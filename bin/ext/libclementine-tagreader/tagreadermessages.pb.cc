// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tagreadermessages.proto

#include "tagreadermessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace cpb {
namespace tagreader {
PROTOBUF_CONSTEXPR SongMetadata::SongMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.album_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.artist_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.albumartist_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.composer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.genre_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.basefilename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.art_automatic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.etag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.performer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.grouping_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lyrics_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.track_)*/0
  , /*decltype(_impl_.disc_)*/0
  , /*decltype(_impl_.bpm_)*/0
  , /*decltype(_impl_.year_)*/0
  , /*decltype(_impl_.valid_)*/false
  , /*decltype(_impl_.compilation_)*/false
  , /*decltype(_impl_.suspicious_tags_)*/false
  , /*decltype(_impl_.rating_)*/0
  , /*decltype(_impl_.playcount_)*/0
  , /*decltype(_impl_.skipcount_)*/0
  , /*decltype(_impl_.lastplayed_)*/0
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_.length_nanosec_)*/uint64_t{0u}
  , /*decltype(_impl_.bitrate_)*/0
  , /*decltype(_impl_.samplerate_)*/0
  , /*decltype(_impl_.mtime_)*/0
  , /*decltype(_impl_.ctime_)*/0
  , /*decltype(_impl_.filesize_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.originalyear_)*/0} {}
struct SongMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SongMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SongMetadataDefaultTypeInternal() {}
  union {
    SongMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SongMetadataDefaultTypeInternal _SongMetadata_default_instance_;
PROTOBUF_CONSTEXPR ReadFileRequest::ReadFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ReadFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadFileRequestDefaultTypeInternal() {}
  union {
    ReadFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadFileRequestDefaultTypeInternal _ReadFileRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadFileResponse::ReadFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ReadFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadFileResponseDefaultTypeInternal() {}
  union {
    ReadFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadFileResponseDefaultTypeInternal _ReadFileResponse_default_instance_;
PROTOBUF_CONSTEXPR SaveFileRequest::SaveFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct SaveFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveFileRequestDefaultTypeInternal() {}
  union {
    SaveFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveFileRequestDefaultTypeInternal _SaveFileRequest_default_instance_;
PROTOBUF_CONSTEXPR SaveFileResponse::SaveFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_)*/false} {}
struct SaveFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveFileResponseDefaultTypeInternal() {}
  union {
    SaveFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveFileResponseDefaultTypeInternal _SaveFileResponse_default_instance_;
PROTOBUF_CONSTEXPR IsMediaFileRequest::IsMediaFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct IsMediaFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IsMediaFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IsMediaFileRequestDefaultTypeInternal() {}
  union {
    IsMediaFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IsMediaFileRequestDefaultTypeInternal _IsMediaFileRequest_default_instance_;
PROTOBUF_CONSTEXPR IsMediaFileResponse::IsMediaFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_)*/false} {}
struct IsMediaFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IsMediaFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IsMediaFileResponseDefaultTypeInternal() {}
  union {
    IsMediaFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IsMediaFileResponseDefaultTypeInternal _IsMediaFileResponse_default_instance_;
PROTOBUF_CONSTEXPR LoadEmbeddedArtRequest::LoadEmbeddedArtRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoadEmbeddedArtRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadEmbeddedArtRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadEmbeddedArtRequestDefaultTypeInternal() {}
  union {
    LoadEmbeddedArtRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadEmbeddedArtRequestDefaultTypeInternal _LoadEmbeddedArtRequest_default_instance_;
PROTOBUF_CONSTEXPR LoadEmbeddedArtResponse::LoadEmbeddedArtResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoadEmbeddedArtResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadEmbeddedArtResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadEmbeddedArtResponseDefaultTypeInternal() {}
  union {
    LoadEmbeddedArtResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadEmbeddedArtResponseDefaultTypeInternal _LoadEmbeddedArtResponse_default_instance_;
PROTOBUF_CONSTEXPR ReadCloudFileRequest::ReadCloudFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.download_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorisation_header_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mime_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/0} {}
struct ReadCloudFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadCloudFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadCloudFileRequestDefaultTypeInternal() {}
  union {
    ReadCloudFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadCloudFileRequestDefaultTypeInternal _ReadCloudFileRequest_default_instance_;
PROTOBUF_CONSTEXPR ReadCloudFileResponse::ReadCloudFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct ReadCloudFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadCloudFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadCloudFileResponseDefaultTypeInternal() {}
  union {
    ReadCloudFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadCloudFileResponseDefaultTypeInternal _ReadCloudFileResponse_default_instance_;
PROTOBUF_CONSTEXPR SaveSongStatisticsToFileRequest::SaveSongStatisticsToFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct SaveSongStatisticsToFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveSongStatisticsToFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveSongStatisticsToFileRequestDefaultTypeInternal() {}
  union {
    SaveSongStatisticsToFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveSongStatisticsToFileRequestDefaultTypeInternal _SaveSongStatisticsToFileRequest_default_instance_;
PROTOBUF_CONSTEXPR SaveSongStatisticsToFileResponse::SaveSongStatisticsToFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_)*/false} {}
struct SaveSongStatisticsToFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveSongStatisticsToFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveSongStatisticsToFileResponseDefaultTypeInternal() {}
  union {
    SaveSongStatisticsToFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveSongStatisticsToFileResponseDefaultTypeInternal _SaveSongStatisticsToFileResponse_default_instance_;
PROTOBUF_CONSTEXPR SaveSongRatingToFileRequest::SaveSongRatingToFileRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr} {}
struct SaveSongRatingToFileRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveSongRatingToFileRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveSongRatingToFileRequestDefaultTypeInternal() {}
  union {
    SaveSongRatingToFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveSongRatingToFileRequestDefaultTypeInternal _SaveSongRatingToFileRequest_default_instance_;
PROTOBUF_CONSTEXPR SaveSongRatingToFileResponse::SaveSongRatingToFileResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.success_)*/false} {}
struct SaveSongRatingToFileResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveSongRatingToFileResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveSongRatingToFileResponseDefaultTypeInternal() {}
  union {
    SaveSongRatingToFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveSongRatingToFileResponseDefaultTypeInternal _SaveSongRatingToFileResponse_default_instance_;
PROTOBUF_CONSTEXPR Message::Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.read_file_request_)*/nullptr
  , /*decltype(_impl_.read_file_response_)*/nullptr
  , /*decltype(_impl_.save_file_request_)*/nullptr
  , /*decltype(_impl_.save_file_response_)*/nullptr
  , /*decltype(_impl_.is_media_file_request_)*/nullptr
  , /*decltype(_impl_.is_media_file_response_)*/nullptr
  , /*decltype(_impl_.load_embedded_art_request_)*/nullptr
  , /*decltype(_impl_.load_embedded_art_response_)*/nullptr
  , /*decltype(_impl_.read_cloud_file_request_)*/nullptr
  , /*decltype(_impl_.read_cloud_file_response_)*/nullptr
  , /*decltype(_impl_.save_song_statistics_to_file_request_)*/nullptr
  , /*decltype(_impl_.save_song_statistics_to_file_response_)*/nullptr
  , /*decltype(_impl_.save_song_rating_to_file_request_)*/nullptr
  , /*decltype(_impl_.save_song_rating_to_file_response_)*/nullptr
  , /*decltype(_impl_.id_)*/0} {}
struct MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageDefaultTypeInternal _Message_default_instance_;
}  // namespace tagreader
}  // namespace cpb
static ::_pb::Metadata file_level_metadata_tagreadermessages_2eproto[16];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_tagreadermessages_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_tagreadermessages_2eproto = nullptr;

const uint32_t TableStruct_tagreadermessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.valid_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.album_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.artist_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.albumartist_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.composer_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.disc_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.bpm_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.year_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.genre_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.compilation_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.rating_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.playcount_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.skipcount_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.lastplayed_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.length_nanosec_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.bitrate_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.samplerate_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.basefilename_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.mtime_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.ctime_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.filesize_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.suspicious_tags_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.art_automatic_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.etag_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.performer_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.grouping_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.lyrics_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SongMetadata, _impl_.originalyear_),
  18,
  0,
  1,
  2,
  3,
  4,
  14,
  15,
  16,
  17,
  5,
  6,
  19,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  7,
  8,
  29,
  30,
  31,
  20,
  9,
  32,
  10,
  11,
  12,
  13,
  33,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadFileRequest, _impl_.filename_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadFileResponse, _impl_.metadata_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileRequest, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileRequest, _impl_.metadata_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveFileResponse, _impl_.success_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::IsMediaFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::IsMediaFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::IsMediaFileRequest, _impl_.filename_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::IsMediaFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::IsMediaFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::IsMediaFileResponse, _impl_.success_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::LoadEmbeddedArtRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::LoadEmbeddedArtRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::LoadEmbeddedArtRequest, _impl_.filename_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::LoadEmbeddedArtResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::LoadEmbeddedArtResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::LoadEmbeddedArtResponse, _impl_.data_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _impl_.download_url_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _impl_.authorisation_header_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileRequest, _impl_.mime_type_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::ReadCloudFileResponse, _impl_.metadata_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileRequest, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileRequest, _impl_.metadata_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongStatisticsToFileResponse, _impl_.success_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileRequest, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileRequest, _impl_.metadata_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::SaveSongRatingToFileResponse, _impl_.success_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.read_file_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.read_file_response_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.save_file_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.save_file_response_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.is_media_file_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.is_media_file_response_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.load_embedded_art_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.load_embedded_art_response_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.read_cloud_file_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.read_cloud_file_response_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.save_song_statistics_to_file_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.save_song_statistics_to_file_response_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.save_song_rating_to_file_request_),
  PROTOBUF_FIELD_OFFSET(::cpb::tagreader::Message, _impl_.save_song_rating_to_file_response_),
  14,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 40, -1, sizeof(::cpb::tagreader::SongMetadata)},
  { 74, 81, -1, sizeof(::cpb::tagreader::ReadFileRequest)},
  { 82, 89, -1, sizeof(::cpb::tagreader::ReadFileResponse)},
  { 90, 98, -1, sizeof(::cpb::tagreader::SaveFileRequest)},
  { 100, 107, -1, sizeof(::cpb::tagreader::SaveFileResponse)},
  { 108, 115, -1, sizeof(::cpb::tagreader::IsMediaFileRequest)},
  { 116, 123, -1, sizeof(::cpb::tagreader::IsMediaFileResponse)},
  { 124, 131, -1, sizeof(::cpb::tagreader::LoadEmbeddedArtRequest)},
  { 132, 139, -1, sizeof(::cpb::tagreader::LoadEmbeddedArtResponse)},
  { 140, 151, -1, sizeof(::cpb::tagreader::ReadCloudFileRequest)},
  { 156, 163, -1, sizeof(::cpb::tagreader::ReadCloudFileResponse)},
  { 164, 172, -1, sizeof(::cpb::tagreader::SaveSongStatisticsToFileRequest)},
  { 174, 181, -1, sizeof(::cpb::tagreader::SaveSongStatisticsToFileResponse)},
  { 182, 190, -1, sizeof(::cpb::tagreader::SaveSongRatingToFileRequest)},
  { 192, 199, -1, sizeof(::cpb::tagreader::SaveSongRatingToFileResponse)},
  { 200, 221, -1, sizeof(::cpb::tagreader::Message)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::cpb::tagreader::_SongMetadata_default_instance_._instance,
  &::cpb::tagreader::_ReadFileRequest_default_instance_._instance,
  &::cpb::tagreader::_ReadFileResponse_default_instance_._instance,
  &::cpb::tagreader::_SaveFileRequest_default_instance_._instance,
  &::cpb::tagreader::_SaveFileResponse_default_instance_._instance,
  &::cpb::tagreader::_IsMediaFileRequest_default_instance_._instance,
  &::cpb::tagreader::_IsMediaFileResponse_default_instance_._instance,
  &::cpb::tagreader::_LoadEmbeddedArtRequest_default_instance_._instance,
  &::cpb::tagreader::_LoadEmbeddedArtResponse_default_instance_._instance,
  &::cpb::tagreader::_ReadCloudFileRequest_default_instance_._instance,
  &::cpb::tagreader::_ReadCloudFileResponse_default_instance_._instance,
  &::cpb::tagreader::_SaveSongStatisticsToFileRequest_default_instance_._instance,
  &::cpb::tagreader::_SaveSongStatisticsToFileResponse_default_instance_._instance,
  &::cpb::tagreader::_SaveSongRatingToFileRequest_default_instance_._instance,
  &::cpb::tagreader::_SaveSongRatingToFileResponse_default_instance_._instance,
  &::cpb::tagreader::_Message_default_instance_._instance,
};

const char descriptor_table_protodef_tagreadermessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027tagreadermessages.proto\022\rcpb.tagreader"
  "\"\357\006\n\014SongMetadata\022\r\n\005valid\030\001 \001(\010\022\r\n\005titl"
  "e\030\002 \001(\t\022\r\n\005album\030\003 \001(\t\022\016\n\006artist\030\004 \001(\t\022\023"
  "\n\013albumartist\030\005 \001(\t\022\020\n\010composer\030\006 \001(\t\022\r\n"
  "\005track\030\007 \001(\005\022\014\n\004disc\030\010 \001(\005\022\013\n\003bpm\030\t \001(\002\022"
  "\014\n\004year\030\n \001(\005\022\r\n\005genre\030\013 \001(\t\022\017\n\007comment\030"
  "\014 \001(\t\022\023\n\013compilation\030\r \001(\010\022\016\n\006rating\030\016 \001"
  "(\002\022\021\n\tplaycount\030\017 \001(\005\022\021\n\tskipcount\030\020 \001(\005"
  "\022\022\n\nlastplayed\030\021 \001(\005\022\r\n\005score\030\022 \001(\005\022\026\n\016l"
  "ength_nanosec\030\023 \001(\004\022\017\n\007bitrate\030\024 \001(\005\022\022\n\n"
  "samplerate\030\025 \001(\005\022\013\n\003url\030\026 \001(\t\022\024\n\014basefil"
  "ename\030\027 \001(\t\022\r\n\005mtime\030\030 \001(\005\022\r\n\005ctime\030\031 \001("
  "\005\022\020\n\010filesize\030\032 \001(\005\022\027\n\017suspicious_tags\030\033"
  " \001(\010\022\025\n\rart_automatic\030\034 \001(\t\022.\n\004type\030\035 \001("
  "\0162 .cpb.tagreader.SongMetadata.Type\022\014\n\004e"
  "tag\030\036 \001(\t\022\021\n\tperformer\030\037 \001(\t\022\020\n\010grouping"
  "\030  \001(\t\022\016\n\006lyrics\030! \001(\t\022\024\n\014originalyear\030\""
  " \001(\005\"\353\001\n\004Type\022\013\n\007UNKNOWN\020\000\022\007\n\003ASF\020\001\022\010\n\004F"
  "LAC\020\002\022\007\n\003MP4\020\003\022\007\n\003MPC\020\004\022\010\n\004MPEG\020\005\022\013\n\007OGG"
  "FLAC\020\006\022\014\n\010OGGSPEEX\020\007\022\r\n\tOGGVORBIS\020\010\022\010\n\004A"
  "IFF\020\t\022\007\n\003WAV\020\n\022\r\n\tTRUEAUDIO\020\013\022\010\n\004CDDA\020\014\022"
  "\013\n\007OGGOPUS\020\r\022\013\n\007WAVPACK\020\016\022\007\n\003SPC\020\017\022\007\n\003VG"
  "M\020\020\022\007\n\003APE\020\021\022\007\n\003DSF\020\022\022\007\n\003DFF\020\023\022\n\n\006STREAM"
  "\020c\"#\n\017ReadFileRequest\022\020\n\010filename\030\001 \001(\t\""
  "A\n\020ReadFileResponse\022-\n\010metadata\030\001 \001(\0132\033."
  "cpb.tagreader.SongMetadata\"R\n\017SaveFileRe"
  "quest\022\020\n\010filename\030\001 \001(\t\022-\n\010metadata\030\002 \001("
  "\0132\033.cpb.tagreader.SongMetadata\"#\n\020SaveFi"
  "leResponse\022\017\n\007success\030\001 \001(\010\"&\n\022IsMediaFi"
  "leRequest\022\020\n\010filename\030\001 \001(\t\"&\n\023IsMediaFi"
  "leResponse\022\017\n\007success\030\001 \001(\010\"*\n\026LoadEmbed"
  "dedArtRequest\022\020\n\010filename\030\001 \001(\t\"\'\n\027LoadE"
  "mbeddedArtResponse\022\014\n\004data\030\001 \001(\014\"z\n\024Read"
  "CloudFileRequest\022\024\n\014download_url\030\001 \001(\t\022\r"
  "\n\005title\030\002 \001(\t\022\014\n\004size\030\003 \001(\005\022\034\n\024authorisa"
  "tion_header\030\004 \001(\t\022\021\n\tmime_type\030\005 \001(\t\"F\n\025"
  "ReadCloudFileResponse\022-\n\010metadata\030\001 \001(\0132"
  "\033.cpb.tagreader.SongMetadata\"b\n\037SaveSong"
  "StatisticsToFileRequest\022\020\n\010filename\030\001 \001("
  "\t\022-\n\010metadata\030\002 \001(\0132\033.cpb.tagreader.Song"
  "Metadata\"3\n SaveSongStatisticsToFileResp"
  "onse\022\017\n\007success\030\001 \001(\010\"^\n\033SaveSongRatingT"
  "oFileRequest\022\020\n\010filename\030\001 \001(\t\022-\n\010metada"
  "ta\030\002 \001(\0132\033.cpb.tagreader.SongMetadata\"/\n"
  "\034SaveSongRatingToFileResponse\022\017\n\007success"
  "\030\001 \001(\010\"\233\010\n\007Message\022\n\n\002id\030\001 \001(\005\0229\n\021read_f"
  "ile_request\030\002 \001(\0132\036.cpb.tagreader.ReadFi"
  "leRequest\022;\n\022read_file_response\030\003 \001(\0132\037."
  "cpb.tagreader.ReadFileResponse\0229\n\021save_f"
  "ile_request\030\004 \001(\0132\036.cpb.tagreader.SaveFi"
  "leRequest\022;\n\022save_file_response\030\005 \001(\0132\037."
  "cpb.tagreader.SaveFileResponse\022@\n\025is_med"
  "ia_file_request\030\006 \001(\0132!.cpb.tagreader.Is"
  "MediaFileRequest\022B\n\026is_media_file_respon"
  "se\030\007 \001(\0132\".cpb.tagreader.IsMediaFileResp"
  "onse\022H\n\031load_embedded_art_request\030\010 \001(\0132"
  "%.cpb.tagreader.LoadEmbeddedArtRequest\022J"
  "\n\032load_embedded_art_response\030\t \001(\0132&.cpb"
  ".tagreader.LoadEmbeddedArtResponse\022D\n\027re"
  "ad_cloud_file_request\030\n \001(\0132#.cpb.tagrea"
  "der.ReadCloudFileRequest\022F\n\030read_cloud_f"
  "ile_response\030\013 \001(\0132$.cpb.tagreader.ReadC"
  "loudFileResponse\022\\\n$save_song_statistics"
  "_to_file_request\030\014 \001(\0132..cpb.tagreader.S"
  "aveSongStatisticsToFileRequest\022^\n%save_s"
  "ong_statistics_to_file_response\030\r \001(\0132/."
  "cpb.tagreader.SaveSongStatisticsToFileRe"
  "sponse\022T\n save_song_rating_to_file_reque"
  "st\030\016 \001(\0132*.cpb.tagreader.SaveSongRatingT"
  "oFileRequest\022V\n!save_song_rating_to_file"
  "_response\030\017 \001(\0132+.cpb.tagreader.SaveSong"
  "RatingToFileResponse"
  ;
static ::_pbi::once_flag descriptor_table_tagreadermessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_tagreadermessages_2eproto = {
    false, false, 2860, descriptor_table_protodef_tagreadermessages_2eproto,
    "tagreadermessages.proto",
    &descriptor_table_tagreadermessages_2eproto_once, nullptr, 0, 16,
    schemas, file_default_instances, TableStruct_tagreadermessages_2eproto::offsets,
    file_level_metadata_tagreadermessages_2eproto, file_level_enum_descriptors_tagreadermessages_2eproto,
    file_level_service_descriptors_tagreadermessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_tagreadermessages_2eproto_getter() {
  return &descriptor_table_tagreadermessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_tagreadermessages_2eproto(&descriptor_table_tagreadermessages_2eproto);
namespace cpb {
namespace tagreader {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SongMetadata_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_tagreadermessages_2eproto);
  return file_level_enum_descriptors_tagreadermessages_2eproto[0];
}
bool SongMetadata_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 99:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SongMetadata_Type SongMetadata::UNKNOWN;
constexpr SongMetadata_Type SongMetadata::ASF;
constexpr SongMetadata_Type SongMetadata::FLAC;
constexpr SongMetadata_Type SongMetadata::MP4;
constexpr SongMetadata_Type SongMetadata::MPC;
constexpr SongMetadata_Type SongMetadata::MPEG;
constexpr SongMetadata_Type SongMetadata::OGGFLAC;
constexpr SongMetadata_Type SongMetadata::OGGSPEEX;
constexpr SongMetadata_Type SongMetadata::OGGVORBIS;
constexpr SongMetadata_Type SongMetadata::AIFF;
constexpr SongMetadata_Type SongMetadata::WAV;
constexpr SongMetadata_Type SongMetadata::TRUEAUDIO;
constexpr SongMetadata_Type SongMetadata::CDDA;
constexpr SongMetadata_Type SongMetadata::OGGOPUS;
constexpr SongMetadata_Type SongMetadata::WAVPACK;
constexpr SongMetadata_Type SongMetadata::SPC;
constexpr SongMetadata_Type SongMetadata::VGM;
constexpr SongMetadata_Type SongMetadata::APE;
constexpr SongMetadata_Type SongMetadata::DSF;
constexpr SongMetadata_Type SongMetadata::DFF;
constexpr SongMetadata_Type SongMetadata::STREAM;
constexpr SongMetadata_Type SongMetadata::Type_MIN;
constexpr SongMetadata_Type SongMetadata::Type_MAX;
constexpr int SongMetadata::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SongMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<SongMetadata>()._impl_._has_bits_);
  static void set_has_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_album(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_artist(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_albumartist(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_composer(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_track(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_disc(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_bpm(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_year(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_genre(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_compilation(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_playcount(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_skipcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_lastplayed(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_length_nanosec(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_bitrate(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_samplerate(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_basefilename(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mtime(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_filesize(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_suspicious_tags(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_art_automatic(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_etag(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_performer(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_grouping(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_lyrics(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_originalyear(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
};

SongMetadata::SongMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SongMetadata)
}
SongMetadata::SongMetadata(const SongMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SongMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.album_){}
    , decltype(_impl_.artist_){}
    , decltype(_impl_.albumartist_){}
    , decltype(_impl_.composer_){}
    , decltype(_impl_.genre_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.basefilename_){}
    , decltype(_impl_.art_automatic_){}
    , decltype(_impl_.etag_){}
    , decltype(_impl_.performer_){}
    , decltype(_impl_.grouping_){}
    , decltype(_impl_.lyrics_){}
    , decltype(_impl_.track_){}
    , decltype(_impl_.disc_){}
    , decltype(_impl_.bpm_){}
    , decltype(_impl_.year_){}
    , decltype(_impl_.valid_){}
    , decltype(_impl_.compilation_){}
    , decltype(_impl_.suspicious_tags_){}
    , decltype(_impl_.rating_){}
    , decltype(_impl_.playcount_){}
    , decltype(_impl_.skipcount_){}
    , decltype(_impl_.lastplayed_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.length_nanosec_){}
    , decltype(_impl_.bitrate_){}
    , decltype(_impl_.samplerate_){}
    , decltype(_impl_.mtime_){}
    , decltype(_impl_.ctime_){}
    , decltype(_impl_.filesize_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.originalyear_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.album_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.album_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_album()) {
    _this->_impl_.album_.Set(from._internal_album(), 
      _this->GetArenaForAllocation());
  }
  _impl_.artist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artist()) {
    _this->_impl_.artist_.Set(from._internal_artist(), 
      _this->GetArenaForAllocation());
  }
  _impl_.albumartist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_albumartist()) {
    _this->_impl_.albumartist_.Set(from._internal_albumartist(), 
      _this->GetArenaForAllocation());
  }
  _impl_.composer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.composer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_composer()) {
    _this->_impl_.composer_.Set(from._internal_composer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.genre_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.genre_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_genre()) {
    _this->_impl_.genre_.Set(from._internal_genre(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comment()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.basefilename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.basefilename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_basefilename()) {
    _this->_impl_.basefilename_.Set(from._internal_basefilename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.art_automatic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_art_automatic()) {
    _this->_impl_.art_automatic_.Set(from._internal_art_automatic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.etag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.etag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_etag()) {
    _this->_impl_.etag_.Set(from._internal_etag(), 
      _this->GetArenaForAllocation());
  }
  _impl_.performer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.performer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_performer()) {
    _this->_impl_.performer_.Set(from._internal_performer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.grouping_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.grouping_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_grouping()) {
    _this->_impl_.grouping_.Set(from._internal_grouping(), 
      _this->GetArenaForAllocation());
  }
  _impl_.lyrics_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lyrics_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lyrics()) {
    _this->_impl_.lyrics_.Set(from._internal_lyrics(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.track_, &from._impl_.track_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.originalyear_) -
    reinterpret_cast<char*>(&_impl_.track_)) + sizeof(_impl_.originalyear_));
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SongMetadata)
}

inline void SongMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.album_){}
    , decltype(_impl_.artist_){}
    , decltype(_impl_.albumartist_){}
    , decltype(_impl_.composer_){}
    , decltype(_impl_.genre_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.basefilename_){}
    , decltype(_impl_.art_automatic_){}
    , decltype(_impl_.etag_){}
    , decltype(_impl_.performer_){}
    , decltype(_impl_.grouping_){}
    , decltype(_impl_.lyrics_){}
    , decltype(_impl_.track_){0}
    , decltype(_impl_.disc_){0}
    , decltype(_impl_.bpm_){0}
    , decltype(_impl_.year_){0}
    , decltype(_impl_.valid_){false}
    , decltype(_impl_.compilation_){false}
    , decltype(_impl_.suspicious_tags_){false}
    , decltype(_impl_.rating_){0}
    , decltype(_impl_.playcount_){0}
    , decltype(_impl_.skipcount_){0}
    , decltype(_impl_.lastplayed_){0}
    , decltype(_impl_.score_){0}
    , decltype(_impl_.length_nanosec_){uint64_t{0u}}
    , decltype(_impl_.bitrate_){0}
    , decltype(_impl_.samplerate_){0}
    , decltype(_impl_.mtime_){0}
    , decltype(_impl_.ctime_){0}
    , decltype(_impl_.filesize_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.originalyear_){0}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.album_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.album_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.artist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.albumartist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.composer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.composer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.genre_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.genre_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.basefilename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.basefilename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.art_automatic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.etag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.etag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.performer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.performer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.grouping_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.grouping_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lyrics_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lyrics_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SongMetadata::~SongMetadata() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SongMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SongMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
  _impl_.album_.Destroy();
  _impl_.artist_.Destroy();
  _impl_.albumartist_.Destroy();
  _impl_.composer_.Destroy();
  _impl_.genre_.Destroy();
  _impl_.comment_.Destroy();
  _impl_.url_.Destroy();
  _impl_.basefilename_.Destroy();
  _impl_.art_automatic_.Destroy();
  _impl_.etag_.Destroy();
  _impl_.performer_.Destroy();
  _impl_.grouping_.Destroy();
  _impl_.lyrics_.Destroy();
}

void SongMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SongMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SongMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.album_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.artist_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.albumartist_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.composer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.genre_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.comment_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.basefilename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.art_automatic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.etag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.performer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      _impl_.grouping_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      _impl_.lyrics_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000c000u) {
    ::memset(&_impl_.track_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.disc_) -
        reinterpret_cast<char*>(&_impl_.track_)) + sizeof(_impl_.disc_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.bpm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.skipcount_) -
        reinterpret_cast<char*>(&_impl_.bpm_)) + sizeof(_impl_.skipcount_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.lastplayed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.filesize_) -
        reinterpret_cast<char*>(&_impl_.lastplayed_)) + sizeof(_impl_.filesize_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.originalyear_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.originalyear_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SongMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool valid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_valid(&_impl_._has_bits_);
          _impl_.valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string album = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_album();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.album");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string artist = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_artist();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.artist");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string albumartist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_albumartist();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.albumartist");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string composer = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_composer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.composer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 track = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_track(&_impl_._has_bits_);
          _impl_.track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 disc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_disc(&_impl_._has_bits_);
          _impl_.disc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float bpm = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_bpm(&_impl_._has_bits_);
          _impl_.bpm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 year = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_year(&_impl_._has_bits_);
          _impl_.year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string genre = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_genre();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.genre");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string comment = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.comment");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool compilation = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_compilation(&_impl_._has_bits_);
          _impl_.compilation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float rating = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_rating(&_impl_._has_bits_);
          _impl_.rating_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 playcount = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_playcount(&_impl_._has_bits_);
          _impl_.playcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 skipcount = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_skipcount(&_impl_._has_bits_);
          _impl_.skipcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 lastplayed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_lastplayed(&_impl_._has_bits_);
          _impl_.lastplayed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 score = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_score(&_impl_._has_bits_);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 length_nanosec = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_length_nanosec(&_impl_._has_bits_);
          _impl_.length_nanosec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bitrate = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_bitrate(&_impl_._has_bits_);
          _impl_.bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 samplerate = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_samplerate(&_impl_._has_bits_);
          _impl_.samplerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string basefilename = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_basefilename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.basefilename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 mtime = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_mtime(&_impl_._has_bits_);
          _impl_.mtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ctime = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_ctime(&_impl_._has_bits_);
          _impl_.ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 filesize = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_filesize(&_impl_._has_bits_);
          _impl_.filesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool suspicious_tags = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_suspicious_tags(&_impl_._has_bits_);
          _impl_.suspicious_tags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string art_automatic = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_art_automatic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.art_automatic");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SongMetadata.Type type = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::tagreader::SongMetadata_Type_IsValid(val))) {
            _internal_set_type(static_cast<::cpb::tagreader::SongMetadata_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(29, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string etag = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          auto str = _internal_mutable_etag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.etag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string performer = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          auto str = _internal_mutable_performer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.performer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string grouping = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_grouping();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.grouping");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string lyrics = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_lyrics();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SongMetadata.lyrics");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 originalyear = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_originalyear(&_impl_._has_bits_);
          _impl_.originalyear_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SongMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SongMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool valid = 1;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_valid(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional string album = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_album().data(), static_cast<int>(this->_internal_album().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.album");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_album(), target);
  }

  // optional string artist = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_artist().data(), static_cast<int>(this->_internal_artist().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.artist");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_artist(), target);
  }

  // optional string albumartist = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_albumartist().data(), static_cast<int>(this->_internal_albumartist().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.albumartist");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_albumartist(), target);
  }

  // optional string composer = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_composer().data(), static_cast<int>(this->_internal_composer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.composer");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_composer(), target);
  }

  // optional int32 track = 7;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_track(), target);
  }

  // optional int32 disc = 8;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_disc(), target);
  }

  // optional float bpm = 9;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_bpm(), target);
  }

  // optional int32 year = 10;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_year(), target);
  }

  // optional string genre = 11;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_genre().data(), static_cast<int>(this->_internal_genre().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.genre");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_genre(), target);
  }

  // optional string comment = 12;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.comment");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_comment(), target);
  }

  // optional bool compilation = 13;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_compilation(), target);
  }

  // optional float rating = 14;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_rating(), target);
  }

  // optional int32 playcount = 15;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_playcount(), target);
  }

  // optional int32 skipcount = 16;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_skipcount(), target);
  }

  // optional int32 lastplayed = 17;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_lastplayed(), target);
  }

  // optional int32 score = 18;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_score(), target);
  }

  // optional uint64 length_nanosec = 19;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_length_nanosec(), target);
  }

  // optional int32 bitrate = 20;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_bitrate(), target);
  }

  // optional int32 samplerate = 21;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_samplerate(), target);
  }

  // optional string url = 22;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.url");
    target = stream->WriteStringMaybeAliased(
        22, this->_internal_url(), target);
  }

  // optional string basefilename = 23;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_basefilename().data(), static_cast<int>(this->_internal_basefilename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.basefilename");
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_basefilename(), target);
  }

  // optional int32 mtime = 24;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_mtime(), target);
  }

  // optional int32 ctime = 25;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_ctime(), target);
  }

  // optional int32 filesize = 26;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(26, this->_internal_filesize(), target);
  }

  // optional bool suspicious_tags = 27;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_suspicious_tags(), target);
  }

  // optional string art_automatic = 28;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_art_automatic().data(), static_cast<int>(this->_internal_art_automatic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.art_automatic");
    target = stream->WriteStringMaybeAliased(
        28, this->_internal_art_automatic(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional .cpb.tagreader.SongMetadata.Type type = 29;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      29, this->_internal_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string etag = 30;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_etag().data(), static_cast<int>(this->_internal_etag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.etag");
    target = stream->WriteStringMaybeAliased(
        30, this->_internal_etag(), target);
  }

  // optional string performer = 31;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_performer().data(), static_cast<int>(this->_internal_performer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.performer");
    target = stream->WriteStringMaybeAliased(
        31, this->_internal_performer(), target);
  }

  // optional string grouping = 32;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_grouping().data(), static_cast<int>(this->_internal_grouping().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.grouping");
    target = stream->WriteStringMaybeAliased(
        32, this->_internal_grouping(), target);
  }

  // optional string lyrics = 33;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_lyrics().data(), static_cast<int>(this->_internal_lyrics().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SongMetadata.lyrics");
    target = stream->WriteStringMaybeAliased(
        33, this->_internal_lyrics(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 originalyear = 34;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(34, this->_internal_originalyear(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SongMetadata)
  return target;
}

size_t SongMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SongMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string title = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string album = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_album());
    }

    // optional string artist = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_artist());
    }

    // optional string albumartist = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_albumartist());
    }

    // optional string composer = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_composer());
    }

    // optional string genre = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_genre());
    }

    // optional string comment = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comment());
    }

    // optional string url = 22;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string basefilename = 23;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_basefilename());
    }

    // optional string art_automatic = 28;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_art_automatic());
    }

    // optional string etag = 30;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_etag());
    }

    // optional string performer = 31;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_performer());
    }

    // optional string grouping = 32;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_grouping());
    }

    // optional string lyrics = 33;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_lyrics());
    }

    // optional int32 track = 7;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_track());
    }

    // optional int32 disc = 8;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_disc());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float bpm = 9;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 4;
    }

    // optional int32 year = 10;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_year());
    }

    // optional bool valid = 1;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool compilation = 13;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 1;
    }

    // optional bool suspicious_tags = 27;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional float rating = 14;
    if (cached_has_bits & 0x00200000u) {
      total_size += 1 + 4;
    }

    // optional int32 playcount = 15;
    if (cached_has_bits & 0x00400000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playcount());
    }

    // optional int32 skipcount = 16;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_skipcount());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional int32 lastplayed = 17;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_lastplayed());
    }

    // optional int32 score = 18;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_score());
    }

    // optional uint64 length_nanosec = 19;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_length_nanosec());
    }

    // optional int32 bitrate = 20;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_bitrate());
    }

    // optional int32 samplerate = 21;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_samplerate());
    }

    // optional int32 mtime = 24;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_mtime());
    }

    // optional int32 ctime = 25;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_ctime());
    }

    // optional int32 filesize = 26;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_filesize());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    // optional .cpb.tagreader.SongMetadata.Type type = 29;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 originalyear = 34;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_originalyear());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SongMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SongMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SongMetadata::GetClassData() const { return &_class_data_; }


void SongMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SongMetadata*>(&to_msg);
  auto& from = static_cast<const SongMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SongMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_album(from._internal_album());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_artist(from._internal_artist());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_albumartist(from._internal_albumartist());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_composer(from._internal_composer());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_genre(from._internal_genre());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_url(from._internal_url());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_basefilename(from._internal_basefilename());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_art_automatic(from._internal_art_automatic());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_etag(from._internal_etag());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_performer(from._internal_performer());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_set_grouping(from._internal_grouping());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_set_lyrics(from._internal_lyrics());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.track_ = from._impl_.track_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.disc_ = from._impl_.disc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.bpm_ = from._impl_.bpm_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.year_ = from._impl_.year_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.valid_ = from._impl_.valid_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.compilation_ = from._impl_.compilation_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.suspicious_tags_ = from._impl_.suspicious_tags_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.rating_ = from._impl_.rating_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.playcount_ = from._impl_.playcount_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.skipcount_ = from._impl_.skipcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.lastplayed_ = from._impl_.lastplayed_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.length_nanosec_ = from._impl_.length_nanosec_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.bitrate_ = from._impl_.bitrate_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.samplerate_ = from._impl_.samplerate_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.mtime_ = from._impl_.mtime_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.ctime_ = from._impl_.ctime_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.filesize_ = from._impl_.filesize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.originalyear_ = from._impl_.originalyear_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SongMetadata::CopyFrom(const SongMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SongMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SongMetadata::IsInitialized() const {
  return true;
}

void SongMetadata::InternalSwap(SongMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.album_, lhs_arena,
      &other->_impl_.album_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.artist_, lhs_arena,
      &other->_impl_.artist_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.albumartist_, lhs_arena,
      &other->_impl_.albumartist_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.composer_, lhs_arena,
      &other->_impl_.composer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.genre_, lhs_arena,
      &other->_impl_.genre_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.basefilename_, lhs_arena,
      &other->_impl_.basefilename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.art_automatic_, lhs_arena,
      &other->_impl_.art_automatic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.etag_, lhs_arena,
      &other->_impl_.etag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.performer_, lhs_arena,
      &other->_impl_.performer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.grouping_, lhs_arena,
      &other->_impl_.grouping_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lyrics_, lhs_arena,
      &other->_impl_.lyrics_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SongMetadata, _impl_.originalyear_)
      + sizeof(SongMetadata::_impl_.originalyear_)
      - PROTOBUF_FIELD_OFFSET(SongMetadata, _impl_.track_)>(
          reinterpret_cast<char*>(&_impl_.track_),
          reinterpret_cast<char*>(&other->_impl_.track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SongMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[0]);
}

// ===================================================================

class ReadFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ReadFileRequest>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReadFileRequest::ReadFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.ReadFileRequest)
}
ReadFileRequest::ReadFileRequest(const ReadFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.ReadFileRequest)
}

inline void ReadFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadFileRequest::~ReadFileRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.ReadFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void ReadFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.ReadFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.ReadFileRequest.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.ReadFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.ReadFileRequest.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.ReadFileRequest)
  return target;
}

size_t ReadFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.ReadFileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string filename = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadFileRequest::GetClassData() const { return &_class_data_; }


void ReadFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadFileRequest*>(&to_msg);
  auto& from = static_cast<const ReadFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.ReadFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_filename()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadFileRequest::CopyFrom(const ReadFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.ReadFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadFileRequest::IsInitialized() const {
  return true;
}

void ReadFileRequest::InternalSwap(ReadFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[1]);
}

// ===================================================================

class ReadFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ReadFileResponse>()._impl_._has_bits_);
  static const ::cpb::tagreader::SongMetadata& metadata(const ReadFileResponse* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cpb::tagreader::SongMetadata&
ReadFileResponse::_Internal::metadata(const ReadFileResponse* msg) {
  return *msg->_impl_.metadata_;
}
ReadFileResponse::ReadFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.ReadFileResponse)
}
ReadFileResponse::ReadFileResponse(const ReadFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::cpb::tagreader::SongMetadata(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.ReadFileResponse)
}

inline void ReadFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ReadFileResponse::~ReadFileResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.ReadFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ReadFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.ReadFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.tagreader.SongMetadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.ReadFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.tagreader.SongMetadata metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.ReadFileResponse)
  return target;
}

size_t ReadFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.ReadFileResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.tagreader.SongMetadata metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadFileResponse::GetClassData() const { return &_class_data_; }


void ReadFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadFileResponse*>(&to_msg);
  auto& from = static_cast<const ReadFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.ReadFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::cpb::tagreader::SongMetadata::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadFileResponse::CopyFrom(const ReadFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.ReadFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadFileResponse::IsInitialized() const {
  return true;
}

void ReadFileResponse::InternalSwap(ReadFileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[2]);
}

// ===================================================================

class SaveFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveFileRequest>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cpb::tagreader::SongMetadata& metadata(const SaveFileRequest* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cpb::tagreader::SongMetadata&
SaveFileRequest::_Internal::metadata(const SaveFileRequest* msg) {
  return *msg->_impl_.metadata_;
}
SaveFileRequest::SaveFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SaveFileRequest)
}
SaveFileRequest::SaveFileRequest(const SaveFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaveFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::cpb::tagreader::SongMetadata(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SaveFileRequest)
}

inline void SaveFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.metadata_){nullptr}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SaveFileRequest::~SaveFileRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SaveFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void SaveFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaveFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SaveFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SaveFileRequest.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SongMetadata metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SaveFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SaveFileRequest.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional .cpb.tagreader.SongMetadata metadata = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SaveFileRequest)
  return target;
}

size_t SaveFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SaveFileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional .cpb.tagreader.SongMetadata metadata = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaveFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveFileRequest::GetClassData() const { return &_class_data_; }


void SaveFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaveFileRequest*>(&to_msg);
  auto& from = static_cast<const SaveFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SaveFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_metadata()->::cpb::tagreader::SongMetadata::MergeFrom(
          from._internal_metadata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveFileRequest::CopyFrom(const SaveFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SaveFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveFileRequest::IsInitialized() const {
  return true;
}

void SaveFileRequest::InternalSwap(SaveFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[3]);
}

// ===================================================================

class SaveFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveFileResponse>()._impl_._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SaveFileResponse::SaveFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SaveFileResponse)
}
SaveFileResponse::SaveFileResponse(const SaveFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaveFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SaveFileResponse)
}

inline void SaveFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){false}
  };
}

SaveFileResponse::~SaveFileResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SaveFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SaveFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaveFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SaveFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SaveFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SaveFileResponse)
  return target;
}

size_t SaveFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SaveFileResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool success = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaveFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveFileResponse::GetClassData() const { return &_class_data_; }


void SaveFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaveFileResponse*>(&to_msg);
  auto& from = static_cast<const SaveFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SaveFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_success()) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveFileResponse::CopyFrom(const SaveFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SaveFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveFileResponse::IsInitialized() const {
  return true;
}

void SaveFileResponse::InternalSwap(SaveFileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[4]);
}

// ===================================================================

class IsMediaFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<IsMediaFileRequest>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IsMediaFileRequest::IsMediaFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.IsMediaFileRequest)
}
IsMediaFileRequest::IsMediaFileRequest(const IsMediaFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IsMediaFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.IsMediaFileRequest)
}

inline void IsMediaFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IsMediaFileRequest::~IsMediaFileRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.IsMediaFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IsMediaFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void IsMediaFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IsMediaFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.IsMediaFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IsMediaFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.IsMediaFileRequest.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IsMediaFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.IsMediaFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.IsMediaFileRequest.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.IsMediaFileRequest)
  return target;
}

size_t IsMediaFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.IsMediaFileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string filename = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IsMediaFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IsMediaFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IsMediaFileRequest::GetClassData() const { return &_class_data_; }


void IsMediaFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IsMediaFileRequest*>(&to_msg);
  auto& from = static_cast<const IsMediaFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.IsMediaFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_filename()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IsMediaFileRequest::CopyFrom(const IsMediaFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.IsMediaFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IsMediaFileRequest::IsInitialized() const {
  return true;
}

void IsMediaFileRequest::InternalSwap(IsMediaFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata IsMediaFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[5]);
}

// ===================================================================

class IsMediaFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<IsMediaFileResponse>()._impl_._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IsMediaFileResponse::IsMediaFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.IsMediaFileResponse)
}
IsMediaFileResponse::IsMediaFileResponse(const IsMediaFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IsMediaFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.IsMediaFileResponse)
}

inline void IsMediaFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){false}
  };
}

IsMediaFileResponse::~IsMediaFileResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.IsMediaFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IsMediaFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IsMediaFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IsMediaFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.IsMediaFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IsMediaFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IsMediaFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.IsMediaFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.IsMediaFileResponse)
  return target;
}

size_t IsMediaFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.IsMediaFileResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool success = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IsMediaFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IsMediaFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IsMediaFileResponse::GetClassData() const { return &_class_data_; }


void IsMediaFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IsMediaFileResponse*>(&to_msg);
  auto& from = static_cast<const IsMediaFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.IsMediaFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_success()) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IsMediaFileResponse::CopyFrom(const IsMediaFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.IsMediaFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IsMediaFileResponse::IsInitialized() const {
  return true;
}

void IsMediaFileResponse::InternalSwap(IsMediaFileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IsMediaFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[6]);
}

// ===================================================================

class LoadEmbeddedArtRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadEmbeddedArtRequest>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoadEmbeddedArtRequest::LoadEmbeddedArtRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.LoadEmbeddedArtRequest)
}
LoadEmbeddedArtRequest::LoadEmbeddedArtRequest(const LoadEmbeddedArtRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadEmbeddedArtRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.LoadEmbeddedArtRequest)
}

inline void LoadEmbeddedArtRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoadEmbeddedArtRequest::~LoadEmbeddedArtRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.LoadEmbeddedArtRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadEmbeddedArtRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void LoadEmbeddedArtRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadEmbeddedArtRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.LoadEmbeddedArtRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadEmbeddedArtRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.LoadEmbeddedArtRequest.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadEmbeddedArtRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.LoadEmbeddedArtRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.LoadEmbeddedArtRequest.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.LoadEmbeddedArtRequest)
  return target;
}

size_t LoadEmbeddedArtRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.LoadEmbeddedArtRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string filename = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadEmbeddedArtRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadEmbeddedArtRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadEmbeddedArtRequest::GetClassData() const { return &_class_data_; }


void LoadEmbeddedArtRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadEmbeddedArtRequest*>(&to_msg);
  auto& from = static_cast<const LoadEmbeddedArtRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.LoadEmbeddedArtRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_filename()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadEmbeddedArtRequest::CopyFrom(const LoadEmbeddedArtRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.LoadEmbeddedArtRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadEmbeddedArtRequest::IsInitialized() const {
  return true;
}

void LoadEmbeddedArtRequest::InternalSwap(LoadEmbeddedArtRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadEmbeddedArtRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[7]);
}

// ===================================================================

class LoadEmbeddedArtResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadEmbeddedArtResponse>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoadEmbeddedArtResponse::LoadEmbeddedArtResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.LoadEmbeddedArtResponse)
}
LoadEmbeddedArtResponse::LoadEmbeddedArtResponse(const LoadEmbeddedArtResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadEmbeddedArtResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.LoadEmbeddedArtResponse)
}

inline void LoadEmbeddedArtResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoadEmbeddedArtResponse::~LoadEmbeddedArtResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.LoadEmbeddedArtResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadEmbeddedArtResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void LoadEmbeddedArtResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadEmbeddedArtResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.LoadEmbeddedArtResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadEmbeddedArtResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadEmbeddedArtResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.LoadEmbeddedArtResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.LoadEmbeddedArtResponse)
  return target;
}

size_t LoadEmbeddedArtResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.LoadEmbeddedArtResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadEmbeddedArtResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadEmbeddedArtResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadEmbeddedArtResponse::GetClassData() const { return &_class_data_; }


void LoadEmbeddedArtResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadEmbeddedArtResponse*>(&to_msg);
  auto& from = static_cast<const LoadEmbeddedArtResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.LoadEmbeddedArtResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadEmbeddedArtResponse::CopyFrom(const LoadEmbeddedArtResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.LoadEmbeddedArtResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadEmbeddedArtResponse::IsInitialized() const {
  return true;
}

void LoadEmbeddedArtResponse::InternalSwap(LoadEmbeddedArtResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadEmbeddedArtResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[8]);
}

// ===================================================================

class ReadCloudFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ReadCloudFileRequest>()._impl_._has_bits_);
  static void set_has_download_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_authorisation_header(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mime_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ReadCloudFileRequest::ReadCloudFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.ReadCloudFileRequest)
}
ReadCloudFileRequest::ReadCloudFileRequest(const ReadCloudFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadCloudFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.download_url_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.authorisation_header_){}
    , decltype(_impl_.mime_type_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.download_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.download_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_download_url()) {
    _this->_impl_.download_url_.Set(from._internal_download_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.authorisation_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorisation_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_authorisation_header()) {
    _this->_impl_.authorisation_header_.Set(from._internal_authorisation_header(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mime_type()) {
    _this->_impl_.mime_type_.Set(from._internal_mime_type(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.size_ = from._impl_.size_;
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.ReadCloudFileRequest)
}

inline void ReadCloudFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.download_url_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.authorisation_header_){}
    , decltype(_impl_.mime_type_){}
    , decltype(_impl_.size_){0}
  };
  _impl_.download_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.download_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authorisation_header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.authorisation_header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReadCloudFileRequest::~ReadCloudFileRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.ReadCloudFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadCloudFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.download_url_.Destroy();
  _impl_.title_.Destroy();
  _impl_.authorisation_header_.Destroy();
  _impl_.mime_type_.Destroy();
}

void ReadCloudFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadCloudFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.ReadCloudFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.download_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.authorisation_header_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.mime_type_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.size_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadCloudFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string download_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_download_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.ReadCloudFileRequest.download_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.ReadCloudFileRequest.title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string authorisation_header = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_authorisation_header();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.ReadCloudFileRequest.authorisation_header");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string mime_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mime_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.ReadCloudFileRequest.mime_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadCloudFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.ReadCloudFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string download_url = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_download_url().data(), static_cast<int>(this->_internal_download_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.ReadCloudFileRequest.download_url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_download_url(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.ReadCloudFileRequest.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional int32 size = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_size(), target);
  }

  // optional string authorisation_header = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_authorisation_header().data(), static_cast<int>(this->_internal_authorisation_header().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.ReadCloudFileRequest.authorisation_header");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_authorisation_header(), target);
  }

  // optional string mime_type = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mime_type().data(), static_cast<int>(this->_internal_mime_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.ReadCloudFileRequest.mime_type");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_mime_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.ReadCloudFileRequest)
  return target;
}

size_t ReadCloudFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.ReadCloudFileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string download_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_download_url());
    }

    // optional string title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string authorisation_header = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_authorisation_header());
    }

    // optional string mime_type = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mime_type());
    }

    // optional int32 size = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadCloudFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadCloudFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadCloudFileRequest::GetClassData() const { return &_class_data_; }


void ReadCloudFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadCloudFileRequest*>(&to_msg);
  auto& from = static_cast<const ReadCloudFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.ReadCloudFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_download_url(from._internal_download_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_authorisation_header(from._internal_authorisation_header());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_mime_type(from._internal_mime_type());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadCloudFileRequest::CopyFrom(const ReadCloudFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.ReadCloudFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadCloudFileRequest::IsInitialized() const {
  return true;
}

void ReadCloudFileRequest::InternalSwap(ReadCloudFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.download_url_, lhs_arena,
      &other->_impl_.download_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.authorisation_header_, lhs_arena,
      &other->_impl_.authorisation_header_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mime_type_, lhs_arena,
      &other->_impl_.mime_type_, rhs_arena
  );
  swap(_impl_.size_, other->_impl_.size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadCloudFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[9]);
}

// ===================================================================

class ReadCloudFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ReadCloudFileResponse>()._impl_._has_bits_);
  static const ::cpb::tagreader::SongMetadata& metadata(const ReadCloudFileResponse* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cpb::tagreader::SongMetadata&
ReadCloudFileResponse::_Internal::metadata(const ReadCloudFileResponse* msg) {
  return *msg->_impl_.metadata_;
}
ReadCloudFileResponse::ReadCloudFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.ReadCloudFileResponse)
}
ReadCloudFileResponse::ReadCloudFileResponse(const ReadCloudFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReadCloudFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::cpb::tagreader::SongMetadata(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.ReadCloudFileResponse)
}

inline void ReadCloudFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.metadata_){nullptr}
  };
}

ReadCloudFileResponse::~ReadCloudFileResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.ReadCloudFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadCloudFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void ReadCloudFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadCloudFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.ReadCloudFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
    _impl_.metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReadCloudFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.tagreader.SongMetadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadCloudFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.ReadCloudFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.tagreader.SongMetadata metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.ReadCloudFileResponse)
  return target;
}

size_t ReadCloudFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.ReadCloudFileResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.tagreader.SongMetadata metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReadCloudFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReadCloudFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReadCloudFileResponse::GetClassData() const { return &_class_data_; }


void ReadCloudFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReadCloudFileResponse*>(&to_msg);
  auto& from = static_cast<const ReadCloudFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.ReadCloudFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::cpb::tagreader::SongMetadata::MergeFrom(
        from._internal_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReadCloudFileResponse::CopyFrom(const ReadCloudFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.ReadCloudFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadCloudFileResponse::IsInitialized() const {
  return true;
}

void ReadCloudFileResponse::InternalSwap(ReadCloudFileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReadCloudFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[10]);
}

// ===================================================================

class SaveSongStatisticsToFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveSongStatisticsToFileRequest>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cpb::tagreader::SongMetadata& metadata(const SaveSongStatisticsToFileRequest* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cpb::tagreader::SongMetadata&
SaveSongStatisticsToFileRequest::_Internal::metadata(const SaveSongStatisticsToFileRequest* msg) {
  return *msg->_impl_.metadata_;
}
SaveSongStatisticsToFileRequest::SaveSongStatisticsToFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SaveSongStatisticsToFileRequest)
}
SaveSongStatisticsToFileRequest::SaveSongStatisticsToFileRequest(const SaveSongStatisticsToFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaveSongStatisticsToFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::cpb::tagreader::SongMetadata(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SaveSongStatisticsToFileRequest)
}

inline void SaveSongStatisticsToFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.metadata_){nullptr}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SaveSongStatisticsToFileRequest::~SaveSongStatisticsToFileRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SaveSongStatisticsToFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveSongStatisticsToFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void SaveSongStatisticsToFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaveSongStatisticsToFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SaveSongStatisticsToFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveSongStatisticsToFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SaveSongStatisticsToFileRequest.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SongMetadata metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveSongStatisticsToFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SaveSongStatisticsToFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SaveSongStatisticsToFileRequest.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional .cpb.tagreader.SongMetadata metadata = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SaveSongStatisticsToFileRequest)
  return target;
}

size_t SaveSongStatisticsToFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SaveSongStatisticsToFileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional .cpb.tagreader.SongMetadata metadata = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveSongStatisticsToFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaveSongStatisticsToFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveSongStatisticsToFileRequest::GetClassData() const { return &_class_data_; }


void SaveSongStatisticsToFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaveSongStatisticsToFileRequest*>(&to_msg);
  auto& from = static_cast<const SaveSongStatisticsToFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SaveSongStatisticsToFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_metadata()->::cpb::tagreader::SongMetadata::MergeFrom(
          from._internal_metadata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveSongStatisticsToFileRequest::CopyFrom(const SaveSongStatisticsToFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SaveSongStatisticsToFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveSongStatisticsToFileRequest::IsInitialized() const {
  return true;
}

void SaveSongStatisticsToFileRequest::InternalSwap(SaveSongStatisticsToFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveSongStatisticsToFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[11]);
}

// ===================================================================

class SaveSongStatisticsToFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveSongStatisticsToFileResponse>()._impl_._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SaveSongStatisticsToFileResponse::SaveSongStatisticsToFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SaveSongStatisticsToFileResponse)
}
SaveSongStatisticsToFileResponse::SaveSongStatisticsToFileResponse(const SaveSongStatisticsToFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaveSongStatisticsToFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SaveSongStatisticsToFileResponse)
}

inline void SaveSongStatisticsToFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){false}
  };
}

SaveSongStatisticsToFileResponse::~SaveSongStatisticsToFileResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SaveSongStatisticsToFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveSongStatisticsToFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SaveSongStatisticsToFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaveSongStatisticsToFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SaveSongStatisticsToFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveSongStatisticsToFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveSongStatisticsToFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SaveSongStatisticsToFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SaveSongStatisticsToFileResponse)
  return target;
}

size_t SaveSongStatisticsToFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SaveSongStatisticsToFileResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool success = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveSongStatisticsToFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaveSongStatisticsToFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveSongStatisticsToFileResponse::GetClassData() const { return &_class_data_; }


void SaveSongStatisticsToFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaveSongStatisticsToFileResponse*>(&to_msg);
  auto& from = static_cast<const SaveSongStatisticsToFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SaveSongStatisticsToFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_success()) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveSongStatisticsToFileResponse::CopyFrom(const SaveSongStatisticsToFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SaveSongStatisticsToFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveSongStatisticsToFileResponse::IsInitialized() const {
  return true;
}

void SaveSongStatisticsToFileResponse::InternalSwap(SaveSongStatisticsToFileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveSongStatisticsToFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[12]);
}

// ===================================================================

class SaveSongRatingToFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveSongRatingToFileRequest>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cpb::tagreader::SongMetadata& metadata(const SaveSongRatingToFileRequest* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cpb::tagreader::SongMetadata&
SaveSongRatingToFileRequest::_Internal::metadata(const SaveSongRatingToFileRequest* msg) {
  return *msg->_impl_.metadata_;
}
SaveSongRatingToFileRequest::SaveSongRatingToFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SaveSongRatingToFileRequest)
}
SaveSongRatingToFileRequest::SaveSongRatingToFileRequest(const SaveSongRatingToFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaveSongRatingToFileRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::cpb::tagreader::SongMetadata(*from._impl_.metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SaveSongRatingToFileRequest)
}

inline void SaveSongRatingToFileRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.metadata_){nullptr}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SaveSongRatingToFileRequest::~SaveSongRatingToFileRequest() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SaveSongRatingToFileRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveSongRatingToFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void SaveSongRatingToFileRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaveSongRatingToFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SaveSongRatingToFileRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
      _impl_.metadata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveSongRatingToFileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.tagreader.SaveSongRatingToFileRequest.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SongMetadata metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveSongRatingToFileRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SaveSongRatingToFileRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.tagreader.SaveSongRatingToFileRequest.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional .cpb.tagreader.SongMetadata metadata = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SaveSongRatingToFileRequest)
  return target;
}

size_t SaveSongRatingToFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SaveSongRatingToFileRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional .cpb.tagreader.SongMetadata metadata = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.metadata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveSongRatingToFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaveSongRatingToFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveSongRatingToFileRequest::GetClassData() const { return &_class_data_; }


void SaveSongRatingToFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaveSongRatingToFileRequest*>(&to_msg);
  auto& from = static_cast<const SaveSongRatingToFileRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SaveSongRatingToFileRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_metadata()->::cpb::tagreader::SongMetadata::MergeFrom(
          from._internal_metadata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveSongRatingToFileRequest::CopyFrom(const SaveSongRatingToFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SaveSongRatingToFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveSongRatingToFileRequest::IsInitialized() const {
  return true;
}

void SaveSongRatingToFileRequest::InternalSwap(SaveSongRatingToFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  swap(_impl_.metadata_, other->_impl_.metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveSongRatingToFileRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[13]);
}

// ===================================================================

class SaveSongRatingToFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveSongRatingToFileResponse>()._impl_._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SaveSongRatingToFileResponse::SaveSongRatingToFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.SaveSongRatingToFileResponse)
}
SaveSongRatingToFileResponse::SaveSongRatingToFileResponse(const SaveSongRatingToFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SaveSongRatingToFileResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.SaveSongRatingToFileResponse)
}

inline void SaveSongRatingToFileResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.success_){false}
  };
}

SaveSongRatingToFileResponse::~SaveSongRatingToFileResponse() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.SaveSongRatingToFileResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveSongRatingToFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SaveSongRatingToFileResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SaveSongRatingToFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.SaveSongRatingToFileResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.success_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SaveSongRatingToFileResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveSongRatingToFileResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.SaveSongRatingToFileResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool success = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.SaveSongRatingToFileResponse)
  return target;
}

size_t SaveSongRatingToFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.SaveSongRatingToFileResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool success = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SaveSongRatingToFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SaveSongRatingToFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SaveSongRatingToFileResponse::GetClassData() const { return &_class_data_; }


void SaveSongRatingToFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SaveSongRatingToFileResponse*>(&to_msg);
  auto& from = static_cast<const SaveSongRatingToFileResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.SaveSongRatingToFileResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_success()) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SaveSongRatingToFileResponse::CopyFrom(const SaveSongRatingToFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.SaveSongRatingToFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveSongRatingToFileResponse::IsInitialized() const {
  return true;
}

void SaveSongRatingToFileResponse::InternalSwap(SaveSongRatingToFileResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SaveSongRatingToFileResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[14]);
}

// ===================================================================

class Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Message>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::cpb::tagreader::ReadFileRequest& read_file_request(const Message* msg);
  static void set_has_read_file_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cpb::tagreader::ReadFileResponse& read_file_response(const Message* msg);
  static void set_has_read_file_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::cpb::tagreader::SaveFileRequest& save_file_request(const Message* msg);
  static void set_has_save_file_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::cpb::tagreader::SaveFileResponse& save_file_response(const Message* msg);
  static void set_has_save_file_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::cpb::tagreader::IsMediaFileRequest& is_media_file_request(const Message* msg);
  static void set_has_is_media_file_request(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::cpb::tagreader::IsMediaFileResponse& is_media_file_response(const Message* msg);
  static void set_has_is_media_file_response(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::cpb::tagreader::LoadEmbeddedArtRequest& load_embedded_art_request(const Message* msg);
  static void set_has_load_embedded_art_request(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::cpb::tagreader::LoadEmbeddedArtResponse& load_embedded_art_response(const Message* msg);
  static void set_has_load_embedded_art_response(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::cpb::tagreader::ReadCloudFileRequest& read_cloud_file_request(const Message* msg);
  static void set_has_read_cloud_file_request(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::cpb::tagreader::ReadCloudFileResponse& read_cloud_file_response(const Message* msg);
  static void set_has_read_cloud_file_response(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::cpb::tagreader::SaveSongStatisticsToFileRequest& save_song_statistics_to_file_request(const Message* msg);
  static void set_has_save_song_statistics_to_file_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::cpb::tagreader::SaveSongStatisticsToFileResponse& save_song_statistics_to_file_response(const Message* msg);
  static void set_has_save_song_statistics_to_file_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::cpb::tagreader::SaveSongRatingToFileRequest& save_song_rating_to_file_request(const Message* msg);
  static void set_has_save_song_rating_to_file_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::cpb::tagreader::SaveSongRatingToFileResponse& save_song_rating_to_file_response(const Message* msg);
  static void set_has_save_song_rating_to_file_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::cpb::tagreader::ReadFileRequest&
Message::_Internal::read_file_request(const Message* msg) {
  return *msg->_impl_.read_file_request_;
}
const ::cpb::tagreader::ReadFileResponse&
Message::_Internal::read_file_response(const Message* msg) {
  return *msg->_impl_.read_file_response_;
}
const ::cpb::tagreader::SaveFileRequest&
Message::_Internal::save_file_request(const Message* msg) {
  return *msg->_impl_.save_file_request_;
}
const ::cpb::tagreader::SaveFileResponse&
Message::_Internal::save_file_response(const Message* msg) {
  return *msg->_impl_.save_file_response_;
}
const ::cpb::tagreader::IsMediaFileRequest&
Message::_Internal::is_media_file_request(const Message* msg) {
  return *msg->_impl_.is_media_file_request_;
}
const ::cpb::tagreader::IsMediaFileResponse&
Message::_Internal::is_media_file_response(const Message* msg) {
  return *msg->_impl_.is_media_file_response_;
}
const ::cpb::tagreader::LoadEmbeddedArtRequest&
Message::_Internal::load_embedded_art_request(const Message* msg) {
  return *msg->_impl_.load_embedded_art_request_;
}
const ::cpb::tagreader::LoadEmbeddedArtResponse&
Message::_Internal::load_embedded_art_response(const Message* msg) {
  return *msg->_impl_.load_embedded_art_response_;
}
const ::cpb::tagreader::ReadCloudFileRequest&
Message::_Internal::read_cloud_file_request(const Message* msg) {
  return *msg->_impl_.read_cloud_file_request_;
}
const ::cpb::tagreader::ReadCloudFileResponse&
Message::_Internal::read_cloud_file_response(const Message* msg) {
  return *msg->_impl_.read_cloud_file_response_;
}
const ::cpb::tagreader::SaveSongStatisticsToFileRequest&
Message::_Internal::save_song_statistics_to_file_request(const Message* msg) {
  return *msg->_impl_.save_song_statistics_to_file_request_;
}
const ::cpb::tagreader::SaveSongStatisticsToFileResponse&
Message::_Internal::save_song_statistics_to_file_response(const Message* msg) {
  return *msg->_impl_.save_song_statistics_to_file_response_;
}
const ::cpb::tagreader::SaveSongRatingToFileRequest&
Message::_Internal::save_song_rating_to_file_request(const Message* msg) {
  return *msg->_impl_.save_song_rating_to_file_request_;
}
const ::cpb::tagreader::SaveSongRatingToFileResponse&
Message::_Internal::save_song_rating_to_file_response(const Message* msg) {
  return *msg->_impl_.save_song_rating_to_file_response_;
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.tagreader.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.read_file_request_){nullptr}
    , decltype(_impl_.read_file_response_){nullptr}
    , decltype(_impl_.save_file_request_){nullptr}
    , decltype(_impl_.save_file_response_){nullptr}
    , decltype(_impl_.is_media_file_request_){nullptr}
    , decltype(_impl_.is_media_file_response_){nullptr}
    , decltype(_impl_.load_embedded_art_request_){nullptr}
    , decltype(_impl_.load_embedded_art_response_){nullptr}
    , decltype(_impl_.read_cloud_file_request_){nullptr}
    , decltype(_impl_.read_cloud_file_response_){nullptr}
    , decltype(_impl_.save_song_statistics_to_file_request_){nullptr}
    , decltype(_impl_.save_song_statistics_to_file_response_){nullptr}
    , decltype(_impl_.save_song_rating_to_file_request_){nullptr}
    , decltype(_impl_.save_song_rating_to_file_response_){nullptr}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_read_file_request()) {
    _this->_impl_.read_file_request_ = new ::cpb::tagreader::ReadFileRequest(*from._impl_.read_file_request_);
  }
  if (from._internal_has_read_file_response()) {
    _this->_impl_.read_file_response_ = new ::cpb::tagreader::ReadFileResponse(*from._impl_.read_file_response_);
  }
  if (from._internal_has_save_file_request()) {
    _this->_impl_.save_file_request_ = new ::cpb::tagreader::SaveFileRequest(*from._impl_.save_file_request_);
  }
  if (from._internal_has_save_file_response()) {
    _this->_impl_.save_file_response_ = new ::cpb::tagreader::SaveFileResponse(*from._impl_.save_file_response_);
  }
  if (from._internal_has_is_media_file_request()) {
    _this->_impl_.is_media_file_request_ = new ::cpb::tagreader::IsMediaFileRequest(*from._impl_.is_media_file_request_);
  }
  if (from._internal_has_is_media_file_response()) {
    _this->_impl_.is_media_file_response_ = new ::cpb::tagreader::IsMediaFileResponse(*from._impl_.is_media_file_response_);
  }
  if (from._internal_has_load_embedded_art_request()) {
    _this->_impl_.load_embedded_art_request_ = new ::cpb::tagreader::LoadEmbeddedArtRequest(*from._impl_.load_embedded_art_request_);
  }
  if (from._internal_has_load_embedded_art_response()) {
    _this->_impl_.load_embedded_art_response_ = new ::cpb::tagreader::LoadEmbeddedArtResponse(*from._impl_.load_embedded_art_response_);
  }
  if (from._internal_has_read_cloud_file_request()) {
    _this->_impl_.read_cloud_file_request_ = new ::cpb::tagreader::ReadCloudFileRequest(*from._impl_.read_cloud_file_request_);
  }
  if (from._internal_has_read_cloud_file_response()) {
    _this->_impl_.read_cloud_file_response_ = new ::cpb::tagreader::ReadCloudFileResponse(*from._impl_.read_cloud_file_response_);
  }
  if (from._internal_has_save_song_statistics_to_file_request()) {
    _this->_impl_.save_song_statistics_to_file_request_ = new ::cpb::tagreader::SaveSongStatisticsToFileRequest(*from._impl_.save_song_statistics_to_file_request_);
  }
  if (from._internal_has_save_song_statistics_to_file_response()) {
    _this->_impl_.save_song_statistics_to_file_response_ = new ::cpb::tagreader::SaveSongStatisticsToFileResponse(*from._impl_.save_song_statistics_to_file_response_);
  }
  if (from._internal_has_save_song_rating_to_file_request()) {
    _this->_impl_.save_song_rating_to_file_request_ = new ::cpb::tagreader::SaveSongRatingToFileRequest(*from._impl_.save_song_rating_to_file_request_);
  }
  if (from._internal_has_save_song_rating_to_file_response()) {
    _this->_impl_.save_song_rating_to_file_response_ = new ::cpb::tagreader::SaveSongRatingToFileResponse(*from._impl_.save_song_rating_to_file_response_);
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:cpb.tagreader.Message)
}

inline void Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.read_file_request_){nullptr}
    , decltype(_impl_.read_file_response_){nullptr}
    , decltype(_impl_.save_file_request_){nullptr}
    , decltype(_impl_.save_file_response_){nullptr}
    , decltype(_impl_.is_media_file_request_){nullptr}
    , decltype(_impl_.is_media_file_response_){nullptr}
    , decltype(_impl_.load_embedded_art_request_){nullptr}
    , decltype(_impl_.load_embedded_art_response_){nullptr}
    , decltype(_impl_.read_cloud_file_request_){nullptr}
    , decltype(_impl_.read_cloud_file_response_){nullptr}
    , decltype(_impl_.save_song_statistics_to_file_request_){nullptr}
    , decltype(_impl_.save_song_statistics_to_file_response_){nullptr}
    , decltype(_impl_.save_song_rating_to_file_request_){nullptr}
    , decltype(_impl_.save_song_rating_to_file_response_){nullptr}
    , decltype(_impl_.id_){0}
  };
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:cpb.tagreader.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.read_file_request_;
  if (this != internal_default_instance()) delete _impl_.read_file_response_;
  if (this != internal_default_instance()) delete _impl_.save_file_request_;
  if (this != internal_default_instance()) delete _impl_.save_file_response_;
  if (this != internal_default_instance()) delete _impl_.is_media_file_request_;
  if (this != internal_default_instance()) delete _impl_.is_media_file_response_;
  if (this != internal_default_instance()) delete _impl_.load_embedded_art_request_;
  if (this != internal_default_instance()) delete _impl_.load_embedded_art_response_;
  if (this != internal_default_instance()) delete _impl_.read_cloud_file_request_;
  if (this != internal_default_instance()) delete _impl_.read_cloud_file_response_;
  if (this != internal_default_instance()) delete _impl_.save_song_statistics_to_file_request_;
  if (this != internal_default_instance()) delete _impl_.save_song_statistics_to_file_response_;
  if (this != internal_default_instance()) delete _impl_.save_song_rating_to_file_request_;
  if (this != internal_default_instance()) delete _impl_.save_song_rating_to_file_response_;
}

void Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.tagreader.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.read_file_request_ != nullptr);
      _impl_.read_file_request_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.read_file_response_ != nullptr);
      _impl_.read_file_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.save_file_request_ != nullptr);
      _impl_.save_file_request_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.save_file_response_ != nullptr);
      _impl_.save_file_response_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.is_media_file_request_ != nullptr);
      _impl_.is_media_file_request_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.is_media_file_response_ != nullptr);
      _impl_.is_media_file_response_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.load_embedded_art_request_ != nullptr);
      _impl_.load_embedded_art_request_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.load_embedded_art_response_ != nullptr);
      _impl_.load_embedded_art_response_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.read_cloud_file_request_ != nullptr);
      _impl_.read_cloud_file_request_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.read_cloud_file_response_ != nullptr);
      _impl_.read_cloud_file_response_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.save_song_statistics_to_file_request_ != nullptr);
      _impl_.save_song_statistics_to_file_request_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.save_song_statistics_to_file_response_ != nullptr);
      _impl_.save_song_statistics_to_file_response_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.save_song_rating_to_file_request_ != nullptr);
      _impl_.save_song_rating_to_file_request_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.save_song_rating_to_file_response_ != nullptr);
      _impl_.save_song_rating_to_file_response_->Clear();
    }
  }
  _impl_.id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.ReadFileRequest read_file_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_read_file_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.ReadFileResponse read_file_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_read_file_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SaveFileRequest save_file_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_file_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SaveFileResponse save_file_response = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_file_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.IsMediaFileRequest is_media_file_request = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_is_media_file_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.IsMediaFileResponse is_media_file_response = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_is_media_file_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_load_embedded_art_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_load_embedded_art_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.ReadCloudFileRequest read_cloud_file_request = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_read_cloud_file_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.ReadCloudFileResponse read_cloud_file_response = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_read_cloud_file_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SaveSongStatisticsToFileRequest save_song_statistics_to_file_request = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_song_statistics_to_file_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SaveSongStatisticsToFileResponse save_song_statistics_to_file_response = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_song_statistics_to_file_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SaveSongRatingToFileRequest save_song_rating_to_file_request = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_song_rating_to_file_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.tagreader.SaveSongRatingToFileResponse save_song_rating_to_file_response = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_song_rating_to_file_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.tagreader.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional .cpb.tagreader.ReadFileRequest read_file_request = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::read_file_request(this),
        _Internal::read_file_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.ReadFileResponse read_file_response = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::read_file_response(this),
        _Internal::read_file_response(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.SaveFileRequest save_file_request = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::save_file_request(this),
        _Internal::save_file_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.SaveFileResponse save_file_response = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::save_file_response(this),
        _Internal::save_file_response(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.IsMediaFileRequest is_media_file_request = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::is_media_file_request(this),
        _Internal::is_media_file_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.IsMediaFileResponse is_media_file_response = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::is_media_file_response(this),
        _Internal::is_media_file_response(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::load_embedded_art_request(this),
        _Internal::load_embedded_art_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::load_embedded_art_response(this),
        _Internal::load_embedded_art_response(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.ReadCloudFileRequest read_cloud_file_request = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::read_cloud_file_request(this),
        _Internal::read_cloud_file_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.ReadCloudFileResponse read_cloud_file_response = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::read_cloud_file_response(this),
        _Internal::read_cloud_file_response(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.SaveSongStatisticsToFileRequest save_song_statistics_to_file_request = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::save_song_statistics_to_file_request(this),
        _Internal::save_song_statistics_to_file_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.SaveSongStatisticsToFileResponse save_song_statistics_to_file_response = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::save_song_statistics_to_file_response(this),
        _Internal::save_song_statistics_to_file_response(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.SaveSongRatingToFileRequest save_song_rating_to_file_request = 14;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::save_song_rating_to_file_request(this),
        _Internal::save_song_rating_to_file_request(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.tagreader.SaveSongRatingToFileResponse save_song_rating_to_file_response = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::save_song_rating_to_file_response(this),
        _Internal::save_song_rating_to_file_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.tagreader.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.tagreader.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .cpb.tagreader.ReadFileRequest read_file_request = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.read_file_request_);
    }

    // optional .cpb.tagreader.ReadFileResponse read_file_response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.read_file_response_);
    }

    // optional .cpb.tagreader.SaveFileRequest save_file_request = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.save_file_request_);
    }

    // optional .cpb.tagreader.SaveFileResponse save_file_response = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.save_file_response_);
    }

    // optional .cpb.tagreader.IsMediaFileRequest is_media_file_request = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.is_media_file_request_);
    }

    // optional .cpb.tagreader.IsMediaFileResponse is_media_file_response = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.is_media_file_response_);
    }

    // optional .cpb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.load_embedded_art_request_);
    }

    // optional .cpb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.load_embedded_art_response_);
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional .cpb.tagreader.ReadCloudFileRequest read_cloud_file_request = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.read_cloud_file_request_);
    }

    // optional .cpb.tagreader.ReadCloudFileResponse read_cloud_file_response = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.read_cloud_file_response_);
    }

    // optional .cpb.tagreader.SaveSongStatisticsToFileRequest save_song_statistics_to_file_request = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.save_song_statistics_to_file_request_);
    }

    // optional .cpb.tagreader.SaveSongStatisticsToFileResponse save_song_statistics_to_file_response = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.save_song_statistics_to_file_response_);
    }

    // optional .cpb.tagreader.SaveSongRatingToFileRequest save_song_rating_to_file_request = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.save_song_rating_to_file_request_);
    }

    // optional .cpb.tagreader.SaveSongRatingToFileResponse save_song_rating_to_file_response = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.save_song_rating_to_file_response_);
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }


void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message*>(&to_msg);
  auto& from = static_cast<const Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.tagreader.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_read_file_request()->::cpb::tagreader::ReadFileRequest::MergeFrom(
          from._internal_read_file_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_read_file_response()->::cpb::tagreader::ReadFileResponse::MergeFrom(
          from._internal_read_file_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_save_file_request()->::cpb::tagreader::SaveFileRequest::MergeFrom(
          from._internal_save_file_request());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_save_file_response()->::cpb::tagreader::SaveFileResponse::MergeFrom(
          from._internal_save_file_response());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_is_media_file_request()->::cpb::tagreader::IsMediaFileRequest::MergeFrom(
          from._internal_is_media_file_request());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_is_media_file_response()->::cpb::tagreader::IsMediaFileResponse::MergeFrom(
          from._internal_is_media_file_response());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_load_embedded_art_request()->::cpb::tagreader::LoadEmbeddedArtRequest::MergeFrom(
          from._internal_load_embedded_art_request());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_load_embedded_art_response()->::cpb::tagreader::LoadEmbeddedArtResponse::MergeFrom(
          from._internal_load_embedded_art_response());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_read_cloud_file_request()->::cpb::tagreader::ReadCloudFileRequest::MergeFrom(
          from._internal_read_cloud_file_request());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_read_cloud_file_response()->::cpb::tagreader::ReadCloudFileResponse::MergeFrom(
          from._internal_read_cloud_file_response());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_save_song_statistics_to_file_request()->::cpb::tagreader::SaveSongStatisticsToFileRequest::MergeFrom(
          from._internal_save_song_statistics_to_file_request());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_save_song_statistics_to_file_response()->::cpb::tagreader::SaveSongStatisticsToFileResponse::MergeFrom(
          from._internal_save_song_statistics_to_file_response());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_save_song_rating_to_file_request()->::cpb::tagreader::SaveSongRatingToFileRequest::MergeFrom(
          from._internal_save_song_rating_to_file_request());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_save_song_rating_to_file_response()->::cpb::tagreader::SaveSongRatingToFileResponse::MergeFrom(
          from._internal_save_song_rating_to_file_response());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.tagreader.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, _impl_.id_)
      + sizeof(Message::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(Message, _impl_.read_file_request_)>(
          reinterpret_cast<char*>(&_impl_.read_file_request_),
          reinterpret_cast<char*>(&other->_impl_.read_file_request_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_tagreadermessages_2eproto_getter, &descriptor_table_tagreadermessages_2eproto_once,
      file_level_metadata_tagreadermessages_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace tagreader
}  // namespace cpb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SongMetadata*
Arena::CreateMaybeMessage< ::cpb::tagreader::SongMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SongMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::ReadFileRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::ReadFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::ReadFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::ReadFileResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::ReadFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::ReadFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SaveFileRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::SaveFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SaveFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SaveFileResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::SaveFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SaveFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::IsMediaFileRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::IsMediaFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::IsMediaFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::IsMediaFileResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::IsMediaFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::IsMediaFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::LoadEmbeddedArtRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::LoadEmbeddedArtRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::LoadEmbeddedArtRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::LoadEmbeddedArtResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::LoadEmbeddedArtResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::LoadEmbeddedArtResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::ReadCloudFileRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::ReadCloudFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::ReadCloudFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::ReadCloudFileResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::ReadCloudFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::ReadCloudFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SaveSongStatisticsToFileRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::SaveSongStatisticsToFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SaveSongStatisticsToFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SaveSongStatisticsToFileResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::SaveSongStatisticsToFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SaveSongStatisticsToFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SaveSongRatingToFileRequest*
Arena::CreateMaybeMessage< ::cpb::tagreader::SaveSongRatingToFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SaveSongRatingToFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::SaveSongRatingToFileResponse*
Arena::CreateMaybeMessage< ::cpb::tagreader::SaveSongRatingToFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::SaveSongRatingToFileResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::tagreader::Message*
Arena::CreateMaybeMessage< ::cpb::tagreader::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::tagreader::Message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
