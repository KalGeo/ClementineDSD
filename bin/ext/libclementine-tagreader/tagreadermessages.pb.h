// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tagreadermessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tagreadermessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tagreadermessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tagreadermessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tagreadermessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tagreadermessages_2eproto;
namespace cpb {
namespace tagreader {
class IsMediaFileRequest;
struct IsMediaFileRequestDefaultTypeInternal;
extern IsMediaFileRequestDefaultTypeInternal _IsMediaFileRequest_default_instance_;
class IsMediaFileResponse;
struct IsMediaFileResponseDefaultTypeInternal;
extern IsMediaFileResponseDefaultTypeInternal _IsMediaFileResponse_default_instance_;
class LoadEmbeddedArtRequest;
struct LoadEmbeddedArtRequestDefaultTypeInternal;
extern LoadEmbeddedArtRequestDefaultTypeInternal _LoadEmbeddedArtRequest_default_instance_;
class LoadEmbeddedArtResponse;
struct LoadEmbeddedArtResponseDefaultTypeInternal;
extern LoadEmbeddedArtResponseDefaultTypeInternal _LoadEmbeddedArtResponse_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class ReadCloudFileRequest;
struct ReadCloudFileRequestDefaultTypeInternal;
extern ReadCloudFileRequestDefaultTypeInternal _ReadCloudFileRequest_default_instance_;
class ReadCloudFileResponse;
struct ReadCloudFileResponseDefaultTypeInternal;
extern ReadCloudFileResponseDefaultTypeInternal _ReadCloudFileResponse_default_instance_;
class ReadFileRequest;
struct ReadFileRequestDefaultTypeInternal;
extern ReadFileRequestDefaultTypeInternal _ReadFileRequest_default_instance_;
class ReadFileResponse;
struct ReadFileResponseDefaultTypeInternal;
extern ReadFileResponseDefaultTypeInternal _ReadFileResponse_default_instance_;
class SaveFileRequest;
struct SaveFileRequestDefaultTypeInternal;
extern SaveFileRequestDefaultTypeInternal _SaveFileRequest_default_instance_;
class SaveFileResponse;
struct SaveFileResponseDefaultTypeInternal;
extern SaveFileResponseDefaultTypeInternal _SaveFileResponse_default_instance_;
class SaveSongRatingToFileRequest;
struct SaveSongRatingToFileRequestDefaultTypeInternal;
extern SaveSongRatingToFileRequestDefaultTypeInternal _SaveSongRatingToFileRequest_default_instance_;
class SaveSongRatingToFileResponse;
struct SaveSongRatingToFileResponseDefaultTypeInternal;
extern SaveSongRatingToFileResponseDefaultTypeInternal _SaveSongRatingToFileResponse_default_instance_;
class SaveSongStatisticsToFileRequest;
struct SaveSongStatisticsToFileRequestDefaultTypeInternal;
extern SaveSongStatisticsToFileRequestDefaultTypeInternal _SaveSongStatisticsToFileRequest_default_instance_;
class SaveSongStatisticsToFileResponse;
struct SaveSongStatisticsToFileResponseDefaultTypeInternal;
extern SaveSongStatisticsToFileResponseDefaultTypeInternal _SaveSongStatisticsToFileResponse_default_instance_;
class SongMetadata;
struct SongMetadataDefaultTypeInternal;
extern SongMetadataDefaultTypeInternal _SongMetadata_default_instance_;
}  // namespace tagreader
}  // namespace cpb
PROTOBUF_NAMESPACE_OPEN
template<> ::cpb::tagreader::IsMediaFileRequest* Arena::CreateMaybeMessage<::cpb::tagreader::IsMediaFileRequest>(Arena*);
template<> ::cpb::tagreader::IsMediaFileResponse* Arena::CreateMaybeMessage<::cpb::tagreader::IsMediaFileResponse>(Arena*);
template<> ::cpb::tagreader::LoadEmbeddedArtRequest* Arena::CreateMaybeMessage<::cpb::tagreader::LoadEmbeddedArtRequest>(Arena*);
template<> ::cpb::tagreader::LoadEmbeddedArtResponse* Arena::CreateMaybeMessage<::cpb::tagreader::LoadEmbeddedArtResponse>(Arena*);
template<> ::cpb::tagreader::Message* Arena::CreateMaybeMessage<::cpb::tagreader::Message>(Arena*);
template<> ::cpb::tagreader::ReadCloudFileRequest* Arena::CreateMaybeMessage<::cpb::tagreader::ReadCloudFileRequest>(Arena*);
template<> ::cpb::tagreader::ReadCloudFileResponse* Arena::CreateMaybeMessage<::cpb::tagreader::ReadCloudFileResponse>(Arena*);
template<> ::cpb::tagreader::ReadFileRequest* Arena::CreateMaybeMessage<::cpb::tagreader::ReadFileRequest>(Arena*);
template<> ::cpb::tagreader::ReadFileResponse* Arena::CreateMaybeMessage<::cpb::tagreader::ReadFileResponse>(Arena*);
template<> ::cpb::tagreader::SaveFileRequest* Arena::CreateMaybeMessage<::cpb::tagreader::SaveFileRequest>(Arena*);
template<> ::cpb::tagreader::SaveFileResponse* Arena::CreateMaybeMessage<::cpb::tagreader::SaveFileResponse>(Arena*);
template<> ::cpb::tagreader::SaveSongRatingToFileRequest* Arena::CreateMaybeMessage<::cpb::tagreader::SaveSongRatingToFileRequest>(Arena*);
template<> ::cpb::tagreader::SaveSongRatingToFileResponse* Arena::CreateMaybeMessage<::cpb::tagreader::SaveSongRatingToFileResponse>(Arena*);
template<> ::cpb::tagreader::SaveSongStatisticsToFileRequest* Arena::CreateMaybeMessage<::cpb::tagreader::SaveSongStatisticsToFileRequest>(Arena*);
template<> ::cpb::tagreader::SaveSongStatisticsToFileResponse* Arena::CreateMaybeMessage<::cpb::tagreader::SaveSongStatisticsToFileResponse>(Arena*);
template<> ::cpb::tagreader::SongMetadata* Arena::CreateMaybeMessage<::cpb::tagreader::SongMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cpb {
namespace tagreader {

enum SongMetadata_Type : int {
  SongMetadata_Type_UNKNOWN = 0,
  SongMetadata_Type_ASF = 1,
  SongMetadata_Type_FLAC = 2,
  SongMetadata_Type_MP4 = 3,
  SongMetadata_Type_MPC = 4,
  SongMetadata_Type_MPEG = 5,
  SongMetadata_Type_OGGFLAC = 6,
  SongMetadata_Type_OGGSPEEX = 7,
  SongMetadata_Type_OGGVORBIS = 8,
  SongMetadata_Type_AIFF = 9,
  SongMetadata_Type_WAV = 10,
  SongMetadata_Type_TRUEAUDIO = 11,
  SongMetadata_Type_CDDA = 12,
  SongMetadata_Type_OGGOPUS = 13,
  SongMetadata_Type_WAVPACK = 14,
  SongMetadata_Type_SPC = 15,
  SongMetadata_Type_VGM = 16,
  SongMetadata_Type_APE = 17,
  SongMetadata_Type_DSF = 18,
  SongMetadata_Type_DFF = 19,
  SongMetadata_Type_STREAM = 99
};
bool SongMetadata_Type_IsValid(int value);
constexpr SongMetadata_Type SongMetadata_Type_Type_MIN = SongMetadata_Type_UNKNOWN;
constexpr SongMetadata_Type SongMetadata_Type_Type_MAX = SongMetadata_Type_STREAM;
constexpr int SongMetadata_Type_Type_ARRAYSIZE = SongMetadata_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SongMetadata_Type_descriptor();
template<typename T>
inline const std::string& SongMetadata_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SongMetadata_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SongMetadata_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SongMetadata_Type_descriptor(), enum_t_value);
}
inline bool SongMetadata_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SongMetadata_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SongMetadata_Type>(
    SongMetadata_Type_descriptor(), name, value);
}
// ===================================================================

class SongMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SongMetadata) */ {
 public:
  inline SongMetadata() : SongMetadata(nullptr) {}
  ~SongMetadata() override;
  explicit PROTOBUF_CONSTEXPR SongMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SongMetadata(const SongMetadata& from);
  SongMetadata(SongMetadata&& from) noexcept
    : SongMetadata() {
    *this = ::std::move(from);
  }

  inline SongMetadata& operator=(const SongMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SongMetadata& operator=(SongMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SongMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SongMetadata* internal_default_instance() {
    return reinterpret_cast<const SongMetadata*>(
               &_SongMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SongMetadata& a, SongMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SongMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SongMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SongMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SongMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SongMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SongMetadata& from) {
    SongMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SongMetadata";
  }
  protected:
  explicit SongMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SongMetadata_Type Type;
  static constexpr Type UNKNOWN =
    SongMetadata_Type_UNKNOWN;
  static constexpr Type ASF =
    SongMetadata_Type_ASF;
  static constexpr Type FLAC =
    SongMetadata_Type_FLAC;
  static constexpr Type MP4 =
    SongMetadata_Type_MP4;
  static constexpr Type MPC =
    SongMetadata_Type_MPC;
  static constexpr Type MPEG =
    SongMetadata_Type_MPEG;
  static constexpr Type OGGFLAC =
    SongMetadata_Type_OGGFLAC;
  static constexpr Type OGGSPEEX =
    SongMetadata_Type_OGGSPEEX;
  static constexpr Type OGGVORBIS =
    SongMetadata_Type_OGGVORBIS;
  static constexpr Type AIFF =
    SongMetadata_Type_AIFF;
  static constexpr Type WAV =
    SongMetadata_Type_WAV;
  static constexpr Type TRUEAUDIO =
    SongMetadata_Type_TRUEAUDIO;
  static constexpr Type CDDA =
    SongMetadata_Type_CDDA;
  static constexpr Type OGGOPUS =
    SongMetadata_Type_OGGOPUS;
  static constexpr Type WAVPACK =
    SongMetadata_Type_WAVPACK;
  static constexpr Type SPC =
    SongMetadata_Type_SPC;
  static constexpr Type VGM =
    SongMetadata_Type_VGM;
  static constexpr Type APE =
    SongMetadata_Type_APE;
  static constexpr Type DSF =
    SongMetadata_Type_DSF;
  static constexpr Type DFF =
    SongMetadata_Type_DFF;
  static constexpr Type STREAM =
    SongMetadata_Type_STREAM;
  static inline bool Type_IsValid(int value) {
    return SongMetadata_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SongMetadata_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SongMetadata_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SongMetadata_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return SongMetadata_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SongMetadata_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SongMetadata_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kAlbumFieldNumber = 3,
    kArtistFieldNumber = 4,
    kAlbumartistFieldNumber = 5,
    kComposerFieldNumber = 6,
    kGenreFieldNumber = 11,
    kCommentFieldNumber = 12,
    kUrlFieldNumber = 22,
    kBasefilenameFieldNumber = 23,
    kArtAutomaticFieldNumber = 28,
    kEtagFieldNumber = 30,
    kPerformerFieldNumber = 31,
    kGroupingFieldNumber = 32,
    kLyricsFieldNumber = 33,
    kTrackFieldNumber = 7,
    kDiscFieldNumber = 8,
    kBpmFieldNumber = 9,
    kYearFieldNumber = 10,
    kValidFieldNumber = 1,
    kCompilationFieldNumber = 13,
    kSuspiciousTagsFieldNumber = 27,
    kRatingFieldNumber = 14,
    kPlaycountFieldNumber = 15,
    kSkipcountFieldNumber = 16,
    kLastplayedFieldNumber = 17,
    kScoreFieldNumber = 18,
    kLengthNanosecFieldNumber = 19,
    kBitrateFieldNumber = 20,
    kSamplerateFieldNumber = 21,
    kMtimeFieldNumber = 24,
    kCtimeFieldNumber = 25,
    kFilesizeFieldNumber = 26,
    kTypeFieldNumber = 29,
    kOriginalyearFieldNumber = 34,
  };
  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string album = 3;
  bool has_album() const;
  private:
  bool _internal_has_album() const;
  public:
  void clear_album();
  const std::string& album() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_album(ArgT0&& arg0, ArgT... args);
  std::string* mutable_album();
  PROTOBUF_NODISCARD std::string* release_album();
  void set_allocated_album(std::string* album);
  private:
  const std::string& _internal_album() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_album(const std::string& value);
  std::string* _internal_mutable_album();
  public:

  // optional string artist = 4;
  bool has_artist() const;
  private:
  bool _internal_has_artist() const;
  public:
  void clear_artist();
  const std::string& artist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artist();
  PROTOBUF_NODISCARD std::string* release_artist();
  void set_allocated_artist(std::string* artist);
  private:
  const std::string& _internal_artist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artist(const std::string& value);
  std::string* _internal_mutable_artist();
  public:

  // optional string albumartist = 5;
  bool has_albumartist() const;
  private:
  bool _internal_has_albumartist() const;
  public:
  void clear_albumartist();
  const std::string& albumartist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_albumartist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_albumartist();
  PROTOBUF_NODISCARD std::string* release_albumartist();
  void set_allocated_albumartist(std::string* albumartist);
  private:
  const std::string& _internal_albumartist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_albumartist(const std::string& value);
  std::string* _internal_mutable_albumartist();
  public:

  // optional string composer = 6;
  bool has_composer() const;
  private:
  bool _internal_has_composer() const;
  public:
  void clear_composer();
  const std::string& composer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_composer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_composer();
  PROTOBUF_NODISCARD std::string* release_composer();
  void set_allocated_composer(std::string* composer);
  private:
  const std::string& _internal_composer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_composer(const std::string& value);
  std::string* _internal_mutable_composer();
  public:

  // optional string genre = 11;
  bool has_genre() const;
  private:
  bool _internal_has_genre() const;
  public:
  void clear_genre();
  const std::string& genre() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_genre(ArgT0&& arg0, ArgT... args);
  std::string* mutable_genre();
  PROTOBUF_NODISCARD std::string* release_genre();
  void set_allocated_genre(std::string* genre);
  private:
  const std::string& _internal_genre() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_genre(const std::string& value);
  std::string* _internal_mutable_genre();
  public:

  // optional string comment = 12;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional string url = 22;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string basefilename = 23;
  bool has_basefilename() const;
  private:
  bool _internal_has_basefilename() const;
  public:
  void clear_basefilename();
  const std::string& basefilename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_basefilename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_basefilename();
  PROTOBUF_NODISCARD std::string* release_basefilename();
  void set_allocated_basefilename(std::string* basefilename);
  private:
  const std::string& _internal_basefilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_basefilename(const std::string& value);
  std::string* _internal_mutable_basefilename();
  public:

  // optional string art_automatic = 28;
  bool has_art_automatic() const;
  private:
  bool _internal_has_art_automatic() const;
  public:
  void clear_art_automatic();
  const std::string& art_automatic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_art_automatic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_art_automatic();
  PROTOBUF_NODISCARD std::string* release_art_automatic();
  void set_allocated_art_automatic(std::string* art_automatic);
  private:
  const std::string& _internal_art_automatic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_art_automatic(const std::string& value);
  std::string* _internal_mutable_art_automatic();
  public:

  // optional string etag = 30;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // optional string performer = 31;
  bool has_performer() const;
  private:
  bool _internal_has_performer() const;
  public:
  void clear_performer();
  const std::string& performer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_performer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_performer();
  PROTOBUF_NODISCARD std::string* release_performer();
  void set_allocated_performer(std::string* performer);
  private:
  const std::string& _internal_performer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_performer(const std::string& value);
  std::string* _internal_mutable_performer();
  public:

  // optional string grouping = 32;
  bool has_grouping() const;
  private:
  bool _internal_has_grouping() const;
  public:
  void clear_grouping();
  const std::string& grouping() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_grouping(ArgT0&& arg0, ArgT... args);
  std::string* mutable_grouping();
  PROTOBUF_NODISCARD std::string* release_grouping();
  void set_allocated_grouping(std::string* grouping);
  private:
  const std::string& _internal_grouping() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_grouping(const std::string& value);
  std::string* _internal_mutable_grouping();
  public:

  // optional string lyrics = 33;
  bool has_lyrics() const;
  private:
  bool _internal_has_lyrics() const;
  public:
  void clear_lyrics();
  const std::string& lyrics() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lyrics(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lyrics();
  PROTOBUF_NODISCARD std::string* release_lyrics();
  void set_allocated_lyrics(std::string* lyrics);
  private:
  const std::string& _internal_lyrics() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lyrics(const std::string& value);
  std::string* _internal_mutable_lyrics();
  public:

  // optional int32 track = 7;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  int32_t track() const;
  void set_track(int32_t value);
  private:
  int32_t _internal_track() const;
  void _internal_set_track(int32_t value);
  public:

  // optional int32 disc = 8;
  bool has_disc() const;
  private:
  bool _internal_has_disc() const;
  public:
  void clear_disc();
  int32_t disc() const;
  void set_disc(int32_t value);
  private:
  int32_t _internal_disc() const;
  void _internal_set_disc(int32_t value);
  public:

  // optional float bpm = 9;
  bool has_bpm() const;
  private:
  bool _internal_has_bpm() const;
  public:
  void clear_bpm();
  float bpm() const;
  void set_bpm(float value);
  private:
  float _internal_bpm() const;
  void _internal_set_bpm(float value);
  public:

  // optional int32 year = 10;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  int32_t year() const;
  void set_year(int32_t value);
  private:
  int32_t _internal_year() const;
  void _internal_set_year(int32_t value);
  public:

  // optional bool valid = 1;
  bool has_valid() const;
  private:
  bool _internal_has_valid() const;
  public:
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // optional bool compilation = 13;
  bool has_compilation() const;
  private:
  bool _internal_has_compilation() const;
  public:
  void clear_compilation();
  bool compilation() const;
  void set_compilation(bool value);
  private:
  bool _internal_compilation() const;
  void _internal_set_compilation(bool value);
  public:

  // optional bool suspicious_tags = 27;
  bool has_suspicious_tags() const;
  private:
  bool _internal_has_suspicious_tags() const;
  public:
  void clear_suspicious_tags();
  bool suspicious_tags() const;
  void set_suspicious_tags(bool value);
  private:
  bool _internal_suspicious_tags() const;
  void _internal_set_suspicious_tags(bool value);
  public:

  // optional float rating = 14;
  bool has_rating() const;
  private:
  bool _internal_has_rating() const;
  public:
  void clear_rating();
  float rating() const;
  void set_rating(float value);
  private:
  float _internal_rating() const;
  void _internal_set_rating(float value);
  public:

  // optional int32 playcount = 15;
  bool has_playcount() const;
  private:
  bool _internal_has_playcount() const;
  public:
  void clear_playcount();
  int32_t playcount() const;
  void set_playcount(int32_t value);
  private:
  int32_t _internal_playcount() const;
  void _internal_set_playcount(int32_t value);
  public:

  // optional int32 skipcount = 16;
  bool has_skipcount() const;
  private:
  bool _internal_has_skipcount() const;
  public:
  void clear_skipcount();
  int32_t skipcount() const;
  void set_skipcount(int32_t value);
  private:
  int32_t _internal_skipcount() const;
  void _internal_set_skipcount(int32_t value);
  public:

  // optional int32 lastplayed = 17;
  bool has_lastplayed() const;
  private:
  bool _internal_has_lastplayed() const;
  public:
  void clear_lastplayed();
  int32_t lastplayed() const;
  void set_lastplayed(int32_t value);
  private:
  int32_t _internal_lastplayed() const;
  void _internal_set_lastplayed(int32_t value);
  public:

  // optional int32 score = 18;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // optional uint64 length_nanosec = 19;
  bool has_length_nanosec() const;
  private:
  bool _internal_has_length_nanosec() const;
  public:
  void clear_length_nanosec();
  uint64_t length_nanosec() const;
  void set_length_nanosec(uint64_t value);
  private:
  uint64_t _internal_length_nanosec() const;
  void _internal_set_length_nanosec(uint64_t value);
  public:

  // optional int32 bitrate = 20;
  bool has_bitrate() const;
  private:
  bool _internal_has_bitrate() const;
  public:
  void clear_bitrate();
  int32_t bitrate() const;
  void set_bitrate(int32_t value);
  private:
  int32_t _internal_bitrate() const;
  void _internal_set_bitrate(int32_t value);
  public:

  // optional int32 samplerate = 21;
  bool has_samplerate() const;
  private:
  bool _internal_has_samplerate() const;
  public:
  void clear_samplerate();
  int32_t samplerate() const;
  void set_samplerate(int32_t value);
  private:
  int32_t _internal_samplerate() const;
  void _internal_set_samplerate(int32_t value);
  public:

  // optional int32 mtime = 24;
  bool has_mtime() const;
  private:
  bool _internal_has_mtime() const;
  public:
  void clear_mtime();
  int32_t mtime() const;
  void set_mtime(int32_t value);
  private:
  int32_t _internal_mtime() const;
  void _internal_set_mtime(int32_t value);
  public:

  // optional int32 ctime = 25;
  bool has_ctime() const;
  private:
  bool _internal_has_ctime() const;
  public:
  void clear_ctime();
  int32_t ctime() const;
  void set_ctime(int32_t value);
  private:
  int32_t _internal_ctime() const;
  void _internal_set_ctime(int32_t value);
  public:

  // optional int32 filesize = 26;
  bool has_filesize() const;
  private:
  bool _internal_has_filesize() const;
  public:
  void clear_filesize();
  int32_t filesize() const;
  void set_filesize(int32_t value);
  private:
  int32_t _internal_filesize() const;
  void _internal_set_filesize(int32_t value);
  public:

  // optional .cpb.tagreader.SongMetadata.Type type = 29;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::cpb::tagreader::SongMetadata_Type type() const;
  void set_type(::cpb::tagreader::SongMetadata_Type value);
  private:
  ::cpb::tagreader::SongMetadata_Type _internal_type() const;
  void _internal_set_type(::cpb::tagreader::SongMetadata_Type value);
  public:

  // optional int32 originalyear = 34;
  bool has_originalyear() const;
  private:
  bool _internal_has_originalyear() const;
  public:
  void clear_originalyear();
  int32_t originalyear() const;
  void set_originalyear(int32_t value);
  private:
  int32_t _internal_originalyear() const;
  void _internal_set_originalyear(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SongMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr album_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr albumartist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr composer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr genre_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr basefilename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr art_automatic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr performer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grouping_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lyrics_;
    int32_t track_;
    int32_t disc_;
    float bpm_;
    int32_t year_;
    bool valid_;
    bool compilation_;
    bool suspicious_tags_;
    float rating_;
    int32_t playcount_;
    int32_t skipcount_;
    int32_t lastplayed_;
    int32_t score_;
    uint64_t length_nanosec_;
    int32_t bitrate_;
    int32_t samplerate_;
    int32_t mtime_;
    int32_t ctime_;
    int32_t filesize_;
    int type_;
    int32_t originalyear_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class ReadFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.ReadFileRequest) */ {
 public:
  inline ReadFileRequest() : ReadFileRequest(nullptr) {}
  ~ReadFileRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadFileRequest(const ReadFileRequest& from);
  ReadFileRequest(ReadFileRequest&& from) noexcept
    : ReadFileRequest() {
    *this = ::std::move(from);
  }

  inline ReadFileRequest& operator=(const ReadFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadFileRequest& operator=(ReadFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadFileRequest* internal_default_instance() {
    return reinterpret_cast<const ReadFileRequest*>(
               &_ReadFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReadFileRequest& a, ReadFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadFileRequest& from) {
    ReadFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.ReadFileRequest";
  }
  protected:
  explicit ReadFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.ReadFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class ReadFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.ReadFileResponse) */ {
 public:
  inline ReadFileResponse() : ReadFileResponse(nullptr) {}
  ~ReadFileResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadFileResponse(const ReadFileResponse& from);
  ReadFileResponse(ReadFileResponse&& from) noexcept
    : ReadFileResponse() {
    *this = ::std::move(from);
  }

  inline ReadFileResponse& operator=(const ReadFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadFileResponse& operator=(ReadFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadFileResponse* internal_default_instance() {
    return reinterpret_cast<const ReadFileResponse*>(
               &_ReadFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReadFileResponse& a, ReadFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadFileResponse& from) {
    ReadFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.ReadFileResponse";
  }
  protected:
  explicit ReadFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // optional .cpb.tagreader.SongMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::cpb::tagreader::SongMetadata& metadata() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SongMetadata* release_metadata();
  ::cpb::tagreader::SongMetadata* mutable_metadata();
  void set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata);
  private:
  const ::cpb::tagreader::SongMetadata& _internal_metadata() const;
  ::cpb::tagreader::SongMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cpb::tagreader::SongMetadata* metadata);
  ::cpb::tagreader::SongMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:cpb.tagreader.ReadFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cpb::tagreader::SongMetadata* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class SaveFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SaveFileRequest) */ {
 public:
  inline SaveFileRequest() : SaveFileRequest(nullptr) {}
  ~SaveFileRequest() override;
  explicit PROTOBUF_CONSTEXPR SaveFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveFileRequest(const SaveFileRequest& from);
  SaveFileRequest(SaveFileRequest&& from) noexcept
    : SaveFileRequest() {
    *this = ::std::move(from);
  }

  inline SaveFileRequest& operator=(const SaveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveFileRequest& operator=(SaveFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveFileRequest* internal_default_instance() {
    return reinterpret_cast<const SaveFileRequest*>(
               &_SaveFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SaveFileRequest& a, SaveFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveFileRequest& from) {
    SaveFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SaveFileRequest";
  }
  protected:
  explicit SaveFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional .cpb.tagreader.SongMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::cpb::tagreader::SongMetadata& metadata() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SongMetadata* release_metadata();
  ::cpb::tagreader::SongMetadata* mutable_metadata();
  void set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata);
  private:
  const ::cpb::tagreader::SongMetadata& _internal_metadata() const;
  ::cpb::tagreader::SongMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cpb::tagreader::SongMetadata* metadata);
  ::cpb::tagreader::SongMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SaveFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::cpb::tagreader::SongMetadata* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class SaveFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SaveFileResponse) */ {
 public:
  inline SaveFileResponse() : SaveFileResponse(nullptr) {}
  ~SaveFileResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveFileResponse(const SaveFileResponse& from);
  SaveFileResponse(SaveFileResponse&& from) noexcept
    : SaveFileResponse() {
    *this = ::std::move(from);
  }

  inline SaveFileResponse& operator=(const SaveFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveFileResponse& operator=(SaveFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveFileResponse* internal_default_instance() {
    return reinterpret_cast<const SaveFileResponse*>(
               &_SaveFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SaveFileResponse& a, SaveFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveFileResponse& from) {
    SaveFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SaveFileResponse";
  }
  protected:
  explicit SaveFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SaveFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class IsMediaFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.IsMediaFileRequest) */ {
 public:
  inline IsMediaFileRequest() : IsMediaFileRequest(nullptr) {}
  ~IsMediaFileRequest() override;
  explicit PROTOBUF_CONSTEXPR IsMediaFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsMediaFileRequest(const IsMediaFileRequest& from);
  IsMediaFileRequest(IsMediaFileRequest&& from) noexcept
    : IsMediaFileRequest() {
    *this = ::std::move(from);
  }

  inline IsMediaFileRequest& operator=(const IsMediaFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsMediaFileRequest& operator=(IsMediaFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsMediaFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsMediaFileRequest* internal_default_instance() {
    return reinterpret_cast<const IsMediaFileRequest*>(
               &_IsMediaFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IsMediaFileRequest& a, IsMediaFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IsMediaFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsMediaFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsMediaFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsMediaFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsMediaFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsMediaFileRequest& from) {
    IsMediaFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsMediaFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.IsMediaFileRequest";
  }
  protected:
  explicit IsMediaFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.IsMediaFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class IsMediaFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.IsMediaFileResponse) */ {
 public:
  inline IsMediaFileResponse() : IsMediaFileResponse(nullptr) {}
  ~IsMediaFileResponse() override;
  explicit PROTOBUF_CONSTEXPR IsMediaFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsMediaFileResponse(const IsMediaFileResponse& from);
  IsMediaFileResponse(IsMediaFileResponse&& from) noexcept
    : IsMediaFileResponse() {
    *this = ::std::move(from);
  }

  inline IsMediaFileResponse& operator=(const IsMediaFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsMediaFileResponse& operator=(IsMediaFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsMediaFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsMediaFileResponse* internal_default_instance() {
    return reinterpret_cast<const IsMediaFileResponse*>(
               &_IsMediaFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IsMediaFileResponse& a, IsMediaFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IsMediaFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsMediaFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsMediaFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsMediaFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsMediaFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsMediaFileResponse& from) {
    IsMediaFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsMediaFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.IsMediaFileResponse";
  }
  protected:
  explicit IsMediaFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.IsMediaFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class LoadEmbeddedArtRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.LoadEmbeddedArtRequest) */ {
 public:
  inline LoadEmbeddedArtRequest() : LoadEmbeddedArtRequest(nullptr) {}
  ~LoadEmbeddedArtRequest() override;
  explicit PROTOBUF_CONSTEXPR LoadEmbeddedArtRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadEmbeddedArtRequest(const LoadEmbeddedArtRequest& from);
  LoadEmbeddedArtRequest(LoadEmbeddedArtRequest&& from) noexcept
    : LoadEmbeddedArtRequest() {
    *this = ::std::move(from);
  }

  inline LoadEmbeddedArtRequest& operator=(const LoadEmbeddedArtRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEmbeddedArtRequest& operator=(LoadEmbeddedArtRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadEmbeddedArtRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadEmbeddedArtRequest* internal_default_instance() {
    return reinterpret_cast<const LoadEmbeddedArtRequest*>(
               &_LoadEmbeddedArtRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoadEmbeddedArtRequest& a, LoadEmbeddedArtRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEmbeddedArtRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEmbeddedArtRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadEmbeddedArtRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadEmbeddedArtRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadEmbeddedArtRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadEmbeddedArtRequest& from) {
    LoadEmbeddedArtRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEmbeddedArtRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.LoadEmbeddedArtRequest";
  }
  protected:
  explicit LoadEmbeddedArtRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.LoadEmbeddedArtRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class LoadEmbeddedArtResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.LoadEmbeddedArtResponse) */ {
 public:
  inline LoadEmbeddedArtResponse() : LoadEmbeddedArtResponse(nullptr) {}
  ~LoadEmbeddedArtResponse() override;
  explicit PROTOBUF_CONSTEXPR LoadEmbeddedArtResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadEmbeddedArtResponse(const LoadEmbeddedArtResponse& from);
  LoadEmbeddedArtResponse(LoadEmbeddedArtResponse&& from) noexcept
    : LoadEmbeddedArtResponse() {
    *this = ::std::move(from);
  }

  inline LoadEmbeddedArtResponse& operator=(const LoadEmbeddedArtResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEmbeddedArtResponse& operator=(LoadEmbeddedArtResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadEmbeddedArtResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadEmbeddedArtResponse* internal_default_instance() {
    return reinterpret_cast<const LoadEmbeddedArtResponse*>(
               &_LoadEmbeddedArtResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadEmbeddedArtResponse& a, LoadEmbeddedArtResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEmbeddedArtResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEmbeddedArtResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadEmbeddedArtResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadEmbeddedArtResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadEmbeddedArtResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadEmbeddedArtResponse& from) {
    LoadEmbeddedArtResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEmbeddedArtResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.LoadEmbeddedArtResponse";
  }
  protected:
  explicit LoadEmbeddedArtResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.LoadEmbeddedArtResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class ReadCloudFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.ReadCloudFileRequest) */ {
 public:
  inline ReadCloudFileRequest() : ReadCloudFileRequest(nullptr) {}
  ~ReadCloudFileRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadCloudFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadCloudFileRequest(const ReadCloudFileRequest& from);
  ReadCloudFileRequest(ReadCloudFileRequest&& from) noexcept
    : ReadCloudFileRequest() {
    *this = ::std::move(from);
  }

  inline ReadCloudFileRequest& operator=(const ReadCloudFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadCloudFileRequest& operator=(ReadCloudFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadCloudFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadCloudFileRequest* internal_default_instance() {
    return reinterpret_cast<const ReadCloudFileRequest*>(
               &_ReadCloudFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadCloudFileRequest& a, ReadCloudFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadCloudFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadCloudFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadCloudFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadCloudFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadCloudFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadCloudFileRequest& from) {
    ReadCloudFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadCloudFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.ReadCloudFileRequest";
  }
  protected:
  explicit ReadCloudFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadUrlFieldNumber = 1,
    kTitleFieldNumber = 2,
    kAuthorisationHeaderFieldNumber = 4,
    kMimeTypeFieldNumber = 5,
    kSizeFieldNumber = 3,
  };
  // optional string download_url = 1;
  bool has_download_url() const;
  private:
  bool _internal_has_download_url() const;
  public:
  void clear_download_url();
  const std::string& download_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_download_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_download_url();
  PROTOBUF_NODISCARD std::string* release_download_url();
  void set_allocated_download_url(std::string* download_url);
  private:
  const std::string& _internal_download_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_download_url(const std::string& value);
  std::string* _internal_mutable_download_url();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string authorisation_header = 4;
  bool has_authorisation_header() const;
  private:
  bool _internal_has_authorisation_header() const;
  public:
  void clear_authorisation_header();
  const std::string& authorisation_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorisation_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorisation_header();
  PROTOBUF_NODISCARD std::string* release_authorisation_header();
  void set_allocated_authorisation_header(std::string* authorisation_header);
  private:
  const std::string& _internal_authorisation_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorisation_header(const std::string& value);
  std::string* _internal_mutable_authorisation_header();
  public:

  // optional string mime_type = 5;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // optional int32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.ReadCloudFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr download_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorisation_header_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class ReadCloudFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.ReadCloudFileResponse) */ {
 public:
  inline ReadCloudFileResponse() : ReadCloudFileResponse(nullptr) {}
  ~ReadCloudFileResponse() override;
  explicit PROTOBUF_CONSTEXPR ReadCloudFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadCloudFileResponse(const ReadCloudFileResponse& from);
  ReadCloudFileResponse(ReadCloudFileResponse&& from) noexcept
    : ReadCloudFileResponse() {
    *this = ::std::move(from);
  }

  inline ReadCloudFileResponse& operator=(const ReadCloudFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadCloudFileResponse& operator=(ReadCloudFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadCloudFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadCloudFileResponse* internal_default_instance() {
    return reinterpret_cast<const ReadCloudFileResponse*>(
               &_ReadCloudFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReadCloudFileResponse& a, ReadCloudFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadCloudFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadCloudFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadCloudFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadCloudFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadCloudFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadCloudFileResponse& from) {
    ReadCloudFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadCloudFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.ReadCloudFileResponse";
  }
  protected:
  explicit ReadCloudFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // optional .cpb.tagreader.SongMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::cpb::tagreader::SongMetadata& metadata() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SongMetadata* release_metadata();
  ::cpb::tagreader::SongMetadata* mutable_metadata();
  void set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata);
  private:
  const ::cpb::tagreader::SongMetadata& _internal_metadata() const;
  ::cpb::tagreader::SongMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cpb::tagreader::SongMetadata* metadata);
  ::cpb::tagreader::SongMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:cpb.tagreader.ReadCloudFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cpb::tagreader::SongMetadata* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class SaveSongStatisticsToFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SaveSongStatisticsToFileRequest) */ {
 public:
  inline SaveSongStatisticsToFileRequest() : SaveSongStatisticsToFileRequest(nullptr) {}
  ~SaveSongStatisticsToFileRequest() override;
  explicit PROTOBUF_CONSTEXPR SaveSongStatisticsToFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSongStatisticsToFileRequest(const SaveSongStatisticsToFileRequest& from);
  SaveSongStatisticsToFileRequest(SaveSongStatisticsToFileRequest&& from) noexcept
    : SaveSongStatisticsToFileRequest() {
    *this = ::std::move(from);
  }

  inline SaveSongStatisticsToFileRequest& operator=(const SaveSongStatisticsToFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSongStatisticsToFileRequest& operator=(SaveSongStatisticsToFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSongStatisticsToFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSongStatisticsToFileRequest* internal_default_instance() {
    return reinterpret_cast<const SaveSongStatisticsToFileRequest*>(
               &_SaveSongStatisticsToFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SaveSongStatisticsToFileRequest& a, SaveSongStatisticsToFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSongStatisticsToFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSongStatisticsToFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSongStatisticsToFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSongStatisticsToFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSongStatisticsToFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSongStatisticsToFileRequest& from) {
    SaveSongStatisticsToFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSongStatisticsToFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SaveSongStatisticsToFileRequest";
  }
  protected:
  explicit SaveSongStatisticsToFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional .cpb.tagreader.SongMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::cpb::tagreader::SongMetadata& metadata() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SongMetadata* release_metadata();
  ::cpb::tagreader::SongMetadata* mutable_metadata();
  void set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata);
  private:
  const ::cpb::tagreader::SongMetadata& _internal_metadata() const;
  ::cpb::tagreader::SongMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cpb::tagreader::SongMetadata* metadata);
  ::cpb::tagreader::SongMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SaveSongStatisticsToFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::cpb::tagreader::SongMetadata* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class SaveSongStatisticsToFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SaveSongStatisticsToFileResponse) */ {
 public:
  inline SaveSongStatisticsToFileResponse() : SaveSongStatisticsToFileResponse(nullptr) {}
  ~SaveSongStatisticsToFileResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveSongStatisticsToFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSongStatisticsToFileResponse(const SaveSongStatisticsToFileResponse& from);
  SaveSongStatisticsToFileResponse(SaveSongStatisticsToFileResponse&& from) noexcept
    : SaveSongStatisticsToFileResponse() {
    *this = ::std::move(from);
  }

  inline SaveSongStatisticsToFileResponse& operator=(const SaveSongStatisticsToFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSongStatisticsToFileResponse& operator=(SaveSongStatisticsToFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSongStatisticsToFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSongStatisticsToFileResponse* internal_default_instance() {
    return reinterpret_cast<const SaveSongStatisticsToFileResponse*>(
               &_SaveSongStatisticsToFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SaveSongStatisticsToFileResponse& a, SaveSongStatisticsToFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSongStatisticsToFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSongStatisticsToFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSongStatisticsToFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSongStatisticsToFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSongStatisticsToFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSongStatisticsToFileResponse& from) {
    SaveSongStatisticsToFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSongStatisticsToFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SaveSongStatisticsToFileResponse";
  }
  protected:
  explicit SaveSongStatisticsToFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SaveSongStatisticsToFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class SaveSongRatingToFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SaveSongRatingToFileRequest) */ {
 public:
  inline SaveSongRatingToFileRequest() : SaveSongRatingToFileRequest(nullptr) {}
  ~SaveSongRatingToFileRequest() override;
  explicit PROTOBUF_CONSTEXPR SaveSongRatingToFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSongRatingToFileRequest(const SaveSongRatingToFileRequest& from);
  SaveSongRatingToFileRequest(SaveSongRatingToFileRequest&& from) noexcept
    : SaveSongRatingToFileRequest() {
    *this = ::std::move(from);
  }

  inline SaveSongRatingToFileRequest& operator=(const SaveSongRatingToFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSongRatingToFileRequest& operator=(SaveSongRatingToFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSongRatingToFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSongRatingToFileRequest* internal_default_instance() {
    return reinterpret_cast<const SaveSongRatingToFileRequest*>(
               &_SaveSongRatingToFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SaveSongRatingToFileRequest& a, SaveSongRatingToFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSongRatingToFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSongRatingToFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSongRatingToFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSongRatingToFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSongRatingToFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSongRatingToFileRequest& from) {
    SaveSongRatingToFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSongRatingToFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SaveSongRatingToFileRequest";
  }
  protected:
  explicit SaveSongRatingToFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional .cpb.tagreader.SongMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::cpb::tagreader::SongMetadata& metadata() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SongMetadata* release_metadata();
  ::cpb::tagreader::SongMetadata* mutable_metadata();
  void set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata);
  private:
  const ::cpb::tagreader::SongMetadata& _internal_metadata() const;
  ::cpb::tagreader::SongMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::cpb::tagreader::SongMetadata* metadata);
  ::cpb::tagreader::SongMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SaveSongRatingToFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::cpb::tagreader::SongMetadata* metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class SaveSongRatingToFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.SaveSongRatingToFileResponse) */ {
 public:
  inline SaveSongRatingToFileResponse() : SaveSongRatingToFileResponse(nullptr) {}
  ~SaveSongRatingToFileResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveSongRatingToFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSongRatingToFileResponse(const SaveSongRatingToFileResponse& from);
  SaveSongRatingToFileResponse(SaveSongRatingToFileResponse&& from) noexcept
    : SaveSongRatingToFileResponse() {
    *this = ::std::move(from);
  }

  inline SaveSongRatingToFileResponse& operator=(const SaveSongRatingToFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSongRatingToFileResponse& operator=(SaveSongRatingToFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveSongRatingToFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSongRatingToFileResponse* internal_default_instance() {
    return reinterpret_cast<const SaveSongRatingToFileResponse*>(
               &_SaveSongRatingToFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SaveSongRatingToFileResponse& a, SaveSongRatingToFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveSongRatingToFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSongRatingToFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSongRatingToFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSongRatingToFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveSongRatingToFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveSongRatingToFileResponse& from) {
    SaveSongRatingToFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveSongRatingToFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.SaveSongRatingToFileResponse";
  }
  protected:
  explicit SaveSongRatingToFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.SaveSongRatingToFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.tagreader.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.tagreader.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadFileRequestFieldNumber = 2,
    kReadFileResponseFieldNumber = 3,
    kSaveFileRequestFieldNumber = 4,
    kSaveFileResponseFieldNumber = 5,
    kIsMediaFileRequestFieldNumber = 6,
    kIsMediaFileResponseFieldNumber = 7,
    kLoadEmbeddedArtRequestFieldNumber = 8,
    kLoadEmbeddedArtResponseFieldNumber = 9,
    kReadCloudFileRequestFieldNumber = 10,
    kReadCloudFileResponseFieldNumber = 11,
    kSaveSongStatisticsToFileRequestFieldNumber = 12,
    kSaveSongStatisticsToFileResponseFieldNumber = 13,
    kSaveSongRatingToFileRequestFieldNumber = 14,
    kSaveSongRatingToFileResponseFieldNumber = 15,
    kIdFieldNumber = 1,
  };
  // optional .cpb.tagreader.ReadFileRequest read_file_request = 2;
  bool has_read_file_request() const;
  private:
  bool _internal_has_read_file_request() const;
  public:
  void clear_read_file_request();
  const ::cpb::tagreader::ReadFileRequest& read_file_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::ReadFileRequest* release_read_file_request();
  ::cpb::tagreader::ReadFileRequest* mutable_read_file_request();
  void set_allocated_read_file_request(::cpb::tagreader::ReadFileRequest* read_file_request);
  private:
  const ::cpb::tagreader::ReadFileRequest& _internal_read_file_request() const;
  ::cpb::tagreader::ReadFileRequest* _internal_mutable_read_file_request();
  public:
  void unsafe_arena_set_allocated_read_file_request(
      ::cpb::tagreader::ReadFileRequest* read_file_request);
  ::cpb::tagreader::ReadFileRequest* unsafe_arena_release_read_file_request();

  // optional .cpb.tagreader.ReadFileResponse read_file_response = 3;
  bool has_read_file_response() const;
  private:
  bool _internal_has_read_file_response() const;
  public:
  void clear_read_file_response();
  const ::cpb::tagreader::ReadFileResponse& read_file_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::ReadFileResponse* release_read_file_response();
  ::cpb::tagreader::ReadFileResponse* mutable_read_file_response();
  void set_allocated_read_file_response(::cpb::tagreader::ReadFileResponse* read_file_response);
  private:
  const ::cpb::tagreader::ReadFileResponse& _internal_read_file_response() const;
  ::cpb::tagreader::ReadFileResponse* _internal_mutable_read_file_response();
  public:
  void unsafe_arena_set_allocated_read_file_response(
      ::cpb::tagreader::ReadFileResponse* read_file_response);
  ::cpb::tagreader::ReadFileResponse* unsafe_arena_release_read_file_response();

  // optional .cpb.tagreader.SaveFileRequest save_file_request = 4;
  bool has_save_file_request() const;
  private:
  bool _internal_has_save_file_request() const;
  public:
  void clear_save_file_request();
  const ::cpb::tagreader::SaveFileRequest& save_file_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SaveFileRequest* release_save_file_request();
  ::cpb::tagreader::SaveFileRequest* mutable_save_file_request();
  void set_allocated_save_file_request(::cpb::tagreader::SaveFileRequest* save_file_request);
  private:
  const ::cpb::tagreader::SaveFileRequest& _internal_save_file_request() const;
  ::cpb::tagreader::SaveFileRequest* _internal_mutable_save_file_request();
  public:
  void unsafe_arena_set_allocated_save_file_request(
      ::cpb::tagreader::SaveFileRequest* save_file_request);
  ::cpb::tagreader::SaveFileRequest* unsafe_arena_release_save_file_request();

  // optional .cpb.tagreader.SaveFileResponse save_file_response = 5;
  bool has_save_file_response() const;
  private:
  bool _internal_has_save_file_response() const;
  public:
  void clear_save_file_response();
  const ::cpb::tagreader::SaveFileResponse& save_file_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SaveFileResponse* release_save_file_response();
  ::cpb::tagreader::SaveFileResponse* mutable_save_file_response();
  void set_allocated_save_file_response(::cpb::tagreader::SaveFileResponse* save_file_response);
  private:
  const ::cpb::tagreader::SaveFileResponse& _internal_save_file_response() const;
  ::cpb::tagreader::SaveFileResponse* _internal_mutable_save_file_response();
  public:
  void unsafe_arena_set_allocated_save_file_response(
      ::cpb::tagreader::SaveFileResponse* save_file_response);
  ::cpb::tagreader::SaveFileResponse* unsafe_arena_release_save_file_response();

  // optional .cpb.tagreader.IsMediaFileRequest is_media_file_request = 6;
  bool has_is_media_file_request() const;
  private:
  bool _internal_has_is_media_file_request() const;
  public:
  void clear_is_media_file_request();
  const ::cpb::tagreader::IsMediaFileRequest& is_media_file_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::IsMediaFileRequest* release_is_media_file_request();
  ::cpb::tagreader::IsMediaFileRequest* mutable_is_media_file_request();
  void set_allocated_is_media_file_request(::cpb::tagreader::IsMediaFileRequest* is_media_file_request);
  private:
  const ::cpb::tagreader::IsMediaFileRequest& _internal_is_media_file_request() const;
  ::cpb::tagreader::IsMediaFileRequest* _internal_mutable_is_media_file_request();
  public:
  void unsafe_arena_set_allocated_is_media_file_request(
      ::cpb::tagreader::IsMediaFileRequest* is_media_file_request);
  ::cpb::tagreader::IsMediaFileRequest* unsafe_arena_release_is_media_file_request();

  // optional .cpb.tagreader.IsMediaFileResponse is_media_file_response = 7;
  bool has_is_media_file_response() const;
  private:
  bool _internal_has_is_media_file_response() const;
  public:
  void clear_is_media_file_response();
  const ::cpb::tagreader::IsMediaFileResponse& is_media_file_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::IsMediaFileResponse* release_is_media_file_response();
  ::cpb::tagreader::IsMediaFileResponse* mutable_is_media_file_response();
  void set_allocated_is_media_file_response(::cpb::tagreader::IsMediaFileResponse* is_media_file_response);
  private:
  const ::cpb::tagreader::IsMediaFileResponse& _internal_is_media_file_response() const;
  ::cpb::tagreader::IsMediaFileResponse* _internal_mutable_is_media_file_response();
  public:
  void unsafe_arena_set_allocated_is_media_file_response(
      ::cpb::tagreader::IsMediaFileResponse* is_media_file_response);
  ::cpb::tagreader::IsMediaFileResponse* unsafe_arena_release_is_media_file_response();

  // optional .cpb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
  bool has_load_embedded_art_request() const;
  private:
  bool _internal_has_load_embedded_art_request() const;
  public:
  void clear_load_embedded_art_request();
  const ::cpb::tagreader::LoadEmbeddedArtRequest& load_embedded_art_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::LoadEmbeddedArtRequest* release_load_embedded_art_request();
  ::cpb::tagreader::LoadEmbeddedArtRequest* mutable_load_embedded_art_request();
  void set_allocated_load_embedded_art_request(::cpb::tagreader::LoadEmbeddedArtRequest* load_embedded_art_request);
  private:
  const ::cpb::tagreader::LoadEmbeddedArtRequest& _internal_load_embedded_art_request() const;
  ::cpb::tagreader::LoadEmbeddedArtRequest* _internal_mutable_load_embedded_art_request();
  public:
  void unsafe_arena_set_allocated_load_embedded_art_request(
      ::cpb::tagreader::LoadEmbeddedArtRequest* load_embedded_art_request);
  ::cpb::tagreader::LoadEmbeddedArtRequest* unsafe_arena_release_load_embedded_art_request();

  // optional .cpb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
  bool has_load_embedded_art_response() const;
  private:
  bool _internal_has_load_embedded_art_response() const;
  public:
  void clear_load_embedded_art_response();
  const ::cpb::tagreader::LoadEmbeddedArtResponse& load_embedded_art_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::LoadEmbeddedArtResponse* release_load_embedded_art_response();
  ::cpb::tagreader::LoadEmbeddedArtResponse* mutable_load_embedded_art_response();
  void set_allocated_load_embedded_art_response(::cpb::tagreader::LoadEmbeddedArtResponse* load_embedded_art_response);
  private:
  const ::cpb::tagreader::LoadEmbeddedArtResponse& _internal_load_embedded_art_response() const;
  ::cpb::tagreader::LoadEmbeddedArtResponse* _internal_mutable_load_embedded_art_response();
  public:
  void unsafe_arena_set_allocated_load_embedded_art_response(
      ::cpb::tagreader::LoadEmbeddedArtResponse* load_embedded_art_response);
  ::cpb::tagreader::LoadEmbeddedArtResponse* unsafe_arena_release_load_embedded_art_response();

  // optional .cpb.tagreader.ReadCloudFileRequest read_cloud_file_request = 10;
  bool has_read_cloud_file_request() const;
  private:
  bool _internal_has_read_cloud_file_request() const;
  public:
  void clear_read_cloud_file_request();
  const ::cpb::tagreader::ReadCloudFileRequest& read_cloud_file_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::ReadCloudFileRequest* release_read_cloud_file_request();
  ::cpb::tagreader::ReadCloudFileRequest* mutable_read_cloud_file_request();
  void set_allocated_read_cloud_file_request(::cpb::tagreader::ReadCloudFileRequest* read_cloud_file_request);
  private:
  const ::cpb::tagreader::ReadCloudFileRequest& _internal_read_cloud_file_request() const;
  ::cpb::tagreader::ReadCloudFileRequest* _internal_mutable_read_cloud_file_request();
  public:
  void unsafe_arena_set_allocated_read_cloud_file_request(
      ::cpb::tagreader::ReadCloudFileRequest* read_cloud_file_request);
  ::cpb::tagreader::ReadCloudFileRequest* unsafe_arena_release_read_cloud_file_request();

  // optional .cpb.tagreader.ReadCloudFileResponse read_cloud_file_response = 11;
  bool has_read_cloud_file_response() const;
  private:
  bool _internal_has_read_cloud_file_response() const;
  public:
  void clear_read_cloud_file_response();
  const ::cpb::tagreader::ReadCloudFileResponse& read_cloud_file_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::ReadCloudFileResponse* release_read_cloud_file_response();
  ::cpb::tagreader::ReadCloudFileResponse* mutable_read_cloud_file_response();
  void set_allocated_read_cloud_file_response(::cpb::tagreader::ReadCloudFileResponse* read_cloud_file_response);
  private:
  const ::cpb::tagreader::ReadCloudFileResponse& _internal_read_cloud_file_response() const;
  ::cpb::tagreader::ReadCloudFileResponse* _internal_mutable_read_cloud_file_response();
  public:
  void unsafe_arena_set_allocated_read_cloud_file_response(
      ::cpb::tagreader::ReadCloudFileResponse* read_cloud_file_response);
  ::cpb::tagreader::ReadCloudFileResponse* unsafe_arena_release_read_cloud_file_response();

  // optional .cpb.tagreader.SaveSongStatisticsToFileRequest save_song_statistics_to_file_request = 12;
  bool has_save_song_statistics_to_file_request() const;
  private:
  bool _internal_has_save_song_statistics_to_file_request() const;
  public:
  void clear_save_song_statistics_to_file_request();
  const ::cpb::tagreader::SaveSongStatisticsToFileRequest& save_song_statistics_to_file_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SaveSongStatisticsToFileRequest* release_save_song_statistics_to_file_request();
  ::cpb::tagreader::SaveSongStatisticsToFileRequest* mutable_save_song_statistics_to_file_request();
  void set_allocated_save_song_statistics_to_file_request(::cpb::tagreader::SaveSongStatisticsToFileRequest* save_song_statistics_to_file_request);
  private:
  const ::cpb::tagreader::SaveSongStatisticsToFileRequest& _internal_save_song_statistics_to_file_request() const;
  ::cpb::tagreader::SaveSongStatisticsToFileRequest* _internal_mutable_save_song_statistics_to_file_request();
  public:
  void unsafe_arena_set_allocated_save_song_statistics_to_file_request(
      ::cpb::tagreader::SaveSongStatisticsToFileRequest* save_song_statistics_to_file_request);
  ::cpb::tagreader::SaveSongStatisticsToFileRequest* unsafe_arena_release_save_song_statistics_to_file_request();

  // optional .cpb.tagreader.SaveSongStatisticsToFileResponse save_song_statistics_to_file_response = 13;
  bool has_save_song_statistics_to_file_response() const;
  private:
  bool _internal_has_save_song_statistics_to_file_response() const;
  public:
  void clear_save_song_statistics_to_file_response();
  const ::cpb::tagreader::SaveSongStatisticsToFileResponse& save_song_statistics_to_file_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SaveSongStatisticsToFileResponse* release_save_song_statistics_to_file_response();
  ::cpb::tagreader::SaveSongStatisticsToFileResponse* mutable_save_song_statistics_to_file_response();
  void set_allocated_save_song_statistics_to_file_response(::cpb::tagreader::SaveSongStatisticsToFileResponse* save_song_statistics_to_file_response);
  private:
  const ::cpb::tagreader::SaveSongStatisticsToFileResponse& _internal_save_song_statistics_to_file_response() const;
  ::cpb::tagreader::SaveSongStatisticsToFileResponse* _internal_mutable_save_song_statistics_to_file_response();
  public:
  void unsafe_arena_set_allocated_save_song_statistics_to_file_response(
      ::cpb::tagreader::SaveSongStatisticsToFileResponse* save_song_statistics_to_file_response);
  ::cpb::tagreader::SaveSongStatisticsToFileResponse* unsafe_arena_release_save_song_statistics_to_file_response();

  // optional .cpb.tagreader.SaveSongRatingToFileRequest save_song_rating_to_file_request = 14;
  bool has_save_song_rating_to_file_request() const;
  private:
  bool _internal_has_save_song_rating_to_file_request() const;
  public:
  void clear_save_song_rating_to_file_request();
  const ::cpb::tagreader::SaveSongRatingToFileRequest& save_song_rating_to_file_request() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SaveSongRatingToFileRequest* release_save_song_rating_to_file_request();
  ::cpb::tagreader::SaveSongRatingToFileRequest* mutable_save_song_rating_to_file_request();
  void set_allocated_save_song_rating_to_file_request(::cpb::tagreader::SaveSongRatingToFileRequest* save_song_rating_to_file_request);
  private:
  const ::cpb::tagreader::SaveSongRatingToFileRequest& _internal_save_song_rating_to_file_request() const;
  ::cpb::tagreader::SaveSongRatingToFileRequest* _internal_mutable_save_song_rating_to_file_request();
  public:
  void unsafe_arena_set_allocated_save_song_rating_to_file_request(
      ::cpb::tagreader::SaveSongRatingToFileRequest* save_song_rating_to_file_request);
  ::cpb::tagreader::SaveSongRatingToFileRequest* unsafe_arena_release_save_song_rating_to_file_request();

  // optional .cpb.tagreader.SaveSongRatingToFileResponse save_song_rating_to_file_response = 15;
  bool has_save_song_rating_to_file_response() const;
  private:
  bool _internal_has_save_song_rating_to_file_response() const;
  public:
  void clear_save_song_rating_to_file_response();
  const ::cpb::tagreader::SaveSongRatingToFileResponse& save_song_rating_to_file_response() const;
  PROTOBUF_NODISCARD ::cpb::tagreader::SaveSongRatingToFileResponse* release_save_song_rating_to_file_response();
  ::cpb::tagreader::SaveSongRatingToFileResponse* mutable_save_song_rating_to_file_response();
  void set_allocated_save_song_rating_to_file_response(::cpb::tagreader::SaveSongRatingToFileResponse* save_song_rating_to_file_response);
  private:
  const ::cpb::tagreader::SaveSongRatingToFileResponse& _internal_save_song_rating_to_file_response() const;
  ::cpb::tagreader::SaveSongRatingToFileResponse* _internal_mutable_save_song_rating_to_file_response();
  public:
  void unsafe_arena_set_allocated_save_song_rating_to_file_response(
      ::cpb::tagreader::SaveSongRatingToFileResponse* save_song_rating_to_file_response);
  ::cpb::tagreader::SaveSongRatingToFileResponse* unsafe_arena_release_save_song_rating_to_file_response();

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.tagreader.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cpb::tagreader::ReadFileRequest* read_file_request_;
    ::cpb::tagreader::ReadFileResponse* read_file_response_;
    ::cpb::tagreader::SaveFileRequest* save_file_request_;
    ::cpb::tagreader::SaveFileResponse* save_file_response_;
    ::cpb::tagreader::IsMediaFileRequest* is_media_file_request_;
    ::cpb::tagreader::IsMediaFileResponse* is_media_file_response_;
    ::cpb::tagreader::LoadEmbeddedArtRequest* load_embedded_art_request_;
    ::cpb::tagreader::LoadEmbeddedArtResponse* load_embedded_art_response_;
    ::cpb::tagreader::ReadCloudFileRequest* read_cloud_file_request_;
    ::cpb::tagreader::ReadCloudFileResponse* read_cloud_file_response_;
    ::cpb::tagreader::SaveSongStatisticsToFileRequest* save_song_statistics_to_file_request_;
    ::cpb::tagreader::SaveSongStatisticsToFileResponse* save_song_statistics_to_file_response_;
    ::cpb::tagreader::SaveSongRatingToFileRequest* save_song_rating_to_file_request_;
    ::cpb::tagreader::SaveSongRatingToFileResponse* save_song_rating_to_file_response_;
    int32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tagreadermessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SongMetadata

// optional bool valid = 1;
inline bool SongMetadata::_internal_has_valid() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool SongMetadata::has_valid() const {
  return _internal_has_valid();
}
inline void SongMetadata::clear_valid() {
  _impl_.valid_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool SongMetadata::_internal_valid() const {
  return _impl_.valid_;
}
inline bool SongMetadata::valid() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.valid)
  return _internal_valid();
}
inline void SongMetadata::_internal_set_valid(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.valid_ = value;
}
inline void SongMetadata::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.valid)
}

// optional string title = 2;
inline bool SongMetadata::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SongMetadata::has_title() const {
  return _internal_has_title();
}
inline void SongMetadata::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SongMetadata::title() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.title)
}
inline std::string* SongMetadata::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.title)
  return _s;
}
inline const std::string& SongMetadata::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SongMetadata::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_title() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.title)
}

// optional string album = 3;
inline bool SongMetadata::_internal_has_album() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SongMetadata::has_album() const {
  return _internal_has_album();
}
inline void SongMetadata::clear_album() {
  _impl_.album_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SongMetadata::album() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.album)
  return _internal_album();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_album(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.album_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.album)
}
inline std::string* SongMetadata::mutable_album() {
  std::string* _s = _internal_mutable_album();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.album)
  return _s;
}
inline const std::string& SongMetadata::_internal_album() const {
  return _impl_.album_.Get();
}
inline void SongMetadata::_internal_set_album(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.album_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_album() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.album_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_album() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.album)
  if (!_internal_has_album()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.album_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.album_.IsDefault()) {
    _impl_.album_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_album(std::string* album) {
  if (album != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.album_.SetAllocated(album, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.album_.IsDefault()) {
    _impl_.album_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.album)
}

// optional string artist = 4;
inline bool SongMetadata::_internal_has_artist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SongMetadata::has_artist() const {
  return _internal_has_artist();
}
inline void SongMetadata::clear_artist() {
  _impl_.artist_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SongMetadata::artist() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.artist)
  return _internal_artist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_artist(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.artist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.artist)
}
inline std::string* SongMetadata::mutable_artist() {
  std::string* _s = _internal_mutable_artist();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.artist)
  return _s;
}
inline const std::string& SongMetadata::_internal_artist() const {
  return _impl_.artist_.Get();
}
inline void SongMetadata::_internal_set_artist(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.artist_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_artist() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.artist_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_artist() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.artist)
  if (!_internal_has_artist()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.artist_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.artist_.IsDefault()) {
    _impl_.artist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_artist(std::string* artist) {
  if (artist != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.artist_.SetAllocated(artist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.artist_.IsDefault()) {
    _impl_.artist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.artist)
}

// optional string albumartist = 5;
inline bool SongMetadata::_internal_has_albumartist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SongMetadata::has_albumartist() const {
  return _internal_has_albumartist();
}
inline void SongMetadata::clear_albumartist() {
  _impl_.albumartist_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SongMetadata::albumartist() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.albumartist)
  return _internal_albumartist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_albumartist(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.albumartist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.albumartist)
}
inline std::string* SongMetadata::mutable_albumartist() {
  std::string* _s = _internal_mutable_albumartist();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.albumartist)
  return _s;
}
inline const std::string& SongMetadata::_internal_albumartist() const {
  return _impl_.albumartist_.Get();
}
inline void SongMetadata::_internal_set_albumartist(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.albumartist_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_albumartist() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.albumartist_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_albumartist() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.albumartist)
  if (!_internal_has_albumartist()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.albumartist_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumartist_.IsDefault()) {
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_albumartist(std::string* albumartist) {
  if (albumartist != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.albumartist_.SetAllocated(albumartist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumartist_.IsDefault()) {
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.albumartist)
}

// optional string composer = 6;
inline bool SongMetadata::_internal_has_composer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SongMetadata::has_composer() const {
  return _internal_has_composer();
}
inline void SongMetadata::clear_composer() {
  _impl_.composer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SongMetadata::composer() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.composer)
  return _internal_composer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_composer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.composer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.composer)
}
inline std::string* SongMetadata::mutable_composer() {
  std::string* _s = _internal_mutable_composer();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.composer)
  return _s;
}
inline const std::string& SongMetadata::_internal_composer() const {
  return _impl_.composer_.Get();
}
inline void SongMetadata::_internal_set_composer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.composer_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_composer() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.composer_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_composer() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.composer)
  if (!_internal_has_composer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.composer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.composer_.IsDefault()) {
    _impl_.composer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_composer(std::string* composer) {
  if (composer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.composer_.SetAllocated(composer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.composer_.IsDefault()) {
    _impl_.composer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.composer)
}

// optional int32 track = 7;
inline bool SongMetadata::_internal_has_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool SongMetadata::has_track() const {
  return _internal_has_track();
}
inline void SongMetadata::clear_track() {
  _impl_.track_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t SongMetadata::_internal_track() const {
  return _impl_.track_;
}
inline int32_t SongMetadata::track() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.track)
  return _internal_track();
}
inline void SongMetadata::_internal_set_track(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.track_ = value;
}
inline void SongMetadata::set_track(int32_t value) {
  _internal_set_track(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.track)
}

// optional int32 disc = 8;
inline bool SongMetadata::_internal_has_disc() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool SongMetadata::has_disc() const {
  return _internal_has_disc();
}
inline void SongMetadata::clear_disc() {
  _impl_.disc_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t SongMetadata::_internal_disc() const {
  return _impl_.disc_;
}
inline int32_t SongMetadata::disc() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.disc)
  return _internal_disc();
}
inline void SongMetadata::_internal_set_disc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.disc_ = value;
}
inline void SongMetadata::set_disc(int32_t value) {
  _internal_set_disc(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.disc)
}

// optional float bpm = 9;
inline bool SongMetadata::_internal_has_bpm() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool SongMetadata::has_bpm() const {
  return _internal_has_bpm();
}
inline void SongMetadata::clear_bpm() {
  _impl_.bpm_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float SongMetadata::_internal_bpm() const {
  return _impl_.bpm_;
}
inline float SongMetadata::bpm() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.bpm)
  return _internal_bpm();
}
inline void SongMetadata::_internal_set_bpm(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.bpm_ = value;
}
inline void SongMetadata::set_bpm(float value) {
  _internal_set_bpm(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.bpm)
}

// optional int32 year = 10;
inline bool SongMetadata::_internal_has_year() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool SongMetadata::has_year() const {
  return _internal_has_year();
}
inline void SongMetadata::clear_year() {
  _impl_.year_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int32_t SongMetadata::_internal_year() const {
  return _impl_.year_;
}
inline int32_t SongMetadata::year() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.year)
  return _internal_year();
}
inline void SongMetadata::_internal_set_year(int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.year_ = value;
}
inline void SongMetadata::set_year(int32_t value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.year)
}

// optional string genre = 11;
inline bool SongMetadata::_internal_has_genre() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SongMetadata::has_genre() const {
  return _internal_has_genre();
}
inline void SongMetadata::clear_genre() {
  _impl_.genre_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SongMetadata::genre() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.genre)
  return _internal_genre();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_genre(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.genre_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.genre)
}
inline std::string* SongMetadata::mutable_genre() {
  std::string* _s = _internal_mutable_genre();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.genre)
  return _s;
}
inline const std::string& SongMetadata::_internal_genre() const {
  return _impl_.genre_.Get();
}
inline void SongMetadata::_internal_set_genre(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.genre_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_genre() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.genre_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_genre() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.genre)
  if (!_internal_has_genre()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.genre_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.genre_.IsDefault()) {
    _impl_.genre_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_genre(std::string* genre) {
  if (genre != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.genre_.SetAllocated(genre, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.genre_.IsDefault()) {
    _impl_.genre_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.genre)
}

// optional string comment = 12;
inline bool SongMetadata::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SongMetadata::has_comment() const {
  return _internal_has_comment();
}
inline void SongMetadata::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SongMetadata::comment() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.comment)
}
inline std::string* SongMetadata::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.comment)
  return _s;
}
inline const std::string& SongMetadata::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void SongMetadata::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_comment() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.comment)
}

// optional bool compilation = 13;
inline bool SongMetadata::_internal_has_compilation() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool SongMetadata::has_compilation() const {
  return _internal_has_compilation();
}
inline void SongMetadata::clear_compilation() {
  _impl_.compilation_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool SongMetadata::_internal_compilation() const {
  return _impl_.compilation_;
}
inline bool SongMetadata::compilation() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.compilation)
  return _internal_compilation();
}
inline void SongMetadata::_internal_set_compilation(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.compilation_ = value;
}
inline void SongMetadata::set_compilation(bool value) {
  _internal_set_compilation(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.compilation)
}

// optional float rating = 14;
inline bool SongMetadata::_internal_has_rating() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool SongMetadata::has_rating() const {
  return _internal_has_rating();
}
inline void SongMetadata::clear_rating() {
  _impl_.rating_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline float SongMetadata::_internal_rating() const {
  return _impl_.rating_;
}
inline float SongMetadata::rating() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.rating)
  return _internal_rating();
}
inline void SongMetadata::_internal_set_rating(float value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.rating_ = value;
}
inline void SongMetadata::set_rating(float value) {
  _internal_set_rating(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.rating)
}

// optional int32 playcount = 15;
inline bool SongMetadata::_internal_has_playcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool SongMetadata::has_playcount() const {
  return _internal_has_playcount();
}
inline void SongMetadata::clear_playcount() {
  _impl_.playcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t SongMetadata::_internal_playcount() const {
  return _impl_.playcount_;
}
inline int32_t SongMetadata::playcount() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.playcount)
  return _internal_playcount();
}
inline void SongMetadata::_internal_set_playcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.playcount_ = value;
}
inline void SongMetadata::set_playcount(int32_t value) {
  _internal_set_playcount(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.playcount)
}

// optional int32 skipcount = 16;
inline bool SongMetadata::_internal_has_skipcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool SongMetadata::has_skipcount() const {
  return _internal_has_skipcount();
}
inline void SongMetadata::clear_skipcount() {
  _impl_.skipcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline int32_t SongMetadata::_internal_skipcount() const {
  return _impl_.skipcount_;
}
inline int32_t SongMetadata::skipcount() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.skipcount)
  return _internal_skipcount();
}
inline void SongMetadata::_internal_set_skipcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.skipcount_ = value;
}
inline void SongMetadata::set_skipcount(int32_t value) {
  _internal_set_skipcount(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.skipcount)
}

// optional int32 lastplayed = 17;
inline bool SongMetadata::_internal_has_lastplayed() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool SongMetadata::has_lastplayed() const {
  return _internal_has_lastplayed();
}
inline void SongMetadata::clear_lastplayed() {
  _impl_.lastplayed_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int32_t SongMetadata::_internal_lastplayed() const {
  return _impl_.lastplayed_;
}
inline int32_t SongMetadata::lastplayed() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.lastplayed)
  return _internal_lastplayed();
}
inline void SongMetadata::_internal_set_lastplayed(int32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.lastplayed_ = value;
}
inline void SongMetadata::set_lastplayed(int32_t value) {
  _internal_set_lastplayed(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.lastplayed)
}

// optional int32 score = 18;
inline bool SongMetadata::_internal_has_score() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool SongMetadata::has_score() const {
  return _internal_has_score();
}
inline void SongMetadata::clear_score() {
  _impl_.score_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline int32_t SongMetadata::_internal_score() const {
  return _impl_.score_;
}
inline int32_t SongMetadata::score() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.score)
  return _internal_score();
}
inline void SongMetadata::_internal_set_score(int32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.score_ = value;
}
inline void SongMetadata::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.score)
}

// optional uint64 length_nanosec = 19;
inline bool SongMetadata::_internal_has_length_nanosec() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool SongMetadata::has_length_nanosec() const {
  return _internal_has_length_nanosec();
}
inline void SongMetadata::clear_length_nanosec() {
  _impl_.length_nanosec_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline uint64_t SongMetadata::_internal_length_nanosec() const {
  return _impl_.length_nanosec_;
}
inline uint64_t SongMetadata::length_nanosec() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.length_nanosec)
  return _internal_length_nanosec();
}
inline void SongMetadata::_internal_set_length_nanosec(uint64_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.length_nanosec_ = value;
}
inline void SongMetadata::set_length_nanosec(uint64_t value) {
  _internal_set_length_nanosec(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.length_nanosec)
}

// optional int32 bitrate = 20;
inline bool SongMetadata::_internal_has_bitrate() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool SongMetadata::has_bitrate() const {
  return _internal_has_bitrate();
}
inline void SongMetadata::clear_bitrate() {
  _impl_.bitrate_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline int32_t SongMetadata::_internal_bitrate() const {
  return _impl_.bitrate_;
}
inline int32_t SongMetadata::bitrate() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.bitrate)
  return _internal_bitrate();
}
inline void SongMetadata::_internal_set_bitrate(int32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.bitrate_ = value;
}
inline void SongMetadata::set_bitrate(int32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.bitrate)
}

// optional int32 samplerate = 21;
inline bool SongMetadata::_internal_has_samplerate() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool SongMetadata::has_samplerate() const {
  return _internal_has_samplerate();
}
inline void SongMetadata::clear_samplerate() {
  _impl_.samplerate_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline int32_t SongMetadata::_internal_samplerate() const {
  return _impl_.samplerate_;
}
inline int32_t SongMetadata::samplerate() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.samplerate)
  return _internal_samplerate();
}
inline void SongMetadata::_internal_set_samplerate(int32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.samplerate_ = value;
}
inline void SongMetadata::set_samplerate(int32_t value) {
  _internal_set_samplerate(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.samplerate)
}

// optional string url = 22;
inline bool SongMetadata::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SongMetadata::has_url() const {
  return _internal_has_url();
}
inline void SongMetadata::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SongMetadata::url() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.url)
}
inline std::string* SongMetadata::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.url)
  return _s;
}
inline const std::string& SongMetadata::_internal_url() const {
  return _impl_.url_.Get();
}
inline void SongMetadata::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_url() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.url)
}

// optional string basefilename = 23;
inline bool SongMetadata::_internal_has_basefilename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SongMetadata::has_basefilename() const {
  return _internal_has_basefilename();
}
inline void SongMetadata::clear_basefilename() {
  _impl_.basefilename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& SongMetadata::basefilename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.basefilename)
  return _internal_basefilename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_basefilename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.basefilename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.basefilename)
}
inline std::string* SongMetadata::mutable_basefilename() {
  std::string* _s = _internal_mutable_basefilename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.basefilename)
  return _s;
}
inline const std::string& SongMetadata::_internal_basefilename() const {
  return _impl_.basefilename_.Get();
}
inline void SongMetadata::_internal_set_basefilename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.basefilename_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_basefilename() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.basefilename_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_basefilename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.basefilename)
  if (!_internal_has_basefilename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.basefilename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.basefilename_.IsDefault()) {
    _impl_.basefilename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_basefilename(std::string* basefilename) {
  if (basefilename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.basefilename_.SetAllocated(basefilename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.basefilename_.IsDefault()) {
    _impl_.basefilename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.basefilename)
}

// optional int32 mtime = 24;
inline bool SongMetadata::_internal_has_mtime() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool SongMetadata::has_mtime() const {
  return _internal_has_mtime();
}
inline void SongMetadata::clear_mtime() {
  _impl_.mtime_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline int32_t SongMetadata::_internal_mtime() const {
  return _impl_.mtime_;
}
inline int32_t SongMetadata::mtime() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.mtime)
  return _internal_mtime();
}
inline void SongMetadata::_internal_set_mtime(int32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.mtime_ = value;
}
inline void SongMetadata::set_mtime(int32_t value) {
  _internal_set_mtime(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.mtime)
}

// optional int32 ctime = 25;
inline bool SongMetadata::_internal_has_ctime() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool SongMetadata::has_ctime() const {
  return _internal_has_ctime();
}
inline void SongMetadata::clear_ctime() {
  _impl_.ctime_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline int32_t SongMetadata::_internal_ctime() const {
  return _impl_.ctime_;
}
inline int32_t SongMetadata::ctime() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.ctime)
  return _internal_ctime();
}
inline void SongMetadata::_internal_set_ctime(int32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.ctime_ = value;
}
inline void SongMetadata::set_ctime(int32_t value) {
  _internal_set_ctime(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.ctime)
}

// optional int32 filesize = 26;
inline bool SongMetadata::_internal_has_filesize() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool SongMetadata::has_filesize() const {
  return _internal_has_filesize();
}
inline void SongMetadata::clear_filesize() {
  _impl_.filesize_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline int32_t SongMetadata::_internal_filesize() const {
  return _impl_.filesize_;
}
inline int32_t SongMetadata::filesize() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.filesize)
  return _internal_filesize();
}
inline void SongMetadata::_internal_set_filesize(int32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.filesize_ = value;
}
inline void SongMetadata::set_filesize(int32_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.filesize)
}

// optional bool suspicious_tags = 27;
inline bool SongMetadata::_internal_has_suspicious_tags() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool SongMetadata::has_suspicious_tags() const {
  return _internal_has_suspicious_tags();
}
inline void SongMetadata::clear_suspicious_tags() {
  _impl_.suspicious_tags_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool SongMetadata::_internal_suspicious_tags() const {
  return _impl_.suspicious_tags_;
}
inline bool SongMetadata::suspicious_tags() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.suspicious_tags)
  return _internal_suspicious_tags();
}
inline void SongMetadata::_internal_set_suspicious_tags(bool value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.suspicious_tags_ = value;
}
inline void SongMetadata::set_suspicious_tags(bool value) {
  _internal_set_suspicious_tags(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.suspicious_tags)
}

// optional string art_automatic = 28;
inline bool SongMetadata::_internal_has_art_automatic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SongMetadata::has_art_automatic() const {
  return _internal_has_art_automatic();
}
inline void SongMetadata::clear_art_automatic() {
  _impl_.art_automatic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& SongMetadata::art_automatic() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.art_automatic)
  return _internal_art_automatic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_art_automatic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.art_automatic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.art_automatic)
}
inline std::string* SongMetadata::mutable_art_automatic() {
  std::string* _s = _internal_mutable_art_automatic();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.art_automatic)
  return _s;
}
inline const std::string& SongMetadata::_internal_art_automatic() const {
  return _impl_.art_automatic_.Get();
}
inline void SongMetadata::_internal_set_art_automatic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.art_automatic_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_art_automatic() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.art_automatic_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_art_automatic() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.art_automatic)
  if (!_internal_has_art_automatic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.art_automatic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_automatic_.IsDefault()) {
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_art_automatic(std::string* art_automatic) {
  if (art_automatic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.art_automatic_.SetAllocated(art_automatic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_automatic_.IsDefault()) {
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.art_automatic)
}

// optional .cpb.tagreader.SongMetadata.Type type = 29;
inline bool SongMetadata::_internal_has_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool SongMetadata::has_type() const {
  return _internal_has_type();
}
inline void SongMetadata::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline ::cpb::tagreader::SongMetadata_Type SongMetadata::_internal_type() const {
  return static_cast< ::cpb::tagreader::SongMetadata_Type >(_impl_.type_);
}
inline ::cpb::tagreader::SongMetadata_Type SongMetadata::type() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.type)
  return _internal_type();
}
inline void SongMetadata::_internal_set_type(::cpb::tagreader::SongMetadata_Type value) {
  assert(::cpb::tagreader::SongMetadata_Type_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void SongMetadata::set_type(::cpb::tagreader::SongMetadata_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.type)
}

// optional string etag = 30;
inline bool SongMetadata::_internal_has_etag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SongMetadata::has_etag() const {
  return _internal_has_etag();
}
inline void SongMetadata::clear_etag() {
  _impl_.etag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& SongMetadata::etag() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_etag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.etag)
}
inline std::string* SongMetadata::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.etag)
  return _s;
}
inline const std::string& SongMetadata::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void SongMetadata::_internal_set_etag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_etag() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_etag() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.etag)
}

// optional string performer = 31;
inline bool SongMetadata::_internal_has_performer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SongMetadata::has_performer() const {
  return _internal_has_performer();
}
inline void SongMetadata::clear_performer() {
  _impl_.performer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& SongMetadata::performer() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.performer)
  return _internal_performer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_performer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.performer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.performer)
}
inline std::string* SongMetadata::mutable_performer() {
  std::string* _s = _internal_mutable_performer();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.performer)
  return _s;
}
inline const std::string& SongMetadata::_internal_performer() const {
  return _impl_.performer_.Get();
}
inline void SongMetadata::_internal_set_performer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.performer_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_performer() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.performer_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_performer() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.performer)
  if (!_internal_has_performer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.performer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.performer_.IsDefault()) {
    _impl_.performer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_performer(std::string* performer) {
  if (performer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.performer_.SetAllocated(performer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.performer_.IsDefault()) {
    _impl_.performer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.performer)
}

// optional string grouping = 32;
inline bool SongMetadata::_internal_has_grouping() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SongMetadata::has_grouping() const {
  return _internal_has_grouping();
}
inline void SongMetadata::clear_grouping() {
  _impl_.grouping_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& SongMetadata::grouping() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.grouping)
  return _internal_grouping();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_grouping(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.grouping_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.grouping)
}
inline std::string* SongMetadata::mutable_grouping() {
  std::string* _s = _internal_mutable_grouping();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.grouping)
  return _s;
}
inline const std::string& SongMetadata::_internal_grouping() const {
  return _impl_.grouping_.Get();
}
inline void SongMetadata::_internal_set_grouping(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.grouping_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_grouping() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.grouping_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_grouping() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.grouping)
  if (!_internal_has_grouping()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.grouping_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.grouping_.IsDefault()) {
    _impl_.grouping_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_grouping(std::string* grouping) {
  if (grouping != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.grouping_.SetAllocated(grouping, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.grouping_.IsDefault()) {
    _impl_.grouping_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.grouping)
}

// optional string lyrics = 33;
inline bool SongMetadata::_internal_has_lyrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SongMetadata::has_lyrics() const {
  return _internal_has_lyrics();
}
inline void SongMetadata::clear_lyrics() {
  _impl_.lyrics_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& SongMetadata::lyrics() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.lyrics)
  return _internal_lyrics();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_lyrics(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.lyrics_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.lyrics)
}
inline std::string* SongMetadata::mutable_lyrics() {
  std::string* _s = _internal_mutable_lyrics();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SongMetadata.lyrics)
  return _s;
}
inline const std::string& SongMetadata::_internal_lyrics() const {
  return _impl_.lyrics_.Get();
}
inline void SongMetadata::_internal_set_lyrics(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.lyrics_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_lyrics() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.lyrics_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_lyrics() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SongMetadata.lyrics)
  if (!_internal_has_lyrics()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.lyrics_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lyrics_.IsDefault()) {
    _impl_.lyrics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_lyrics(std::string* lyrics) {
  if (lyrics != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.lyrics_.SetAllocated(lyrics, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lyrics_.IsDefault()) {
    _impl_.lyrics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SongMetadata.lyrics)
}

// optional int32 originalyear = 34;
inline bool SongMetadata::_internal_has_originalyear() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool SongMetadata::has_originalyear() const {
  return _internal_has_originalyear();
}
inline void SongMetadata::clear_originalyear() {
  _impl_.originalyear_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline int32_t SongMetadata::_internal_originalyear() const {
  return _impl_.originalyear_;
}
inline int32_t SongMetadata::originalyear() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SongMetadata.originalyear)
  return _internal_originalyear();
}
inline void SongMetadata::_internal_set_originalyear(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.originalyear_ = value;
}
inline void SongMetadata::set_originalyear(int32_t value) {
  _internal_set_originalyear(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SongMetadata.originalyear)
}

// -------------------------------------------------------------------

// ReadFileRequest

// optional string filename = 1;
inline bool ReadFileRequest::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReadFileRequest::has_filename() const {
  return _internal_has_filename();
}
inline void ReadFileRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReadFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadFileRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadFileRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.ReadFileRequest.filename)
}
inline std::string* ReadFileRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadFileRequest.filename)
  return _s;
}
inline const std::string& ReadFileRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void ReadFileRequest::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadFileRequest::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadFileRequest.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReadFileRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadFileRequest.filename)
}

// -------------------------------------------------------------------

// ReadFileResponse

// optional .cpb.tagreader.SongMetadata metadata = 1;
inline bool ReadFileResponse::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool ReadFileResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void ReadFileResponse::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cpb::tagreader::SongMetadata& ReadFileResponse::_internal_metadata() const {
  const ::cpb::tagreader::SongMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SongMetadata&>(
      ::cpb::tagreader::_SongMetadata_default_instance_);
}
inline const ::cpb::tagreader::SongMetadata& ReadFileResponse::metadata() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadFileResponse.metadata)
  return _internal_metadata();
}
inline void ReadFileResponse::unsafe_arena_set_allocated_metadata(
    ::cpb::tagreader::SongMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.ReadFileResponse.metadata)
}
inline ::cpb::tagreader::SongMetadata* ReadFileResponse::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SongMetadata* ReadFileResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadFileResponse.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SongMetadata* ReadFileResponse::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SongMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cpb::tagreader::SongMetadata* ReadFileResponse::mutable_metadata() {
  ::cpb::tagreader::SongMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadFileResponse.metadata)
  return _msg;
}
inline void ReadFileResponse::set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadFileResponse.metadata)
}

// -------------------------------------------------------------------

// SaveFileRequest

// optional string filename = 1;
inline bool SaveFileRequest::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveFileRequest::has_filename() const {
  return _internal_has_filename();
}
inline void SaveFileRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveFileRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveFileRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SaveFileRequest.filename)
}
inline std::string* SaveFileRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SaveFileRequest.filename)
  return _s;
}
inline const std::string& SaveFileRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void SaveFileRequest::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveFileRequest::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SaveFileRequest.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SaveFileRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SaveFileRequest.filename)
}

// optional .cpb.tagreader.SongMetadata metadata = 2;
inline bool SaveFileRequest::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool SaveFileRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void SaveFileRequest::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cpb::tagreader::SongMetadata& SaveFileRequest::_internal_metadata() const {
  const ::cpb::tagreader::SongMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SongMetadata&>(
      ::cpb::tagreader::_SongMetadata_default_instance_);
}
inline const ::cpb::tagreader::SongMetadata& SaveFileRequest::metadata() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveFileRequest.metadata)
  return _internal_metadata();
}
inline void SaveFileRequest::unsafe_arena_set_allocated_metadata(
    ::cpb::tagreader::SongMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.SaveFileRequest.metadata)
}
inline ::cpb::tagreader::SongMetadata* SaveFileRequest::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SongMetadata* SaveFileRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SaveFileRequest.metadata)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SongMetadata* SaveFileRequest::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SongMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cpb::tagreader::SongMetadata* SaveFileRequest::mutable_metadata() {
  ::cpb::tagreader::SongMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SaveFileRequest.metadata)
  return _msg;
}
inline void SaveFileRequest::set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SaveFileRequest.metadata)
}

// -------------------------------------------------------------------

// SaveFileResponse

// optional bool success = 1;
inline bool SaveFileResponse::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveFileResponse::has_success() const {
  return _internal_has_success();
}
inline void SaveFileResponse::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SaveFileResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SaveFileResponse::success() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveFileResponse.success)
  return _internal_success();
}
inline void SaveFileResponse::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void SaveFileResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SaveFileResponse.success)
}

// -------------------------------------------------------------------

// IsMediaFileRequest

// optional string filename = 1;
inline bool IsMediaFileRequest::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IsMediaFileRequest::has_filename() const {
  return _internal_has_filename();
}
inline void IsMediaFileRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IsMediaFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.IsMediaFileRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsMediaFileRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.IsMediaFileRequest.filename)
}
inline std::string* IsMediaFileRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.IsMediaFileRequest.filename)
  return _s;
}
inline const std::string& IsMediaFileRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void IsMediaFileRequest::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* IsMediaFileRequest::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* IsMediaFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.IsMediaFileRequest.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IsMediaFileRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.IsMediaFileRequest.filename)
}

// -------------------------------------------------------------------

// IsMediaFileResponse

// optional bool success = 1;
inline bool IsMediaFileResponse::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IsMediaFileResponse::has_success() const {
  return _internal_has_success();
}
inline void IsMediaFileResponse::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool IsMediaFileResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool IsMediaFileResponse::success() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.IsMediaFileResponse.success)
  return _internal_success();
}
inline void IsMediaFileResponse::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void IsMediaFileResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.IsMediaFileResponse.success)
}

// -------------------------------------------------------------------

// LoadEmbeddedArtRequest

// optional string filename = 1;
inline bool LoadEmbeddedArtRequest::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoadEmbeddedArtRequest::has_filename() const {
  return _internal_has_filename();
}
inline void LoadEmbeddedArtRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoadEmbeddedArtRequest::filename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.LoadEmbeddedArtRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadEmbeddedArtRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.LoadEmbeddedArtRequest.filename)
}
inline std::string* LoadEmbeddedArtRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.LoadEmbeddedArtRequest.filename)
  return _s;
}
inline const std::string& LoadEmbeddedArtRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void LoadEmbeddedArtRequest::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadEmbeddedArtRequest::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadEmbeddedArtRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.LoadEmbeddedArtRequest.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadEmbeddedArtRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.LoadEmbeddedArtRequest.filename)
}

// -------------------------------------------------------------------

// LoadEmbeddedArtResponse

// optional bytes data = 1;
inline bool LoadEmbeddedArtResponse::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoadEmbeddedArtResponse::has_data() const {
  return _internal_has_data();
}
inline void LoadEmbeddedArtResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoadEmbeddedArtResponse::data() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.LoadEmbeddedArtResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadEmbeddedArtResponse::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.LoadEmbeddedArtResponse.data)
}
inline std::string* LoadEmbeddedArtResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.LoadEmbeddedArtResponse.data)
  return _s;
}
inline const std::string& LoadEmbeddedArtResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void LoadEmbeddedArtResponse::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadEmbeddedArtResponse::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadEmbeddedArtResponse::release_data() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.LoadEmbeddedArtResponse.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadEmbeddedArtResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.LoadEmbeddedArtResponse.data)
}

// -------------------------------------------------------------------

// ReadCloudFileRequest

// optional string download_url = 1;
inline bool ReadCloudFileRequest::_internal_has_download_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReadCloudFileRequest::has_download_url() const {
  return _internal_has_download_url();
}
inline void ReadCloudFileRequest::clear_download_url() {
  _impl_.download_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReadCloudFileRequest::download_url() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadCloudFileRequest.download_url)
  return _internal_download_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadCloudFileRequest::set_download_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.download_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.ReadCloudFileRequest.download_url)
}
inline std::string* ReadCloudFileRequest::mutable_download_url() {
  std::string* _s = _internal_mutable_download_url();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadCloudFileRequest.download_url)
  return _s;
}
inline const std::string& ReadCloudFileRequest::_internal_download_url() const {
  return _impl_.download_url_.Get();
}
inline void ReadCloudFileRequest::_internal_set_download_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.download_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::_internal_mutable_download_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.download_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::release_download_url() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadCloudFileRequest.download_url)
  if (!_internal_has_download_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.download_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.download_url_.IsDefault()) {
    _impl_.download_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReadCloudFileRequest::set_allocated_download_url(std::string* download_url) {
  if (download_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.download_url_.SetAllocated(download_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.download_url_.IsDefault()) {
    _impl_.download_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadCloudFileRequest.download_url)
}

// optional string title = 2;
inline bool ReadCloudFileRequest::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReadCloudFileRequest::has_title() const {
  return _internal_has_title();
}
inline void ReadCloudFileRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReadCloudFileRequest::title() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadCloudFileRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadCloudFileRequest::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.ReadCloudFileRequest.title)
}
inline std::string* ReadCloudFileRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadCloudFileRequest.title)
  return _s;
}
inline const std::string& ReadCloudFileRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ReadCloudFileRequest::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::release_title() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadCloudFileRequest.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReadCloudFileRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadCloudFileRequest.title)
}

// optional int32 size = 3;
inline bool ReadCloudFileRequest::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ReadCloudFileRequest::has_size() const {
  return _internal_has_size();
}
inline void ReadCloudFileRequest::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ReadCloudFileRequest::_internal_size() const {
  return _impl_.size_;
}
inline int32_t ReadCloudFileRequest::size() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadCloudFileRequest.size)
  return _internal_size();
}
inline void ReadCloudFileRequest::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_ = value;
}
inline void ReadCloudFileRequest::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.ReadCloudFileRequest.size)
}

// optional string authorisation_header = 4;
inline bool ReadCloudFileRequest::_internal_has_authorisation_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReadCloudFileRequest::has_authorisation_header() const {
  return _internal_has_authorisation_header();
}
inline void ReadCloudFileRequest::clear_authorisation_header() {
  _impl_.authorisation_header_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ReadCloudFileRequest::authorisation_header() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadCloudFileRequest.authorisation_header)
  return _internal_authorisation_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadCloudFileRequest::set_authorisation_header(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.authorisation_header_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.ReadCloudFileRequest.authorisation_header)
}
inline std::string* ReadCloudFileRequest::mutable_authorisation_header() {
  std::string* _s = _internal_mutable_authorisation_header();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadCloudFileRequest.authorisation_header)
  return _s;
}
inline const std::string& ReadCloudFileRequest::_internal_authorisation_header() const {
  return _impl_.authorisation_header_.Get();
}
inline void ReadCloudFileRequest::_internal_set_authorisation_header(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.authorisation_header_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::_internal_mutable_authorisation_header() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.authorisation_header_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::release_authorisation_header() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadCloudFileRequest.authorisation_header)
  if (!_internal_has_authorisation_header()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.authorisation_header_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorisation_header_.IsDefault()) {
    _impl_.authorisation_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReadCloudFileRequest::set_allocated_authorisation_header(std::string* authorisation_header) {
  if (authorisation_header != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.authorisation_header_.SetAllocated(authorisation_header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorisation_header_.IsDefault()) {
    _impl_.authorisation_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadCloudFileRequest.authorisation_header)
}

// optional string mime_type = 5;
inline bool ReadCloudFileRequest::_internal_has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReadCloudFileRequest::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void ReadCloudFileRequest::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ReadCloudFileRequest::mime_type() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadCloudFileRequest.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadCloudFileRequest::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.ReadCloudFileRequest.mime_type)
}
inline std::string* ReadCloudFileRequest::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadCloudFileRequest.mime_type)
  return _s;
}
inline const std::string& ReadCloudFileRequest::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void ReadCloudFileRequest::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadCloudFileRequest::release_mime_type() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadCloudFileRequest.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReadCloudFileRequest::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadCloudFileRequest.mime_type)
}

// -------------------------------------------------------------------

// ReadCloudFileResponse

// optional .cpb.tagreader.SongMetadata metadata = 1;
inline bool ReadCloudFileResponse::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool ReadCloudFileResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void ReadCloudFileResponse::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cpb::tagreader::SongMetadata& ReadCloudFileResponse::_internal_metadata() const {
  const ::cpb::tagreader::SongMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SongMetadata&>(
      ::cpb::tagreader::_SongMetadata_default_instance_);
}
inline const ::cpb::tagreader::SongMetadata& ReadCloudFileResponse::metadata() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.ReadCloudFileResponse.metadata)
  return _internal_metadata();
}
inline void ReadCloudFileResponse::unsafe_arena_set_allocated_metadata(
    ::cpb::tagreader::SongMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.ReadCloudFileResponse.metadata)
}
inline ::cpb::tagreader::SongMetadata* ReadCloudFileResponse::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SongMetadata* ReadCloudFileResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.ReadCloudFileResponse.metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SongMetadata* ReadCloudFileResponse::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SongMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cpb::tagreader::SongMetadata* ReadCloudFileResponse::mutable_metadata() {
  ::cpb::tagreader::SongMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.ReadCloudFileResponse.metadata)
  return _msg;
}
inline void ReadCloudFileResponse::set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.ReadCloudFileResponse.metadata)
}

// -------------------------------------------------------------------

// SaveSongStatisticsToFileRequest

// optional string filename = 1;
inline bool SaveSongStatisticsToFileRequest::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveSongStatisticsToFileRequest::has_filename() const {
  return _internal_has_filename();
}
inline void SaveSongStatisticsToFileRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveSongStatisticsToFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveSongStatisticsToFileRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSongStatisticsToFileRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SaveSongStatisticsToFileRequest.filename)
}
inline std::string* SaveSongStatisticsToFileRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SaveSongStatisticsToFileRequest.filename)
  return _s;
}
inline const std::string& SaveSongStatisticsToFileRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void SaveSongStatisticsToFileRequest::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSongStatisticsToFileRequest::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSongStatisticsToFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SaveSongStatisticsToFileRequest.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SaveSongStatisticsToFileRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SaveSongStatisticsToFileRequest.filename)
}

// optional .cpb.tagreader.SongMetadata metadata = 2;
inline bool SaveSongStatisticsToFileRequest::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool SaveSongStatisticsToFileRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void SaveSongStatisticsToFileRequest::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cpb::tagreader::SongMetadata& SaveSongStatisticsToFileRequest::_internal_metadata() const {
  const ::cpb::tagreader::SongMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SongMetadata&>(
      ::cpb::tagreader::_SongMetadata_default_instance_);
}
inline const ::cpb::tagreader::SongMetadata& SaveSongStatisticsToFileRequest::metadata() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveSongStatisticsToFileRequest.metadata)
  return _internal_metadata();
}
inline void SaveSongStatisticsToFileRequest::unsafe_arena_set_allocated_metadata(
    ::cpb::tagreader::SongMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.SaveSongStatisticsToFileRequest.metadata)
}
inline ::cpb::tagreader::SongMetadata* SaveSongStatisticsToFileRequest::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SongMetadata* SaveSongStatisticsToFileRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SaveSongStatisticsToFileRequest.metadata)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SongMetadata* SaveSongStatisticsToFileRequest::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SongMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cpb::tagreader::SongMetadata* SaveSongStatisticsToFileRequest::mutable_metadata() {
  ::cpb::tagreader::SongMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SaveSongStatisticsToFileRequest.metadata)
  return _msg;
}
inline void SaveSongStatisticsToFileRequest::set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SaveSongStatisticsToFileRequest.metadata)
}

// -------------------------------------------------------------------

// SaveSongStatisticsToFileResponse

// optional bool success = 1;
inline bool SaveSongStatisticsToFileResponse::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveSongStatisticsToFileResponse::has_success() const {
  return _internal_has_success();
}
inline void SaveSongStatisticsToFileResponse::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SaveSongStatisticsToFileResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SaveSongStatisticsToFileResponse::success() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveSongStatisticsToFileResponse.success)
  return _internal_success();
}
inline void SaveSongStatisticsToFileResponse::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void SaveSongStatisticsToFileResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SaveSongStatisticsToFileResponse.success)
}

// -------------------------------------------------------------------

// SaveSongRatingToFileRequest

// optional string filename = 1;
inline bool SaveSongRatingToFileRequest::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveSongRatingToFileRequest::has_filename() const {
  return _internal_has_filename();
}
inline void SaveSongRatingToFileRequest::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveSongRatingToFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveSongRatingToFileRequest.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveSongRatingToFileRequest::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.tagreader.SaveSongRatingToFileRequest.filename)
}
inline std::string* SaveSongRatingToFileRequest::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SaveSongRatingToFileRequest.filename)
  return _s;
}
inline const std::string& SaveSongRatingToFileRequest::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void SaveSongRatingToFileRequest::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveSongRatingToFileRequest::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveSongRatingToFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SaveSongRatingToFileRequest.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SaveSongRatingToFileRequest::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SaveSongRatingToFileRequest.filename)
}

// optional .cpb.tagreader.SongMetadata metadata = 2;
inline bool SaveSongRatingToFileRequest::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline bool SaveSongRatingToFileRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void SaveSongRatingToFileRequest::clear_metadata() {
  if (_impl_.metadata_ != nullptr) _impl_.metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cpb::tagreader::SongMetadata& SaveSongRatingToFileRequest::_internal_metadata() const {
  const ::cpb::tagreader::SongMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SongMetadata&>(
      ::cpb::tagreader::_SongMetadata_default_instance_);
}
inline const ::cpb::tagreader::SongMetadata& SaveSongRatingToFileRequest::metadata() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveSongRatingToFileRequest.metadata)
  return _internal_metadata();
}
inline void SaveSongRatingToFileRequest::unsafe_arena_set_allocated_metadata(
    ::cpb::tagreader::SongMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.SaveSongRatingToFileRequest.metadata)
}
inline ::cpb::tagreader::SongMetadata* SaveSongRatingToFileRequest::release_metadata() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SongMetadata* SaveSongRatingToFileRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.SaveSongRatingToFileRequest.metadata)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::SongMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SongMetadata* SaveSongRatingToFileRequest::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SongMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::cpb::tagreader::SongMetadata* SaveSongRatingToFileRequest::mutable_metadata() {
  ::cpb::tagreader::SongMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.SaveSongRatingToFileRequest.metadata)
  return _msg;
}
inline void SaveSongRatingToFileRequest::set_allocated_metadata(::cpb::tagreader::SongMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.SaveSongRatingToFileRequest.metadata)
}

// -------------------------------------------------------------------

// SaveSongRatingToFileResponse

// optional bool success = 1;
inline bool SaveSongRatingToFileResponse::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveSongRatingToFileResponse::has_success() const {
  return _internal_has_success();
}
inline void SaveSongRatingToFileResponse::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SaveSongRatingToFileResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SaveSongRatingToFileResponse::success() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.SaveSongRatingToFileResponse.success)
  return _internal_success();
}
inline void SaveSongRatingToFileResponse::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void SaveSongRatingToFileResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.SaveSongRatingToFileResponse.success)
}

// -------------------------------------------------------------------

// Message

// optional int32 id = 1;
inline bool Message::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Message::has_id() const {
  return _internal_has_id();
}
inline void Message::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t Message::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Message::id() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.id)
  return _internal_id();
}
inline void Message::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.id_ = value;
}
inline void Message::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.tagreader.Message.id)
}

// optional .cpb.tagreader.ReadFileRequest read_file_request = 2;
inline bool Message::_internal_has_read_file_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.read_file_request_ != nullptr);
  return value;
}
inline bool Message::has_read_file_request() const {
  return _internal_has_read_file_request();
}
inline void Message::clear_read_file_request() {
  if (_impl_.read_file_request_ != nullptr) _impl_.read_file_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cpb::tagreader::ReadFileRequest& Message::_internal_read_file_request() const {
  const ::cpb::tagreader::ReadFileRequest* p = _impl_.read_file_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::ReadFileRequest&>(
      ::cpb::tagreader::_ReadFileRequest_default_instance_);
}
inline const ::cpb::tagreader::ReadFileRequest& Message::read_file_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.read_file_request)
  return _internal_read_file_request();
}
inline void Message::unsafe_arena_set_allocated_read_file_request(
    ::cpb::tagreader::ReadFileRequest* read_file_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_file_request_);
  }
  _impl_.read_file_request_ = read_file_request;
  if (read_file_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.read_file_request)
}
inline ::cpb::tagreader::ReadFileRequest* Message::release_read_file_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::tagreader::ReadFileRequest* temp = _impl_.read_file_request_;
  _impl_.read_file_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::ReadFileRequest* Message::unsafe_arena_release_read_file_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.read_file_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::tagreader::ReadFileRequest* temp = _impl_.read_file_request_;
  _impl_.read_file_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::ReadFileRequest* Message::_internal_mutable_read_file_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.read_file_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::ReadFileRequest>(GetArenaForAllocation());
    _impl_.read_file_request_ = p;
  }
  return _impl_.read_file_request_;
}
inline ::cpb::tagreader::ReadFileRequest* Message::mutable_read_file_request() {
  ::cpb::tagreader::ReadFileRequest* _msg = _internal_mutable_read_file_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.read_file_request)
  return _msg;
}
inline void Message::set_allocated_read_file_request(::cpb::tagreader::ReadFileRequest* read_file_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_file_request_;
  }
  if (read_file_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_file_request);
    if (message_arena != submessage_arena) {
      read_file_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_file_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.read_file_request_ = read_file_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.read_file_request)
}

// optional .cpb.tagreader.ReadFileResponse read_file_response = 3;
inline bool Message::_internal_has_read_file_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.read_file_response_ != nullptr);
  return value;
}
inline bool Message::has_read_file_response() const {
  return _internal_has_read_file_response();
}
inline void Message::clear_read_file_response() {
  if (_impl_.read_file_response_ != nullptr) _impl_.read_file_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cpb::tagreader::ReadFileResponse& Message::_internal_read_file_response() const {
  const ::cpb::tagreader::ReadFileResponse* p = _impl_.read_file_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::ReadFileResponse&>(
      ::cpb::tagreader::_ReadFileResponse_default_instance_);
}
inline const ::cpb::tagreader::ReadFileResponse& Message::read_file_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.read_file_response)
  return _internal_read_file_response();
}
inline void Message::unsafe_arena_set_allocated_read_file_response(
    ::cpb::tagreader::ReadFileResponse* read_file_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_file_response_);
  }
  _impl_.read_file_response_ = read_file_response;
  if (read_file_response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.read_file_response)
}
inline ::cpb::tagreader::ReadFileResponse* Message::release_read_file_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::ReadFileResponse* temp = _impl_.read_file_response_;
  _impl_.read_file_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::ReadFileResponse* Message::unsafe_arena_release_read_file_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.read_file_response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::tagreader::ReadFileResponse* temp = _impl_.read_file_response_;
  _impl_.read_file_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::ReadFileResponse* Message::_internal_mutable_read_file_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.read_file_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::ReadFileResponse>(GetArenaForAllocation());
    _impl_.read_file_response_ = p;
  }
  return _impl_.read_file_response_;
}
inline ::cpb::tagreader::ReadFileResponse* Message::mutable_read_file_response() {
  ::cpb::tagreader::ReadFileResponse* _msg = _internal_mutable_read_file_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.read_file_response)
  return _msg;
}
inline void Message::set_allocated_read_file_response(::cpb::tagreader::ReadFileResponse* read_file_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_file_response_;
  }
  if (read_file_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_file_response);
    if (message_arena != submessage_arena) {
      read_file_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_file_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.read_file_response_ = read_file_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.read_file_response)
}

// optional .cpb.tagreader.SaveFileRequest save_file_request = 4;
inline bool Message::_internal_has_save_file_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.save_file_request_ != nullptr);
  return value;
}
inline bool Message::has_save_file_request() const {
  return _internal_has_save_file_request();
}
inline void Message::clear_save_file_request() {
  if (_impl_.save_file_request_ != nullptr) _impl_.save_file_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cpb::tagreader::SaveFileRequest& Message::_internal_save_file_request() const {
  const ::cpb::tagreader::SaveFileRequest* p = _impl_.save_file_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SaveFileRequest&>(
      ::cpb::tagreader::_SaveFileRequest_default_instance_);
}
inline const ::cpb::tagreader::SaveFileRequest& Message::save_file_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.save_file_request)
  return _internal_save_file_request();
}
inline void Message::unsafe_arena_set_allocated_save_file_request(
    ::cpb::tagreader::SaveFileRequest* save_file_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_file_request_);
  }
  _impl_.save_file_request_ = save_file_request;
  if (save_file_request) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.save_file_request)
}
inline ::cpb::tagreader::SaveFileRequest* Message::release_save_file_request() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cpb::tagreader::SaveFileRequest* temp = _impl_.save_file_request_;
  _impl_.save_file_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SaveFileRequest* Message::unsafe_arena_release_save_file_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.save_file_request)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cpb::tagreader::SaveFileRequest* temp = _impl_.save_file_request_;
  _impl_.save_file_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SaveFileRequest* Message::_internal_mutable_save_file_request() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.save_file_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SaveFileRequest>(GetArenaForAllocation());
    _impl_.save_file_request_ = p;
  }
  return _impl_.save_file_request_;
}
inline ::cpb::tagreader::SaveFileRequest* Message::mutable_save_file_request() {
  ::cpb::tagreader::SaveFileRequest* _msg = _internal_mutable_save_file_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.save_file_request)
  return _msg;
}
inline void Message::set_allocated_save_file_request(::cpb::tagreader::SaveFileRequest* save_file_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_file_request_;
  }
  if (save_file_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_file_request);
    if (message_arena != submessage_arena) {
      save_file_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_file_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.save_file_request_ = save_file_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.save_file_request)
}

// optional .cpb.tagreader.SaveFileResponse save_file_response = 5;
inline bool Message::_internal_has_save_file_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.save_file_response_ != nullptr);
  return value;
}
inline bool Message::has_save_file_response() const {
  return _internal_has_save_file_response();
}
inline void Message::clear_save_file_response() {
  if (_impl_.save_file_response_ != nullptr) _impl_.save_file_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::cpb::tagreader::SaveFileResponse& Message::_internal_save_file_response() const {
  const ::cpb::tagreader::SaveFileResponse* p = _impl_.save_file_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SaveFileResponse&>(
      ::cpb::tagreader::_SaveFileResponse_default_instance_);
}
inline const ::cpb::tagreader::SaveFileResponse& Message::save_file_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.save_file_response)
  return _internal_save_file_response();
}
inline void Message::unsafe_arena_set_allocated_save_file_response(
    ::cpb::tagreader::SaveFileResponse* save_file_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_file_response_);
  }
  _impl_.save_file_response_ = save_file_response;
  if (save_file_response) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.save_file_response)
}
inline ::cpb::tagreader::SaveFileResponse* Message::release_save_file_response() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cpb::tagreader::SaveFileResponse* temp = _impl_.save_file_response_;
  _impl_.save_file_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SaveFileResponse* Message::unsafe_arena_release_save_file_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.save_file_response)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cpb::tagreader::SaveFileResponse* temp = _impl_.save_file_response_;
  _impl_.save_file_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SaveFileResponse* Message::_internal_mutable_save_file_response() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.save_file_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SaveFileResponse>(GetArenaForAllocation());
    _impl_.save_file_response_ = p;
  }
  return _impl_.save_file_response_;
}
inline ::cpb::tagreader::SaveFileResponse* Message::mutable_save_file_response() {
  ::cpb::tagreader::SaveFileResponse* _msg = _internal_mutable_save_file_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.save_file_response)
  return _msg;
}
inline void Message::set_allocated_save_file_response(::cpb::tagreader::SaveFileResponse* save_file_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_file_response_;
  }
  if (save_file_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_file_response);
    if (message_arena != submessage_arena) {
      save_file_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_file_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.save_file_response_ = save_file_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.save_file_response)
}

// optional .cpb.tagreader.IsMediaFileRequest is_media_file_request = 6;
inline bool Message::_internal_has_is_media_file_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.is_media_file_request_ != nullptr);
  return value;
}
inline bool Message::has_is_media_file_request() const {
  return _internal_has_is_media_file_request();
}
inline void Message::clear_is_media_file_request() {
  if (_impl_.is_media_file_request_ != nullptr) _impl_.is_media_file_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::cpb::tagreader::IsMediaFileRequest& Message::_internal_is_media_file_request() const {
  const ::cpb::tagreader::IsMediaFileRequest* p = _impl_.is_media_file_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::IsMediaFileRequest&>(
      ::cpb::tagreader::_IsMediaFileRequest_default_instance_);
}
inline const ::cpb::tagreader::IsMediaFileRequest& Message::is_media_file_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.is_media_file_request)
  return _internal_is_media_file_request();
}
inline void Message::unsafe_arena_set_allocated_is_media_file_request(
    ::cpb::tagreader::IsMediaFileRequest* is_media_file_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.is_media_file_request_);
  }
  _impl_.is_media_file_request_ = is_media_file_request;
  if (is_media_file_request) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.is_media_file_request)
}
inline ::cpb::tagreader::IsMediaFileRequest* Message::release_is_media_file_request() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::cpb::tagreader::IsMediaFileRequest* temp = _impl_.is_media_file_request_;
  _impl_.is_media_file_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::IsMediaFileRequest* Message::unsafe_arena_release_is_media_file_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.is_media_file_request)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::cpb::tagreader::IsMediaFileRequest* temp = _impl_.is_media_file_request_;
  _impl_.is_media_file_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::IsMediaFileRequest* Message::_internal_mutable_is_media_file_request() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.is_media_file_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::IsMediaFileRequest>(GetArenaForAllocation());
    _impl_.is_media_file_request_ = p;
  }
  return _impl_.is_media_file_request_;
}
inline ::cpb::tagreader::IsMediaFileRequest* Message::mutable_is_media_file_request() {
  ::cpb::tagreader::IsMediaFileRequest* _msg = _internal_mutable_is_media_file_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.is_media_file_request)
  return _msg;
}
inline void Message::set_allocated_is_media_file_request(::cpb::tagreader::IsMediaFileRequest* is_media_file_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.is_media_file_request_;
  }
  if (is_media_file_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(is_media_file_request);
    if (message_arena != submessage_arena) {
      is_media_file_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, is_media_file_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.is_media_file_request_ = is_media_file_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.is_media_file_request)
}

// optional .cpb.tagreader.IsMediaFileResponse is_media_file_response = 7;
inline bool Message::_internal_has_is_media_file_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.is_media_file_response_ != nullptr);
  return value;
}
inline bool Message::has_is_media_file_response() const {
  return _internal_has_is_media_file_response();
}
inline void Message::clear_is_media_file_response() {
  if (_impl_.is_media_file_response_ != nullptr) _impl_.is_media_file_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::cpb::tagreader::IsMediaFileResponse& Message::_internal_is_media_file_response() const {
  const ::cpb::tagreader::IsMediaFileResponse* p = _impl_.is_media_file_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::IsMediaFileResponse&>(
      ::cpb::tagreader::_IsMediaFileResponse_default_instance_);
}
inline const ::cpb::tagreader::IsMediaFileResponse& Message::is_media_file_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.is_media_file_response)
  return _internal_is_media_file_response();
}
inline void Message::unsafe_arena_set_allocated_is_media_file_response(
    ::cpb::tagreader::IsMediaFileResponse* is_media_file_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.is_media_file_response_);
  }
  _impl_.is_media_file_response_ = is_media_file_response;
  if (is_media_file_response) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.is_media_file_response)
}
inline ::cpb::tagreader::IsMediaFileResponse* Message::release_is_media_file_response() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::cpb::tagreader::IsMediaFileResponse* temp = _impl_.is_media_file_response_;
  _impl_.is_media_file_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::IsMediaFileResponse* Message::unsafe_arena_release_is_media_file_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.is_media_file_response)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::cpb::tagreader::IsMediaFileResponse* temp = _impl_.is_media_file_response_;
  _impl_.is_media_file_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::IsMediaFileResponse* Message::_internal_mutable_is_media_file_response() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.is_media_file_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::IsMediaFileResponse>(GetArenaForAllocation());
    _impl_.is_media_file_response_ = p;
  }
  return _impl_.is_media_file_response_;
}
inline ::cpb::tagreader::IsMediaFileResponse* Message::mutable_is_media_file_response() {
  ::cpb::tagreader::IsMediaFileResponse* _msg = _internal_mutable_is_media_file_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.is_media_file_response)
  return _msg;
}
inline void Message::set_allocated_is_media_file_response(::cpb::tagreader::IsMediaFileResponse* is_media_file_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.is_media_file_response_;
  }
  if (is_media_file_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(is_media_file_response);
    if (message_arena != submessage_arena) {
      is_media_file_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, is_media_file_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.is_media_file_response_ = is_media_file_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.is_media_file_response)
}

// optional .cpb.tagreader.LoadEmbeddedArtRequest load_embedded_art_request = 8;
inline bool Message::_internal_has_load_embedded_art_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.load_embedded_art_request_ != nullptr);
  return value;
}
inline bool Message::has_load_embedded_art_request() const {
  return _internal_has_load_embedded_art_request();
}
inline void Message::clear_load_embedded_art_request() {
  if (_impl_.load_embedded_art_request_ != nullptr) _impl_.load_embedded_art_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::cpb::tagreader::LoadEmbeddedArtRequest& Message::_internal_load_embedded_art_request() const {
  const ::cpb::tagreader::LoadEmbeddedArtRequest* p = _impl_.load_embedded_art_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::LoadEmbeddedArtRequest&>(
      ::cpb::tagreader::_LoadEmbeddedArtRequest_default_instance_);
}
inline const ::cpb::tagreader::LoadEmbeddedArtRequest& Message::load_embedded_art_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.load_embedded_art_request)
  return _internal_load_embedded_art_request();
}
inline void Message::unsafe_arena_set_allocated_load_embedded_art_request(
    ::cpb::tagreader::LoadEmbeddedArtRequest* load_embedded_art_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.load_embedded_art_request_);
  }
  _impl_.load_embedded_art_request_ = load_embedded_art_request;
  if (load_embedded_art_request) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.load_embedded_art_request)
}
inline ::cpb::tagreader::LoadEmbeddedArtRequest* Message::release_load_embedded_art_request() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::cpb::tagreader::LoadEmbeddedArtRequest* temp = _impl_.load_embedded_art_request_;
  _impl_.load_embedded_art_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::LoadEmbeddedArtRequest* Message::unsafe_arena_release_load_embedded_art_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.load_embedded_art_request)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::cpb::tagreader::LoadEmbeddedArtRequest* temp = _impl_.load_embedded_art_request_;
  _impl_.load_embedded_art_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::LoadEmbeddedArtRequest* Message::_internal_mutable_load_embedded_art_request() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.load_embedded_art_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::LoadEmbeddedArtRequest>(GetArenaForAllocation());
    _impl_.load_embedded_art_request_ = p;
  }
  return _impl_.load_embedded_art_request_;
}
inline ::cpb::tagreader::LoadEmbeddedArtRequest* Message::mutable_load_embedded_art_request() {
  ::cpb::tagreader::LoadEmbeddedArtRequest* _msg = _internal_mutable_load_embedded_art_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.load_embedded_art_request)
  return _msg;
}
inline void Message::set_allocated_load_embedded_art_request(::cpb::tagreader::LoadEmbeddedArtRequest* load_embedded_art_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.load_embedded_art_request_;
  }
  if (load_embedded_art_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(load_embedded_art_request);
    if (message_arena != submessage_arena) {
      load_embedded_art_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load_embedded_art_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.load_embedded_art_request_ = load_embedded_art_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.load_embedded_art_request)
}

// optional .cpb.tagreader.LoadEmbeddedArtResponse load_embedded_art_response = 9;
inline bool Message::_internal_has_load_embedded_art_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.load_embedded_art_response_ != nullptr);
  return value;
}
inline bool Message::has_load_embedded_art_response() const {
  return _internal_has_load_embedded_art_response();
}
inline void Message::clear_load_embedded_art_response() {
  if (_impl_.load_embedded_art_response_ != nullptr) _impl_.load_embedded_art_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::cpb::tagreader::LoadEmbeddedArtResponse& Message::_internal_load_embedded_art_response() const {
  const ::cpb::tagreader::LoadEmbeddedArtResponse* p = _impl_.load_embedded_art_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::LoadEmbeddedArtResponse&>(
      ::cpb::tagreader::_LoadEmbeddedArtResponse_default_instance_);
}
inline const ::cpb::tagreader::LoadEmbeddedArtResponse& Message::load_embedded_art_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.load_embedded_art_response)
  return _internal_load_embedded_art_response();
}
inline void Message::unsafe_arena_set_allocated_load_embedded_art_response(
    ::cpb::tagreader::LoadEmbeddedArtResponse* load_embedded_art_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.load_embedded_art_response_);
  }
  _impl_.load_embedded_art_response_ = load_embedded_art_response;
  if (load_embedded_art_response) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.load_embedded_art_response)
}
inline ::cpb::tagreader::LoadEmbeddedArtResponse* Message::release_load_embedded_art_response() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::cpb::tagreader::LoadEmbeddedArtResponse* temp = _impl_.load_embedded_art_response_;
  _impl_.load_embedded_art_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::LoadEmbeddedArtResponse* Message::unsafe_arena_release_load_embedded_art_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.load_embedded_art_response)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::cpb::tagreader::LoadEmbeddedArtResponse* temp = _impl_.load_embedded_art_response_;
  _impl_.load_embedded_art_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::LoadEmbeddedArtResponse* Message::_internal_mutable_load_embedded_art_response() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.load_embedded_art_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::LoadEmbeddedArtResponse>(GetArenaForAllocation());
    _impl_.load_embedded_art_response_ = p;
  }
  return _impl_.load_embedded_art_response_;
}
inline ::cpb::tagreader::LoadEmbeddedArtResponse* Message::mutable_load_embedded_art_response() {
  ::cpb::tagreader::LoadEmbeddedArtResponse* _msg = _internal_mutable_load_embedded_art_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.load_embedded_art_response)
  return _msg;
}
inline void Message::set_allocated_load_embedded_art_response(::cpb::tagreader::LoadEmbeddedArtResponse* load_embedded_art_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.load_embedded_art_response_;
  }
  if (load_embedded_art_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(load_embedded_art_response);
    if (message_arena != submessage_arena) {
      load_embedded_art_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load_embedded_art_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.load_embedded_art_response_ = load_embedded_art_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.load_embedded_art_response)
}

// optional .cpb.tagreader.ReadCloudFileRequest read_cloud_file_request = 10;
inline bool Message::_internal_has_read_cloud_file_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.read_cloud_file_request_ != nullptr);
  return value;
}
inline bool Message::has_read_cloud_file_request() const {
  return _internal_has_read_cloud_file_request();
}
inline void Message::clear_read_cloud_file_request() {
  if (_impl_.read_cloud_file_request_ != nullptr) _impl_.read_cloud_file_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::cpb::tagreader::ReadCloudFileRequest& Message::_internal_read_cloud_file_request() const {
  const ::cpb::tagreader::ReadCloudFileRequest* p = _impl_.read_cloud_file_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::ReadCloudFileRequest&>(
      ::cpb::tagreader::_ReadCloudFileRequest_default_instance_);
}
inline const ::cpb::tagreader::ReadCloudFileRequest& Message::read_cloud_file_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.read_cloud_file_request)
  return _internal_read_cloud_file_request();
}
inline void Message::unsafe_arena_set_allocated_read_cloud_file_request(
    ::cpb::tagreader::ReadCloudFileRequest* read_cloud_file_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_cloud_file_request_);
  }
  _impl_.read_cloud_file_request_ = read_cloud_file_request;
  if (read_cloud_file_request) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.read_cloud_file_request)
}
inline ::cpb::tagreader::ReadCloudFileRequest* Message::release_read_cloud_file_request() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::cpb::tagreader::ReadCloudFileRequest* temp = _impl_.read_cloud_file_request_;
  _impl_.read_cloud_file_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::ReadCloudFileRequest* Message::unsafe_arena_release_read_cloud_file_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.read_cloud_file_request)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::cpb::tagreader::ReadCloudFileRequest* temp = _impl_.read_cloud_file_request_;
  _impl_.read_cloud_file_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::ReadCloudFileRequest* Message::_internal_mutable_read_cloud_file_request() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.read_cloud_file_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::ReadCloudFileRequest>(GetArenaForAllocation());
    _impl_.read_cloud_file_request_ = p;
  }
  return _impl_.read_cloud_file_request_;
}
inline ::cpb::tagreader::ReadCloudFileRequest* Message::mutable_read_cloud_file_request() {
  ::cpb::tagreader::ReadCloudFileRequest* _msg = _internal_mutable_read_cloud_file_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.read_cloud_file_request)
  return _msg;
}
inline void Message::set_allocated_read_cloud_file_request(::cpb::tagreader::ReadCloudFileRequest* read_cloud_file_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_cloud_file_request_;
  }
  if (read_cloud_file_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_cloud_file_request);
    if (message_arena != submessage_arena) {
      read_cloud_file_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_cloud_file_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.read_cloud_file_request_ = read_cloud_file_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.read_cloud_file_request)
}

// optional .cpb.tagreader.ReadCloudFileResponse read_cloud_file_response = 11;
inline bool Message::_internal_has_read_cloud_file_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.read_cloud_file_response_ != nullptr);
  return value;
}
inline bool Message::has_read_cloud_file_response() const {
  return _internal_has_read_cloud_file_response();
}
inline void Message::clear_read_cloud_file_response() {
  if (_impl_.read_cloud_file_response_ != nullptr) _impl_.read_cloud_file_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::cpb::tagreader::ReadCloudFileResponse& Message::_internal_read_cloud_file_response() const {
  const ::cpb::tagreader::ReadCloudFileResponse* p = _impl_.read_cloud_file_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::ReadCloudFileResponse&>(
      ::cpb::tagreader::_ReadCloudFileResponse_default_instance_);
}
inline const ::cpb::tagreader::ReadCloudFileResponse& Message::read_cloud_file_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.read_cloud_file_response)
  return _internal_read_cloud_file_response();
}
inline void Message::unsafe_arena_set_allocated_read_cloud_file_response(
    ::cpb::tagreader::ReadCloudFileResponse* read_cloud_file_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_cloud_file_response_);
  }
  _impl_.read_cloud_file_response_ = read_cloud_file_response;
  if (read_cloud_file_response) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.read_cloud_file_response)
}
inline ::cpb::tagreader::ReadCloudFileResponse* Message::release_read_cloud_file_response() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::cpb::tagreader::ReadCloudFileResponse* temp = _impl_.read_cloud_file_response_;
  _impl_.read_cloud_file_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::ReadCloudFileResponse* Message::unsafe_arena_release_read_cloud_file_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.read_cloud_file_response)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::cpb::tagreader::ReadCloudFileResponse* temp = _impl_.read_cloud_file_response_;
  _impl_.read_cloud_file_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::ReadCloudFileResponse* Message::_internal_mutable_read_cloud_file_response() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.read_cloud_file_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::ReadCloudFileResponse>(GetArenaForAllocation());
    _impl_.read_cloud_file_response_ = p;
  }
  return _impl_.read_cloud_file_response_;
}
inline ::cpb::tagreader::ReadCloudFileResponse* Message::mutable_read_cloud_file_response() {
  ::cpb::tagreader::ReadCloudFileResponse* _msg = _internal_mutable_read_cloud_file_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.read_cloud_file_response)
  return _msg;
}
inline void Message::set_allocated_read_cloud_file_response(::cpb::tagreader::ReadCloudFileResponse* read_cloud_file_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_cloud_file_response_;
  }
  if (read_cloud_file_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_cloud_file_response);
    if (message_arena != submessage_arena) {
      read_cloud_file_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_cloud_file_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.read_cloud_file_response_ = read_cloud_file_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.read_cloud_file_response)
}

// optional .cpb.tagreader.SaveSongStatisticsToFileRequest save_song_statistics_to_file_request = 12;
inline bool Message::_internal_has_save_song_statistics_to_file_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.save_song_statistics_to_file_request_ != nullptr);
  return value;
}
inline bool Message::has_save_song_statistics_to_file_request() const {
  return _internal_has_save_song_statistics_to_file_request();
}
inline void Message::clear_save_song_statistics_to_file_request() {
  if (_impl_.save_song_statistics_to_file_request_ != nullptr) _impl_.save_song_statistics_to_file_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::cpb::tagreader::SaveSongStatisticsToFileRequest& Message::_internal_save_song_statistics_to_file_request() const {
  const ::cpb::tagreader::SaveSongStatisticsToFileRequest* p = _impl_.save_song_statistics_to_file_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SaveSongStatisticsToFileRequest&>(
      ::cpb::tagreader::_SaveSongStatisticsToFileRequest_default_instance_);
}
inline const ::cpb::tagreader::SaveSongStatisticsToFileRequest& Message::save_song_statistics_to_file_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.save_song_statistics_to_file_request)
  return _internal_save_song_statistics_to_file_request();
}
inline void Message::unsafe_arena_set_allocated_save_song_statistics_to_file_request(
    ::cpb::tagreader::SaveSongStatisticsToFileRequest* save_song_statistics_to_file_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_song_statistics_to_file_request_);
  }
  _impl_.save_song_statistics_to_file_request_ = save_song_statistics_to_file_request;
  if (save_song_statistics_to_file_request) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.save_song_statistics_to_file_request)
}
inline ::cpb::tagreader::SaveSongStatisticsToFileRequest* Message::release_save_song_statistics_to_file_request() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::cpb::tagreader::SaveSongStatisticsToFileRequest* temp = _impl_.save_song_statistics_to_file_request_;
  _impl_.save_song_statistics_to_file_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SaveSongStatisticsToFileRequest* Message::unsafe_arena_release_save_song_statistics_to_file_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.save_song_statistics_to_file_request)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::cpb::tagreader::SaveSongStatisticsToFileRequest* temp = _impl_.save_song_statistics_to_file_request_;
  _impl_.save_song_statistics_to_file_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SaveSongStatisticsToFileRequest* Message::_internal_mutable_save_song_statistics_to_file_request() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.save_song_statistics_to_file_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SaveSongStatisticsToFileRequest>(GetArenaForAllocation());
    _impl_.save_song_statistics_to_file_request_ = p;
  }
  return _impl_.save_song_statistics_to_file_request_;
}
inline ::cpb::tagreader::SaveSongStatisticsToFileRequest* Message::mutable_save_song_statistics_to_file_request() {
  ::cpb::tagreader::SaveSongStatisticsToFileRequest* _msg = _internal_mutable_save_song_statistics_to_file_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.save_song_statistics_to_file_request)
  return _msg;
}
inline void Message::set_allocated_save_song_statistics_to_file_request(::cpb::tagreader::SaveSongStatisticsToFileRequest* save_song_statistics_to_file_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_song_statistics_to_file_request_;
  }
  if (save_song_statistics_to_file_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_song_statistics_to_file_request);
    if (message_arena != submessage_arena) {
      save_song_statistics_to_file_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_song_statistics_to_file_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.save_song_statistics_to_file_request_ = save_song_statistics_to_file_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.save_song_statistics_to_file_request)
}

// optional .cpb.tagreader.SaveSongStatisticsToFileResponse save_song_statistics_to_file_response = 13;
inline bool Message::_internal_has_save_song_statistics_to_file_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.save_song_statistics_to_file_response_ != nullptr);
  return value;
}
inline bool Message::has_save_song_statistics_to_file_response() const {
  return _internal_has_save_song_statistics_to_file_response();
}
inline void Message::clear_save_song_statistics_to_file_response() {
  if (_impl_.save_song_statistics_to_file_response_ != nullptr) _impl_.save_song_statistics_to_file_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::cpb::tagreader::SaveSongStatisticsToFileResponse& Message::_internal_save_song_statistics_to_file_response() const {
  const ::cpb::tagreader::SaveSongStatisticsToFileResponse* p = _impl_.save_song_statistics_to_file_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SaveSongStatisticsToFileResponse&>(
      ::cpb::tagreader::_SaveSongStatisticsToFileResponse_default_instance_);
}
inline const ::cpb::tagreader::SaveSongStatisticsToFileResponse& Message::save_song_statistics_to_file_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.save_song_statistics_to_file_response)
  return _internal_save_song_statistics_to_file_response();
}
inline void Message::unsafe_arena_set_allocated_save_song_statistics_to_file_response(
    ::cpb::tagreader::SaveSongStatisticsToFileResponse* save_song_statistics_to_file_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_song_statistics_to_file_response_);
  }
  _impl_.save_song_statistics_to_file_response_ = save_song_statistics_to_file_response;
  if (save_song_statistics_to_file_response) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.save_song_statistics_to_file_response)
}
inline ::cpb::tagreader::SaveSongStatisticsToFileResponse* Message::release_save_song_statistics_to_file_response() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::cpb::tagreader::SaveSongStatisticsToFileResponse* temp = _impl_.save_song_statistics_to_file_response_;
  _impl_.save_song_statistics_to_file_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SaveSongStatisticsToFileResponse* Message::unsafe_arena_release_save_song_statistics_to_file_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.save_song_statistics_to_file_response)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::cpb::tagreader::SaveSongStatisticsToFileResponse* temp = _impl_.save_song_statistics_to_file_response_;
  _impl_.save_song_statistics_to_file_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SaveSongStatisticsToFileResponse* Message::_internal_mutable_save_song_statistics_to_file_response() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.save_song_statistics_to_file_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SaveSongStatisticsToFileResponse>(GetArenaForAllocation());
    _impl_.save_song_statistics_to_file_response_ = p;
  }
  return _impl_.save_song_statistics_to_file_response_;
}
inline ::cpb::tagreader::SaveSongStatisticsToFileResponse* Message::mutable_save_song_statistics_to_file_response() {
  ::cpb::tagreader::SaveSongStatisticsToFileResponse* _msg = _internal_mutable_save_song_statistics_to_file_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.save_song_statistics_to_file_response)
  return _msg;
}
inline void Message::set_allocated_save_song_statistics_to_file_response(::cpb::tagreader::SaveSongStatisticsToFileResponse* save_song_statistics_to_file_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_song_statistics_to_file_response_;
  }
  if (save_song_statistics_to_file_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_song_statistics_to_file_response);
    if (message_arena != submessage_arena) {
      save_song_statistics_to_file_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_song_statistics_to_file_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.save_song_statistics_to_file_response_ = save_song_statistics_to_file_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.save_song_statistics_to_file_response)
}

// optional .cpb.tagreader.SaveSongRatingToFileRequest save_song_rating_to_file_request = 14;
inline bool Message::_internal_has_save_song_rating_to_file_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.save_song_rating_to_file_request_ != nullptr);
  return value;
}
inline bool Message::has_save_song_rating_to_file_request() const {
  return _internal_has_save_song_rating_to_file_request();
}
inline void Message::clear_save_song_rating_to_file_request() {
  if (_impl_.save_song_rating_to_file_request_ != nullptr) _impl_.save_song_rating_to_file_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::cpb::tagreader::SaveSongRatingToFileRequest& Message::_internal_save_song_rating_to_file_request() const {
  const ::cpb::tagreader::SaveSongRatingToFileRequest* p = _impl_.save_song_rating_to_file_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SaveSongRatingToFileRequest&>(
      ::cpb::tagreader::_SaveSongRatingToFileRequest_default_instance_);
}
inline const ::cpb::tagreader::SaveSongRatingToFileRequest& Message::save_song_rating_to_file_request() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.save_song_rating_to_file_request)
  return _internal_save_song_rating_to_file_request();
}
inline void Message::unsafe_arena_set_allocated_save_song_rating_to_file_request(
    ::cpb::tagreader::SaveSongRatingToFileRequest* save_song_rating_to_file_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_song_rating_to_file_request_);
  }
  _impl_.save_song_rating_to_file_request_ = save_song_rating_to_file_request;
  if (save_song_rating_to_file_request) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.save_song_rating_to_file_request)
}
inline ::cpb::tagreader::SaveSongRatingToFileRequest* Message::release_save_song_rating_to_file_request() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::cpb::tagreader::SaveSongRatingToFileRequest* temp = _impl_.save_song_rating_to_file_request_;
  _impl_.save_song_rating_to_file_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SaveSongRatingToFileRequest* Message::unsafe_arena_release_save_song_rating_to_file_request() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.save_song_rating_to_file_request)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::cpb::tagreader::SaveSongRatingToFileRequest* temp = _impl_.save_song_rating_to_file_request_;
  _impl_.save_song_rating_to_file_request_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SaveSongRatingToFileRequest* Message::_internal_mutable_save_song_rating_to_file_request() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.save_song_rating_to_file_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SaveSongRatingToFileRequest>(GetArenaForAllocation());
    _impl_.save_song_rating_to_file_request_ = p;
  }
  return _impl_.save_song_rating_to_file_request_;
}
inline ::cpb::tagreader::SaveSongRatingToFileRequest* Message::mutable_save_song_rating_to_file_request() {
  ::cpb::tagreader::SaveSongRatingToFileRequest* _msg = _internal_mutable_save_song_rating_to_file_request();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.save_song_rating_to_file_request)
  return _msg;
}
inline void Message::set_allocated_save_song_rating_to_file_request(::cpb::tagreader::SaveSongRatingToFileRequest* save_song_rating_to_file_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_song_rating_to_file_request_;
  }
  if (save_song_rating_to_file_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_song_rating_to_file_request);
    if (message_arena != submessage_arena) {
      save_song_rating_to_file_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_song_rating_to_file_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.save_song_rating_to_file_request_ = save_song_rating_to_file_request;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.save_song_rating_to_file_request)
}

// optional .cpb.tagreader.SaveSongRatingToFileResponse save_song_rating_to_file_response = 15;
inline bool Message::_internal_has_save_song_rating_to_file_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.save_song_rating_to_file_response_ != nullptr);
  return value;
}
inline bool Message::has_save_song_rating_to_file_response() const {
  return _internal_has_save_song_rating_to_file_response();
}
inline void Message::clear_save_song_rating_to_file_response() {
  if (_impl_.save_song_rating_to_file_response_ != nullptr) _impl_.save_song_rating_to_file_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::cpb::tagreader::SaveSongRatingToFileResponse& Message::_internal_save_song_rating_to_file_response() const {
  const ::cpb::tagreader::SaveSongRatingToFileResponse* p = _impl_.save_song_rating_to_file_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::tagreader::SaveSongRatingToFileResponse&>(
      ::cpb::tagreader::_SaveSongRatingToFileResponse_default_instance_);
}
inline const ::cpb::tagreader::SaveSongRatingToFileResponse& Message::save_song_rating_to_file_response() const {
  // @@protoc_insertion_point(field_get:cpb.tagreader.Message.save_song_rating_to_file_response)
  return _internal_save_song_rating_to_file_response();
}
inline void Message::unsafe_arena_set_allocated_save_song_rating_to_file_response(
    ::cpb::tagreader::SaveSongRatingToFileResponse* save_song_rating_to_file_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_song_rating_to_file_response_);
  }
  _impl_.save_song_rating_to_file_response_ = save_song_rating_to_file_response;
  if (save_song_rating_to_file_response) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.tagreader.Message.save_song_rating_to_file_response)
}
inline ::cpb::tagreader::SaveSongRatingToFileResponse* Message::release_save_song_rating_to_file_response() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::cpb::tagreader::SaveSongRatingToFileResponse* temp = _impl_.save_song_rating_to_file_response_;
  _impl_.save_song_rating_to_file_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::tagreader::SaveSongRatingToFileResponse* Message::unsafe_arena_release_save_song_rating_to_file_response() {
  // @@protoc_insertion_point(field_release:cpb.tagreader.Message.save_song_rating_to_file_response)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::cpb::tagreader::SaveSongRatingToFileResponse* temp = _impl_.save_song_rating_to_file_response_;
  _impl_.save_song_rating_to_file_response_ = nullptr;
  return temp;
}
inline ::cpb::tagreader::SaveSongRatingToFileResponse* Message::_internal_mutable_save_song_rating_to_file_response() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.save_song_rating_to_file_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::tagreader::SaveSongRatingToFileResponse>(GetArenaForAllocation());
    _impl_.save_song_rating_to_file_response_ = p;
  }
  return _impl_.save_song_rating_to_file_response_;
}
inline ::cpb::tagreader::SaveSongRatingToFileResponse* Message::mutable_save_song_rating_to_file_response() {
  ::cpb::tagreader::SaveSongRatingToFileResponse* _msg = _internal_mutable_save_song_rating_to_file_response();
  // @@protoc_insertion_point(field_mutable:cpb.tagreader.Message.save_song_rating_to_file_response)
  return _msg;
}
inline void Message::set_allocated_save_song_rating_to_file_response(::cpb::tagreader::SaveSongRatingToFileResponse* save_song_rating_to_file_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_song_rating_to_file_response_;
  }
  if (save_song_rating_to_file_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_song_rating_to_file_response);
    if (message_arena != submessage_arena) {
      save_song_rating_to_file_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_song_rating_to_file_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.save_song_rating_to_file_response_ = save_song_rating_to_file_response;
  // @@protoc_insertion_point(field_set_allocated:cpb.tagreader.Message.save_song_rating_to_file_response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tagreader
}  // namespace cpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cpb::tagreader::SongMetadata_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::tagreader::SongMetadata_Type>() {
  return ::cpb::tagreader::SongMetadata_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tagreadermessages_2eproto
