// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remotecontrolmessages.proto

#include "remotecontrolmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace cpb {
namespace remote {
PROTOBUF_CONSTEXPR SongMetadata::SongMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.album_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.artist_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.albumartist_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pretty_year_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.genre_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pretty_length_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.art_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.art_automatic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.art_manual_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_.track_)*/0
  , /*decltype(_impl_.disc_)*/0
  , /*decltype(_impl_.playcount_)*/0
  , /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.is_local_)*/false
  , /*decltype(_impl_.file_size_)*/0
  , /*decltype(_impl_.rating_)*/0
  , /*decltype(_impl_.type_)*/0} {}
struct SongMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SongMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SongMetadataDefaultTypeInternal() {}
  union {
    SongMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SongMetadataDefaultTypeInternal _SongMetadata_default_instance_;
PROTOBUF_CONSTEXPR Playlist::Playlist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.item_count_)*/0
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.closed_)*/false
  , /*decltype(_impl_.favorite_)*/false} {}
struct PlaylistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlaylistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlaylistDefaultTypeInternal() {}
  union {
    Playlist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlaylistDefaultTypeInternal _Playlist_default_instance_;
PROTOBUF_CONSTEXPR RequestPlaylists::RequestPlaylists(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.include_closed_)*/false} {}
struct RequestPlaylistsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestPlaylistsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestPlaylistsDefaultTypeInternal() {}
  union {
    RequestPlaylists _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestPlaylistsDefaultTypeInternal _RequestPlaylists_default_instance_;
PROTOBUF_CONSTEXPR RequestPlaylistSongs::RequestPlaylistSongs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/0} {}
struct RequestPlaylistSongsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestPlaylistSongsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestPlaylistSongsDefaultTypeInternal() {}
  union {
    RequestPlaylistSongs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestPlaylistSongsDefaultTypeInternal _RequestPlaylistSongs_default_instance_;
PROTOBUF_CONSTEXPR RequestChangeSong::RequestChangeSong(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playlist_id_)*/0
  , /*decltype(_impl_.song_index_)*/0} {}
struct RequestChangeSongDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestChangeSongDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestChangeSongDefaultTypeInternal() {}
  union {
    RequestChangeSong _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestChangeSongDefaultTypeInternal _RequestChangeSong_default_instance_;
PROTOBUF_CONSTEXPR RequestSetVolume::RequestSetVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.volume_)*/0} {}
struct RequestSetVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestSetVolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestSetVolumeDefaultTypeInternal() {}
  union {
    RequestSetVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestSetVolumeDefaultTypeInternal _RequestSetVolume_default_instance_;
PROTOBUF_CONSTEXPR Repeat::Repeat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.repeat_mode_)*/0} {}
struct RepeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepeatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepeatDefaultTypeInternal() {}
  union {
    Repeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepeatDefaultTypeInternal _Repeat_default_instance_;
PROTOBUF_CONSTEXPR Shuffle::Shuffle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shuffle_mode_)*/0} {}
struct ShuffleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShuffleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShuffleDefaultTypeInternal() {}
  union {
    Shuffle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShuffleDefaultTypeInternal _Shuffle_default_instance_;
PROTOBUF_CONSTEXPR ResponseClementineInfo::ResponseClementineInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.files_music_extensions_)*/{}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.allow_downloads_)*/false} {}
struct ResponseClementineInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseClementineInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseClementineInfoDefaultTypeInternal() {}
  union {
    ResponseClementineInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseClementineInfoDefaultTypeInternal _ResponseClementineInfo_default_instance_;
PROTOBUF_CONSTEXPR ResponseCurrentMetadata::ResponseCurrentMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.song_metadata_)*/nullptr} {}
struct ResponseCurrentMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseCurrentMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseCurrentMetadataDefaultTypeInternal() {}
  union {
    ResponseCurrentMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseCurrentMetadataDefaultTypeInternal _ResponseCurrentMetadata_default_instance_;
PROTOBUF_CONSTEXPR ResponsePlaylists::ResponsePlaylists(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playlist_)*/{}
  , /*decltype(_impl_.include_closed_)*/false} {}
struct ResponsePlaylistsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponsePlaylistsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponsePlaylistsDefaultTypeInternal() {}
  union {
    ResponsePlaylists _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponsePlaylistsDefaultTypeInternal _ResponsePlaylists_default_instance_;
PROTOBUF_CONSTEXPR ResponsePlaylistSongs::ResponsePlaylistSongs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.songs_)*/{}
  , /*decltype(_impl_.requested_playlist_)*/nullptr} {}
struct ResponsePlaylistSongsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponsePlaylistSongsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponsePlaylistSongsDefaultTypeInternal() {}
  union {
    ResponsePlaylistSongs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponsePlaylistSongsDefaultTypeInternal _ResponsePlaylistSongs_default_instance_;
PROTOBUF_CONSTEXPR ResponseEngineStateChanged::ResponseEngineStateChanged(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/0} {}
struct ResponseEngineStateChangedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseEngineStateChangedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseEngineStateChangedDefaultTypeInternal() {}
  union {
    ResponseEngineStateChanged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseEngineStateChangedDefaultTypeInternal _ResponseEngineStateChanged_default_instance_;
PROTOBUF_CONSTEXPR ResponseUpdateTrackPosition::ResponseUpdateTrackPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/0} {}
struct ResponseUpdateTrackPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseUpdateTrackPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseUpdateTrackPositionDefaultTypeInternal() {}
  union {
    ResponseUpdateTrackPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseUpdateTrackPositionDefaultTypeInternal _ResponseUpdateTrackPosition_default_instance_;
PROTOBUF_CONSTEXPR RequestConnect::RequestConnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.auth_code_)*/0
  , /*decltype(_impl_.send_playlist_songs_)*/false
  , /*decltype(_impl_.downloader_)*/false} {}
struct RequestConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestConnectDefaultTypeInternal() {}
  union {
    RequestConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestConnectDefaultTypeInternal _RequestConnect_default_instance_;
PROTOBUF_CONSTEXPR ResponseDisconnect::ResponseDisconnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_disconnect_)*/1} {}
struct ResponseDisconnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDisconnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDisconnectDefaultTypeInternal() {}
  union {
    ResponseDisconnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDisconnectDefaultTypeInternal _ResponseDisconnect_default_instance_;
PROTOBUF_CONSTEXPR ResponseActiveChanged::ResponseActiveChanged(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/0} {}
struct ResponseActiveChangedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseActiveChangedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseActiveChangedDefaultTypeInternal() {}
  union {
    ResponseActiveChanged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseActiveChangedDefaultTypeInternal _ResponseActiveChanged_default_instance_;
PROTOBUF_CONSTEXPR RequestSetTrackPosition::RequestSetTrackPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/0} {}
struct RequestSetTrackPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestSetTrackPositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestSetTrackPositionDefaultTypeInternal() {}
  union {
    RequestSetTrackPosition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestSetTrackPositionDefaultTypeInternal _RequestSetTrackPosition_default_instance_;
PROTOBUF_CONSTEXPR RequestInsertUrls::RequestInsertUrls(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.urls_)*/{}
  , /*decltype(_impl_.songs_)*/{}
  , /*decltype(_impl_.new_playlist_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.playlist_id_)*/0
  , /*decltype(_impl_.play_now_)*/false
  , /*decltype(_impl_.enqueue_)*/false
  , /*decltype(_impl_.position_)*/-1} {}
struct RequestInsertUrlsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestInsertUrlsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestInsertUrlsDefaultTypeInternal() {}
  union {
    RequestInsertUrls _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestInsertUrlsDefaultTypeInternal _RequestInsertUrls_default_instance_;
PROTOBUF_CONSTEXPR RequestRemoveSongs::RequestRemoveSongs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.songs_)*/{}
  , /*decltype(_impl_.playlist_id_)*/0} {}
struct RequestRemoveSongsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestRemoveSongsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestRemoveSongsDefaultTypeInternal() {}
  union {
    RequestRemoveSongs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestRemoveSongsDefaultTypeInternal _RequestRemoveSongs_default_instance_;
PROTOBUF_CONSTEXPR RequestOpenPlaylist::RequestOpenPlaylist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playlist_id_)*/0} {}
struct RequestOpenPlaylistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestOpenPlaylistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestOpenPlaylistDefaultTypeInternal() {}
  union {
    RequestOpenPlaylist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestOpenPlaylistDefaultTypeInternal _RequestOpenPlaylist_default_instance_;
PROTOBUF_CONSTEXPR RequestClosePlaylist::RequestClosePlaylist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playlist_id_)*/0} {}
struct RequestClosePlaylistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestClosePlaylistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestClosePlaylistDefaultTypeInternal() {}
  union {
    RequestClosePlaylist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestClosePlaylistDefaultTypeInternal _RequestClosePlaylist_default_instance_;
PROTOBUF_CONSTEXPR RequestUpdatePlaylist::RequestUpdatePlaylist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_playlist_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.playlist_id_)*/0
  , /*decltype(_impl_.favorite_)*/false
  , /*decltype(_impl_.create_new_playlist_)*/false
  , /*decltype(_impl_.clear_playlist_)*/false} {}
struct RequestUpdatePlaylistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestUpdatePlaylistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestUpdatePlaylistDefaultTypeInternal() {}
  union {
    RequestUpdatePlaylist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestUpdatePlaylistDefaultTypeInternal _RequestUpdatePlaylist_default_instance_;
PROTOBUF_CONSTEXPR ResponseLyrics::ResponseLyrics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lyrics_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseLyricsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseLyricsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseLyricsDefaultTypeInternal() {}
  union {
    ResponseLyrics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseLyricsDefaultTypeInternal _ResponseLyrics_default_instance_;
PROTOBUF_CONSTEXPR Lyric::Lyric(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LyricDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LyricDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LyricDefaultTypeInternal() {}
  union {
    Lyric _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LyricDefaultTypeInternal _Lyric_default_instance_;
PROTOBUF_CONSTEXPR RequestDownloadSongs::RequestDownloadSongs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.urls_)*/{}
  , /*decltype(_impl_.songs_ids_)*/{}
  , /*decltype(_impl_.relative_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.playlist_id_)*/0
  , /*decltype(_impl_.download_item_)*/1} {}
struct RequestDownloadSongsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestDownloadSongsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestDownloadSongsDefaultTypeInternal() {}
  union {
    RequestDownloadSongs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestDownloadSongsDefaultTypeInternal _RequestDownloadSongs_default_instance_;
PROTOBUF_CONSTEXPR ResponseSongFileChunk::ResponseSongFileChunk(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.song_metadata_)*/nullptr
  , /*decltype(_impl_.chunk_number_)*/0
  , /*decltype(_impl_.chunk_count_)*/0
  , /*decltype(_impl_.file_number_)*/0
  , /*decltype(_impl_.file_count_)*/0
  , /*decltype(_impl_.size_)*/0} {}
struct ResponseSongFileChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseSongFileChunkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseSongFileChunkDefaultTypeInternal() {}
  union {
    ResponseSongFileChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseSongFileChunkDefaultTypeInternal _ResponseSongFileChunk_default_instance_;
PROTOBUF_CONSTEXPR ResponseLibraryChunk::ResponseLibraryChunk(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.file_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chunk_number_)*/0
  , /*decltype(_impl_.chunk_count_)*/0
  , /*decltype(_impl_.size_)*/0} {}
struct ResponseLibraryChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseLibraryChunkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseLibraryChunkDefaultTypeInternal() {}
  union {
    ResponseLibraryChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseLibraryChunkDefaultTypeInternal _ResponseLibraryChunk_default_instance_;
PROTOBUF_CONSTEXPR ResponseSongOffer::ResponseSongOffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.accepted_)*/false} {}
struct ResponseSongOfferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseSongOfferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseSongOfferDefaultTypeInternal() {}
  union {
    ResponseSongOffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseSongOfferDefaultTypeInternal _ResponseSongOffer_default_instance_;
PROTOBUF_CONSTEXPR RequestRateSong::RequestRateSong(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rating_)*/0} {}
struct RequestRateSongDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestRateSongDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestRateSongDefaultTypeInternal() {}
  union {
    RequestRateSong _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestRateSongDefaultTypeInternal _RequestRateSong_default_instance_;
PROTOBUF_CONSTEXPR ResponseDownloadTotalSize::ResponseDownloadTotalSize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.total_size_)*/0
  , /*decltype(_impl_.file_count_)*/0} {}
struct ResponseDownloadTotalSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDownloadTotalSizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDownloadTotalSizeDefaultTypeInternal() {}
  union {
    ResponseDownloadTotalSize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDownloadTotalSizeDefaultTypeInternal _ResponseDownloadTotalSize_default_instance_;
PROTOBUF_CONSTEXPR RequestGlobalSearch::RequestGlobalSearch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.query_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RequestGlobalSearchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestGlobalSearchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestGlobalSearchDefaultTypeInternal() {}
  union {
    RequestGlobalSearch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestGlobalSearchDefaultTypeInternal _RequestGlobalSearch_default_instance_;
PROTOBUF_CONSTEXPR ResponseGlobalSearch::ResponseGlobalSearch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.song_metadata_)*/{}
  , /*decltype(_impl_.query_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.search_provider_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.search_provider_icon_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0} {}
struct ResponseGlobalSearchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseGlobalSearchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseGlobalSearchDefaultTypeInternal() {}
  union {
    ResponseGlobalSearch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseGlobalSearchDefaultTypeInternal _ResponseGlobalSearch_default_instance_;
PROTOBUF_CONSTEXPR ResponseTranscoderStatus::ResponseTranscoderStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.processed_)*/0
  , /*decltype(_impl_.total_)*/0} {}
struct ResponseTranscoderStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseTranscoderStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseTranscoderStatusDefaultTypeInternal() {}
  union {
    ResponseTranscoderStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseTranscoderStatusDefaultTypeInternal _ResponseTranscoderStatus_default_instance_;
PROTOBUF_CONSTEXPR ResponseGlobalSearchStatus::ResponseGlobalSearchStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.query_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.status_)*/1} {}
struct ResponseGlobalSearchStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseGlobalSearchStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseGlobalSearchStatusDefaultTypeInternal() {}
  union {
    ResponseGlobalSearchStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseGlobalSearchStatusDefaultTypeInternal _ResponseGlobalSearchStatus_default_instance_;
PROTOBUF_CONSTEXPR RequestListFiles::RequestListFiles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.relative_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RequestListFilesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestListFilesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestListFilesDefaultTypeInternal() {}
  union {
    RequestListFiles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestListFilesDefaultTypeInternal _RequestListFiles_default_instance_;
PROTOBUF_CONSTEXPR FileMetadata::FileMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_dir_)*/false} {}
struct FileMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileMetadataDefaultTypeInternal() {}
  union {
    FileMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileMetadataDefaultTypeInternal _FileMetadata_default_instance_;
PROTOBUF_CONSTEXPR ResponseListFiles::ResponseListFiles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.files_)*/{}
  , /*decltype(_impl_.relative_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/0} {}
struct ResponseListFilesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseListFilesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseListFilesDefaultTypeInternal() {}
  union {
    ResponseListFiles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseListFilesDefaultTypeInternal _ResponseListFiles_default_instance_;
PROTOBUF_CONSTEXPR RequestAppendFiles::RequestAppendFiles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.files_)*/{}
  , /*decltype(_impl_.new_playlist_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relative_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.playlist_id_)*/0
  , /*decltype(_impl_.play_now_)*/false
  , /*decltype(_impl_.clear_first_)*/false} {}
struct RequestAppendFilesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestAppendFilesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestAppendFilesDefaultTypeInternal() {}
  union {
    RequestAppendFiles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestAppendFilesDefaultTypeInternal _RequestAppendFiles_default_instance_;
PROTOBUF_CONSTEXPR Stream::Stream(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_logo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct StreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamDefaultTypeInternal() {}
  union {
    Stream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamDefaultTypeInternal _Stream_default_instance_;
PROTOBUF_CONSTEXPR ResponseSavedRadios::ResponseSavedRadios(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.streams_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseSavedRadiosDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseSavedRadiosDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseSavedRadiosDefaultTypeInternal() {}
  union {
    ResponseSavedRadios _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseSavedRadiosDefaultTypeInternal _ResponseSavedRadios_default_instance_;
PROTOBUF_CONSTEXPR Message::Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.request_playlist_songs_)*/nullptr
  , /*decltype(_impl_.request_change_song_)*/nullptr
  , /*decltype(_impl_.request_set_volume_)*/nullptr
  , /*decltype(_impl_.repeat_)*/nullptr
  , /*decltype(_impl_.shuffle_)*/nullptr
  , /*decltype(_impl_.response_clementine_info_)*/nullptr
  , /*decltype(_impl_.response_current_metadata_)*/nullptr
  , /*decltype(_impl_.response_playlists_)*/nullptr
  , /*decltype(_impl_.response_playlist_songs_)*/nullptr
  , /*decltype(_impl_.response_engine_state_changed_)*/nullptr
  , /*decltype(_impl_.response_update_track_position_)*/nullptr
  , /*decltype(_impl_.request_connect_)*/nullptr
  , /*decltype(_impl_.response_disconnect_)*/nullptr
  , /*decltype(_impl_.request_set_track_position_)*/nullptr
  , /*decltype(_impl_.response_active_changed_)*/nullptr
  , /*decltype(_impl_.request_insert_urls_)*/nullptr
  , /*decltype(_impl_.request_remove_songs_)*/nullptr
  , /*decltype(_impl_.request_playlists_)*/nullptr
  , /*decltype(_impl_.request_open_playlist_)*/nullptr
  , /*decltype(_impl_.request_close_playlist_)*/nullptr
  , /*decltype(_impl_.response_lyrics_)*/nullptr
  , /*decltype(_impl_.request_download_songs_)*/nullptr
  , /*decltype(_impl_.response_song_file_chunk_)*/nullptr
  , /*decltype(_impl_.response_song_offer_)*/nullptr
  , /*decltype(_impl_.response_library_chunk_)*/nullptr
  , /*decltype(_impl_.request_rate_song_)*/nullptr
  , /*decltype(_impl_.response_download_total_size_)*/nullptr
  , /*decltype(_impl_.request_global_search_)*/nullptr
  , /*decltype(_impl_.response_global_search_)*/nullptr
  , /*decltype(_impl_.response_transcoder_status_)*/nullptr
  , /*decltype(_impl_.response_global_search_status_)*/nullptr
  , /*decltype(_impl_.request_list_files_)*/nullptr
  , /*decltype(_impl_.request_append_files_)*/nullptr
  , /*decltype(_impl_.response_list_files_)*/nullptr
  , /*decltype(_impl_.request_update_playlist_)*/nullptr
  , /*decltype(_impl_.response_saved_radios_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.version_)*/21} {}
struct MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageDefaultTypeInternal _Message_default_instance_;
}  // namespace remote
}  // namespace cpb
static ::_pb::Metadata file_level_metadata_remotecontrolmessages_2eproto[42];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_remotecontrolmessages_2eproto[9];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_remotecontrolmessages_2eproto = nullptr;

const uint32_t TableStruct_remotecontrolmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.album_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.artist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.albumartist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.disc_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.pretty_year_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.genre_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.playcount_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.pretty_length_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.art_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.is_local_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.file_size_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.rating_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.art_automatic_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.art_manual_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::SongMetadata, _impl_.type_),
  12,
  13,
  0,
  1,
  2,
  3,
  14,
  15,
  4,
  5,
  16,
  6,
  7,
  17,
  18,
  8,
  19,
  20,
  9,
  10,
  11,
  21,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_.item_count_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_.closed_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Playlist, _impl_.favorite_),
  1,
  0,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestPlaylists, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestPlaylists, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestPlaylists, _impl_.include_closed_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestPlaylistSongs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestPlaylistSongs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestPlaylistSongs, _impl_.id_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestChangeSong, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestChangeSong, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestChangeSong, _impl_.playlist_id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestChangeSong, _impl_.song_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestSetVolume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestSetVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestSetVolume, _impl_.volume_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Repeat, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Repeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Repeat, _impl_.repeat_mode_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Shuffle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Shuffle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Shuffle, _impl_.shuffle_mode_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseClementineInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseClementineInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseClementineInfo, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseClementineInfo, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseClementineInfo, _impl_.allow_downloads_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseClementineInfo, _impl_.files_music_extensions_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseCurrentMetadata, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseCurrentMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseCurrentMetadata, _impl_.song_metadata_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylists, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylists, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylists, _impl_.playlist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylists, _impl_.include_closed_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylistSongs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylistSongs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylistSongs, _impl_.requested_playlist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponsePlaylistSongs, _impl_.songs_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseEngineStateChanged, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseEngineStateChanged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseEngineStateChanged, _impl_.state_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseUpdateTrackPosition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseUpdateTrackPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseUpdateTrackPosition, _impl_.position_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestConnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestConnect, _impl_.auth_code_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestConnect, _impl_.send_playlist_songs_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestConnect, _impl_.downloader_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDisconnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDisconnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDisconnect, _impl_.reason_disconnect_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseActiveChanged, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseActiveChanged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseActiveChanged, _impl_.id_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestSetTrackPosition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestSetTrackPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestSetTrackPosition, _impl_.position_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.playlist_id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.urls_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.play_now_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.enqueue_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.songs_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestInsertUrls, _impl_.new_playlist_name_),
  1,
  ~0u,
  4,
  2,
  3,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRemoveSongs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRemoveSongs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRemoveSongs, _impl_.playlist_id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRemoveSongs, _impl_.songs_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestOpenPlaylist, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestOpenPlaylist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestOpenPlaylist, _impl_.playlist_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestClosePlaylist, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestClosePlaylist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestClosePlaylist, _impl_.playlist_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _impl_.playlist_id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _impl_.new_playlist_name_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _impl_.favorite_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _impl_.create_new_playlist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestUpdatePlaylist, _impl_.clear_playlist_),
  1,
  0,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLyrics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLyrics, _impl_.lyrics_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Lyric, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Lyric, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Lyric, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Lyric, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Lyric, _impl_.content_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _impl_.download_item_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _impl_.playlist_id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _impl_.urls_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _impl_.songs_ids_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestDownloadSongs, _impl_.relative_path_),
  2,
  1,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.chunk_number_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.chunk_count_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.file_number_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.file_count_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.song_metadata_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongFileChunk, _impl_.file_hash_),
  3,
  4,
  5,
  6,
  2,
  0,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _impl_.chunk_number_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _impl_.chunk_count_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseLibraryChunk, _impl_.file_hash_),
  2,
  3,
  0,
  4,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongOffer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongOffer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSongOffer, _impl_.accepted_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRateSong, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRateSong, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestRateSong, _impl_.rating_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDownloadTotalSize, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDownloadTotalSize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDownloadTotalSize, _impl_.total_size_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseDownloadTotalSize, _impl_.file_count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestGlobalSearch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestGlobalSearch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestGlobalSearch, _impl_.query_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _impl_.query_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _impl_.search_provider_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _impl_.song_metadata_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearch, _impl_.search_provider_icon_),
  3,
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseTranscoderStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseTranscoderStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseTranscoderStatus, _impl_.processed_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseTranscoderStatus, _impl_.total_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearchStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearchStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearchStatus, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearchStatus, _impl_.query_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseGlobalSearchStatus, _impl_.status_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestListFiles, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestListFiles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestListFiles, _impl_.relative_path_),
  0,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::FileMetadata, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::FileMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::FileMetadata, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::FileMetadata, _impl_.is_dir_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseListFiles, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseListFiles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseListFiles, _impl_.relative_path_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseListFiles, _impl_.files_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseListFiles, _impl_.error_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_.playlist_id_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_.new_playlist_name_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_.relative_path_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_.files_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_.play_now_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::RequestAppendFiles, _impl_.clear_first_),
  2,
  0,
  1,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Stream, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Stream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Stream, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Stream, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Stream, _impl_.url_logo_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSavedRadios, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::ResponseSavedRadios, _impl_.streams_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_connect_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_playlists_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_playlist_songs_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_change_song_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_set_volume_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_set_track_position_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_insert_urls_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_remove_songs_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_open_playlist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_close_playlist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_update_playlist_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_download_songs_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_rate_song_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_global_search_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_list_files_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.request_append_files_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.repeat_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.shuffle_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_clementine_info_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_current_metadata_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_playlists_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_playlist_songs_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_engine_state_changed_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_update_track_position_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_disconnect_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_active_changed_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_lyrics_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_song_file_chunk_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_song_offer_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_library_chunk_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_download_total_size_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_global_search_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_transcoder_status_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_global_search_status_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_list_files_),
  PROTOBUF_FIELD_OFFSET(::cpb::remote::Message, _impl_.response_saved_radios_),
  37,
  36,
  11,
  17,
  0,
  1,
  2,
  13,
  15,
  16,
  18,
  19,
  34,
  21,
  25,
  27,
  31,
  32,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  12,
  14,
  20,
  22,
  23,
  24,
  26,
  28,
  29,
  30,
  33,
  35,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 28, -1, sizeof(::cpb::remote::SongMetadata)},
  { 50, 62, -1, sizeof(::cpb::remote::Playlist)},
  { 68, 75, -1, sizeof(::cpb::remote::RequestPlaylists)},
  { 76, 83, -1, sizeof(::cpb::remote::RequestPlaylistSongs)},
  { 84, 92, -1, sizeof(::cpb::remote::RequestChangeSong)},
  { 94, 101, -1, sizeof(::cpb::remote::RequestSetVolume)},
  { 102, 109, -1, sizeof(::cpb::remote::Repeat)},
  { 110, 117, -1, sizeof(::cpb::remote::Shuffle)},
  { 118, 128, -1, sizeof(::cpb::remote::ResponseClementineInfo)},
  { 132, 139, -1, sizeof(::cpb::remote::ResponseCurrentMetadata)},
  { 140, 148, -1, sizeof(::cpb::remote::ResponsePlaylists)},
  { 150, 158, -1, sizeof(::cpb::remote::ResponsePlaylistSongs)},
  { 160, 167, -1, sizeof(::cpb::remote::ResponseEngineStateChanged)},
  { 168, 175, -1, sizeof(::cpb::remote::ResponseUpdateTrackPosition)},
  { 176, 185, -1, sizeof(::cpb::remote::RequestConnect)},
  { 188, 195, -1, sizeof(::cpb::remote::ResponseDisconnect)},
  { 196, 203, -1, sizeof(::cpb::remote::ResponseActiveChanged)},
  { 204, 211, -1, sizeof(::cpb::remote::RequestSetTrackPosition)},
  { 212, 225, -1, sizeof(::cpb::remote::RequestInsertUrls)},
  { 232, 240, -1, sizeof(::cpb::remote::RequestRemoveSongs)},
  { 242, 249, -1, sizeof(::cpb::remote::RequestOpenPlaylist)},
  { 250, 257, -1, sizeof(::cpb::remote::RequestClosePlaylist)},
  { 258, 269, -1, sizeof(::cpb::remote::RequestUpdatePlaylist)},
  { 274, -1, -1, sizeof(::cpb::remote::ResponseLyrics)},
  { 281, 290, -1, sizeof(::cpb::remote::Lyric)},
  { 293, 304, -1, sizeof(::cpb::remote::RequestDownloadSongs)},
  { 309, 323, -1, sizeof(::cpb::remote::ResponseSongFileChunk)},
  { 331, 342, -1, sizeof(::cpb::remote::ResponseLibraryChunk)},
  { 347, 354, -1, sizeof(::cpb::remote::ResponseSongOffer)},
  { 355, 362, -1, sizeof(::cpb::remote::RequestRateSong)},
  { 363, 371, -1, sizeof(::cpb::remote::ResponseDownloadTotalSize)},
  { 373, 380, -1, sizeof(::cpb::remote::RequestGlobalSearch)},
  { 381, 392, -1, sizeof(::cpb::remote::ResponseGlobalSearch)},
  { 397, 405, -1, sizeof(::cpb::remote::ResponseTranscoderStatus)},
  { 407, 416, -1, sizeof(::cpb::remote::ResponseGlobalSearchStatus)},
  { 419, 426, -1, sizeof(::cpb::remote::RequestListFiles)},
  { 427, 435, -1, sizeof(::cpb::remote::FileMetadata)},
  { 437, 446, -1, sizeof(::cpb::remote::ResponseListFiles)},
  { 449, 461, -1, sizeof(::cpb::remote::RequestAppendFiles)},
  { 467, 476, -1, sizeof(::cpb::remote::Stream)},
  { 479, -1, -1, sizeof(::cpb::remote::ResponseSavedRadios)},
  { 486, 530, -1, sizeof(::cpb::remote::Message)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::cpb::remote::_SongMetadata_default_instance_._instance,
  &::cpb::remote::_Playlist_default_instance_._instance,
  &::cpb::remote::_RequestPlaylists_default_instance_._instance,
  &::cpb::remote::_RequestPlaylistSongs_default_instance_._instance,
  &::cpb::remote::_RequestChangeSong_default_instance_._instance,
  &::cpb::remote::_RequestSetVolume_default_instance_._instance,
  &::cpb::remote::_Repeat_default_instance_._instance,
  &::cpb::remote::_Shuffle_default_instance_._instance,
  &::cpb::remote::_ResponseClementineInfo_default_instance_._instance,
  &::cpb::remote::_ResponseCurrentMetadata_default_instance_._instance,
  &::cpb::remote::_ResponsePlaylists_default_instance_._instance,
  &::cpb::remote::_ResponsePlaylistSongs_default_instance_._instance,
  &::cpb::remote::_ResponseEngineStateChanged_default_instance_._instance,
  &::cpb::remote::_ResponseUpdateTrackPosition_default_instance_._instance,
  &::cpb::remote::_RequestConnect_default_instance_._instance,
  &::cpb::remote::_ResponseDisconnect_default_instance_._instance,
  &::cpb::remote::_ResponseActiveChanged_default_instance_._instance,
  &::cpb::remote::_RequestSetTrackPosition_default_instance_._instance,
  &::cpb::remote::_RequestInsertUrls_default_instance_._instance,
  &::cpb::remote::_RequestRemoveSongs_default_instance_._instance,
  &::cpb::remote::_RequestOpenPlaylist_default_instance_._instance,
  &::cpb::remote::_RequestClosePlaylist_default_instance_._instance,
  &::cpb::remote::_RequestUpdatePlaylist_default_instance_._instance,
  &::cpb::remote::_ResponseLyrics_default_instance_._instance,
  &::cpb::remote::_Lyric_default_instance_._instance,
  &::cpb::remote::_RequestDownloadSongs_default_instance_._instance,
  &::cpb::remote::_ResponseSongFileChunk_default_instance_._instance,
  &::cpb::remote::_ResponseLibraryChunk_default_instance_._instance,
  &::cpb::remote::_ResponseSongOffer_default_instance_._instance,
  &::cpb::remote::_RequestRateSong_default_instance_._instance,
  &::cpb::remote::_ResponseDownloadTotalSize_default_instance_._instance,
  &::cpb::remote::_RequestGlobalSearch_default_instance_._instance,
  &::cpb::remote::_ResponseGlobalSearch_default_instance_._instance,
  &::cpb::remote::_ResponseTranscoderStatus_default_instance_._instance,
  &::cpb::remote::_ResponseGlobalSearchStatus_default_instance_._instance,
  &::cpb::remote::_RequestListFiles_default_instance_._instance,
  &::cpb::remote::_FileMetadata_default_instance_._instance,
  &::cpb::remote::_ResponseListFiles_default_instance_._instance,
  &::cpb::remote::_RequestAppendFiles_default_instance_._instance,
  &::cpb::remote::_Stream_default_instance_._instance,
  &::cpb::remote::_ResponseSavedRadios_default_instance_._instance,
  &::cpb::remote::_Message_default_instance_._instance,
};

const char descriptor_table_protodef_remotecontrolmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033remotecontrolmessages.proto\022\ncpb.remot"
  "e\"\205\005\n\014SongMetadata\022\n\n\002id\030\001 \001(\005\022\r\n\005index\030"
  "\002 \001(\005\022\r\n\005title\030\003 \001(\t\022\r\n\005album\030\004 \001(\t\022\016\n\006a"
  "rtist\030\005 \001(\t\022\023\n\013albumartist\030\006 \001(\t\022\r\n\005trac"
  "k\030\007 \001(\005\022\014\n\004disc\030\010 \001(\005\022\023\n\013pretty_year\030\t \001"
  "(\t\022\r\n\005genre\030\n \001(\t\022\021\n\tplaycount\030\013 \001(\005\022\025\n\r"
  "pretty_length\030\014 \001(\t\022\013\n\003art\030\r \001(\014\022\016\n\006leng"
  "th\030\016 \001(\005\022\020\n\010is_local\030\017 \001(\010\022\020\n\010filename\030\020"
  " \001(\t\022\021\n\tfile_size\030\021 \001(\005\022\016\n\006rating\030\022 \001(\002\022"
  "\013\n\003url\030\023 \001(\t\022\025\n\rart_automatic\030\024 \001(\t\022\022\n\na"
  "rt_manual\030\025 \001(\t\022+\n\004type\030\026 \001(\0162\035.cpb.remo"
  "te.SongMetadata.Type\"\342\001\n\004Type\022\013\n\007UNKNOWN"
  "\020\000\022\007\n\003ASF\020\001\022\010\n\004FLAC\020\002\022\007\n\003MP4\020\003\022\007\n\003MPC\020\004\022"
  "\010\n\004MPEG\020\005\022\013\n\007OGGFLAC\020\006\022\014\n\010OGGSPEEX\020\007\022\r\n\t"
  "OGGVORBIS\020\010\022\010\n\004AIFF\020\t\022\007\n\003WAV\020\n\022\r\n\tTRUEAU"
  "DIO\020\013\022\010\n\004CDDA\020\014\022\013\n\007OGGOPUS\020\r\022\013\n\007WAVPACK\020"
  "\016\022\007\n\003SPC\020\017\022\007\n\003VGM\020\020\022\007\n\003APE\020\021\022\007\n\003DSF\020\022\022\n\n"
  "\006STREAM\020c\"j\n\010Playlist\022\n\n\002id\030\001 \001(\005\022\014\n\004nam"
  "e\030\002 \001(\t\022\022\n\nitem_count\030\003 \001(\005\022\016\n\006active\030\004 "
  "\001(\010\022\016\n\006closed\030\005 \001(\010\022\020\n\010favorite\030\006 \001(\010\"*\n"
  "\020RequestPlaylists\022\026\n\016include_closed\030\001 \001("
  "\010\"\"\n\024RequestPlaylistSongs\022\n\n\002id\030\001 \001(\005\"<\n"
  "\021RequestChangeSong\022\023\n\013playlist_id\030\001 \001(\005\022"
  "\022\n\nsong_index\030\002 \001(\005\"\"\n\020RequestSetVolume\022"
  "\016\n\006volume\030\001 \001(\005\"5\n\006Repeat\022+\n\013repeat_mode"
  "\030\001 \001(\0162\026.cpb.remote.RepeatMode\"8\n\007Shuffl"
  "e\022-\n\014shuffle_mode\030\001 \001(\0162\027.cpb.remote.Shu"
  "ffleMode\"\212\001\n\026ResponseClementineInfo\022\017\n\007v"
  "ersion\030\001 \001(\t\022&\n\005state\030\002 \001(\0162\027.cpb.remote"
  ".EngineState\022\027\n\017allow_downloads\030\003 \001(\010\022\036\n"
  "\026files_music_extensions\030\004 \003(\t\"J\n\027Respons"
  "eCurrentMetadata\022/\n\rsong_metadata\030\001 \001(\0132"
  "\030.cpb.remote.SongMetadata\"S\n\021ResponsePla"
  "ylists\022&\n\010playlist\030\001 \003(\0132\024.cpb.remote.Pl"
  "aylist\022\026\n\016include_closed\030\002 \001(\010\"r\n\025Respon"
  "sePlaylistSongs\0220\n\022requested_playlist\030\001 "
  "\001(\0132\024.cpb.remote.Playlist\022\'\n\005songs\030\002 \003(\013"
  "2\030.cpb.remote.SongMetadata\"D\n\032ResponseEn"
  "gineStateChanged\022&\n\005state\030\001 \001(\0162\027.cpb.re"
  "mote.EngineState\"/\n\033ResponseUpdateTrackP"
  "osition\022\020\n\010position\030\001 \001(\005\"T\n\016RequestConn"
  "ect\022\021\n\tauth_code\030\001 \001(\005\022\033\n\023send_playlist_"
  "songs\030\002 \001(\010\022\022\n\ndownloader\030\003 \001(\010\"M\n\022Respo"
  "nseDisconnect\0227\n\021reason_disconnect\030\001 \001(\016"
  "2\034.cpb.remote.ReasonDisconnect\"#\n\025Respon"
  "seActiveChanged\022\n\n\002id\030\001 \001(\005\"+\n\027RequestSe"
  "tTrackPosition\022\020\n\010position\030\001 \001(\005\"\301\001\n\021Req"
  "uestInsertUrls\022\023\n\013playlist_id\030\001 \001(\005\022\014\n\004u"
  "rls\030\002 \003(\t\022\024\n\010position\030\003 \001(\005:\002-1\022\027\n\010play_"
  "now\030\004 \001(\010:\005false\022\026\n\007enqueue\030\005 \001(\010:\005false"
  "\022\'\n\005songs\030\006 \003(\0132\030.cpb.remote.SongMetadat"
  "a\022\031\n\021new_playlist_name\030\007 \001(\t\"8\n\022RequestR"
  "emoveSongs\022\023\n\013playlist_id\030\001 \001(\005\022\r\n\005songs"
  "\030\002 \003(\005\"*\n\023RequestOpenPlaylist\022\023\n\013playlis"
  "t_id\030\001 \001(\005\"+\n\024RequestClosePlaylist\022\023\n\013pl"
  "aylist_id\030\001 \001(\005\"\216\001\n\025RequestUpdatePlaylis"
  "t\022\023\n\013playlist_id\030\001 \001(\005\022\031\n\021new_playlist_n"
  "ame\030\002 \001(\t\022\020\n\010favorite\030\003 \001(\010\022\033\n\023create_ne"
  "w_playlist\030\004 \001(\010\022\026\n\016clear_playlist\030\005 \001(\010"
  "\"3\n\016ResponseLyrics\022!\n\006lyrics\030\001 \003(\0132\021.cpb"
  ".remote.Lyric\"3\n\005Lyric\022\n\n\002id\030\001 \001(\t\022\r\n\005ti"
  "tle\030\002 \001(\t\022\017\n\007content\030\003 \001(\t\"\224\001\n\024RequestDo"
  "wnloadSongs\022/\n\rdownload_item\030\001 \001(\0162\030.cpb"
  ".remote.DownloadItem\022\023\n\013playlist_id\030\002 \001("
  "\005\022\014\n\004urls\030\003 \003(\t\022\021\n\tsongs_ids\030\004 \003(\005\022\025\n\rre"
  "lative_path\030\005 \001(\t\"\313\001\n\025ResponseSongFileCh"
  "unk\022\024\n\014chunk_number\030\001 \001(\005\022\023\n\013chunk_count"
  "\030\002 \001(\005\022\023\n\013file_number\030\003 \001(\005\022\022\n\nfile_coun"
  "t\030\004 \001(\005\022/\n\rsong_metadata\030\006 \001(\0132\030.cpb.rem"
  "ote.SongMetadata\022\014\n\004data\030\007 \001(\014\022\014\n\004size\030\010"
  " \001(\005\022\021\n\tfile_hash\030\t \001(\014\"p\n\024ResponseLibra"
  "ryChunk\022\024\n\014chunk_number\030\001 \001(\005\022\023\n\013chunk_c"
  "ount\030\002 \001(\005\022\014\n\004data\030\003 \001(\014\022\014\n\004size\030\004 \001(\005\022\021"
  "\n\tfile_hash\030\005 \001(\014\"%\n\021ResponseSongOffer\022\020"
  "\n\010accepted\030\001 \001(\010\"!\n\017RequestRateSong\022\016\n\006r"
  "ating\030\001 \001(\002\"C\n\031ResponseDownloadTotalSize"
  "\022\022\n\ntotal_size\030\001 \001(\005\022\022\n\nfile_count\030\002 \001(\005"
  "\"$\n\023RequestGlobalSearch\022\r\n\005query\030\001 \001(\t\"\231"
  "\001\n\024ResponseGlobalSearch\022\n\n\002id\030\001 \001(\005\022\r\n\005q"
  "uery\030\002 \001(\t\022\027\n\017search_provider\030\003 \001(\t\022/\n\rs"
  "ong_metadata\030\004 \003(\0132\030.cpb.remote.SongMeta"
  "data\022\034\n\024search_provider_icon\030\005 \001(\014\"<\n\030Re"
  "sponseTranscoderStatus\022\021\n\tprocessed\030\001 \001("
  "\005\022\r\n\005total\030\002 \001(\005\"g\n\032ResponseGlobalSearch"
  "Status\022\n\n\002id\030\001 \001(\005\022\r\n\005query\030\002 \001(\t\022.\n\006sta"
  "tus\030\003 \001(\0162\036.cpb.remote.GlobalSearchStatu"
  "s\")\n\020RequestListFiles\022\025\n\rrelative_path\030\001"
  " \001(\t\"0\n\014FileMetadata\022\020\n\010filename\030\001 \001(\t\022\016"
  "\n\006is_dir\030\002 \001(\010\"\350\001\n\021ResponseListFiles\022\025\n\r"
  "relative_path\030\001 \001(\t\022\'\n\005files\030\002 \003(\0132\030.cpb"
  ".remote.FileMetadata\0222\n\005error\030\003 \001(\0162#.cp"
  "b.remote.ResponseListFiles.Error\"_\n\005Erro"
  "r\022\010\n\004NONE\020\000\022\024\n\020ROOT_DIR_NOT_SET\020\001\022\026\n\022DIR"
  "_NOT_ACCESSIBLE\020\002\022\021\n\rDIR_NOT_EXIST\020\003\022\013\n\007"
  "UNKNOWN\020\004\"\221\001\n\022RequestAppendFiles\022\023\n\013play"
  "list_id\030\001 \001(\005\022\031\n\021new_playlist_name\030\002 \001(\t"
  "\022\025\n\rrelative_path\030\003 \001(\t\022\r\n\005files\030\004 \003(\t\022\020"
  "\n\010play_now\030\005 \001(\010\022\023\n\013clear_first\030\006 \001(\010\"5\n"
  "\006Stream\022\014\n\004name\030\001 \001(\t\022\013\n\003url\030\002 \001(\t\022\020\n\010ur"
  "l_logo\030\003 \001(\t\":\n\023ResponseSavedRadios\022#\n\007s"
  "treams\030\001 \003(\0132\022.cpb.remote.Stream\"\277\022\n\007Mes"
  "sage\022\023\n\007version\030\001 \001(\005:\00221\022*\n\004type\030\002 \001(\0162"
  "\023.cpb.remote.MsgType:\007UNKNOWN\0223\n\017request"
  "_connect\030\025 \001(\0132\032.cpb.remote.RequestConne"
  "ct\0227\n\021request_playlists\030\033 \001(\0132\034.cpb.remo"
  "te.RequestPlaylists\022@\n\026request_playlist_"
  "songs\030\n \001(\0132 .cpb.remote.RequestPlaylist"
  "Songs\022:\n\023request_change_song\030\013 \001(\0132\035.cpb"
  ".remote.RequestChangeSong\0228\n\022request_set"
  "_volume\030\014 \001(\0132\034.cpb.remote.RequestSetVol"
  "ume\022G\n\032request_set_track_position\030\027 \001(\0132"
  "#.cpb.remote.RequestSetTrackPosition\022:\n\023"
  "request_insert_urls\030\031 \001(\0132\035.cpb.remote.R"
  "equestInsertUrls\022<\n\024request_remove_songs"
  "\030\032 \001(\0132\036.cpb.remote.RequestRemoveSongs\022>"
  "\n\025request_open_playlist\030\034 \001(\0132\037.cpb.remo"
  "te.RequestOpenPlaylist\022@\n\026request_close_"
  "playlist\030\035 \001(\0132 .cpb.remote.RequestClose"
  "Playlist\022B\n\027request_update_playlist\0305 \001("
  "\0132!.cpb.remote.RequestUpdatePlaylist\022@\n\026"
  "request_download_songs\030\037 \001(\0132 .cpb.remot"
  "e.RequestDownloadSongs\0226\n\021request_rate_s"
  "ong\030# \001(\0132\033.cpb.remote.RequestRateSong\022>"
  "\n\025request_global_search\030% \001(\0132\037.cpb.remo"
  "te.RequestGlobalSearch\0228\n\022request_list_f"
  "iles\0302 \001(\0132\034.cpb.remote.RequestListFiles"
  "\022<\n\024request_append_files\0303 \001(\0132\036.cpb.rem"
  "ote.RequestAppendFiles\022\"\n\006repeat\030\r \001(\0132\022"
  ".cpb.remote.Repeat\022$\n\007shuffle\030\016 \001(\0132\023.cp"
  "b.remote.Shuffle\022D\n\030response_clementine_"
  "info\030\017 \001(\0132\".cpb.remote.ResponseClementi"
  "neInfo\022F\n\031response_current_metadata\030\020 \001("
  "\0132#.cpb.remote.ResponseCurrentMetadata\0229"
  "\n\022response_playlists\030\021 \001(\0132\035.cpb.remote."
  "ResponsePlaylists\022B\n\027response_playlist_s"
  "ongs\030\022 \001(\0132!.cpb.remote.ResponsePlaylist"
  "Songs\022M\n\035response_engine_state_changed\030\023"
  " \001(\0132&.cpb.remote.ResponseEngineStateCha"
  "nged\022O\n\036response_update_track_position\030\024"
  " \001(\0132\'.cpb.remote.ResponseUpdateTrackPos"
  "ition\022;\n\023response_disconnect\030\026 \001(\0132\036.cpb"
  ".remote.ResponseDisconnect\022B\n\027response_a"
  "ctive_changed\030\030 \001(\0132!.cpb.remote.Respons"
  "eActiveChanged\0223\n\017response_lyrics\030\036 \001(\0132"
  "\032.cpb.remote.ResponseLyrics\022C\n\030response_"
  "song_file_chunk\030  \001(\0132!.cpb.remote.Respo"
  "nseSongFileChunk\022:\n\023response_song_offer\030"
  "! \001(\0132\035.cpb.remote.ResponseSongOffer\022@\n\026"
  "response_library_chunk\030\" \001(\0132 .cpb.remot"
  "e.ResponseLibraryChunk\022K\n\034response_downl"
  "oad_total_size\030$ \001(\0132%.cpb.remote.Respon"
  "seDownloadTotalSize\022@\n\026response_global_s"
  "earch\030& \001(\0132 .cpb.remote.ResponseGlobalS"
  "earch\022H\n\032response_transcoder_status\030\' \001("
  "\0132$.cpb.remote.ResponseTranscoderStatus\022"
  "M\n\035response_global_search_status\030( \001(\0132&"
  ".cpb.remote.ResponseGlobalSearchStatus\022:"
  "\n\023response_list_files\0304 \001(\0132\035.cpb.remote"
  ".ResponseListFiles\022>\n\025response_saved_rad"
  "ios\0306 \001(\0132\037.cpb.remote.ResponseSavedRadi"
  "os*\315\007\n\007MsgType\022\013\n\007UNKNOWN\020\000\022\013\n\007CONNECT\020\001"
  "\022\025\n\021REQUEST_PLAYLISTS\020\003\022\032\n\026REQUEST_PLAYL"
  "IST_SONGS\020\004\022\017\n\013CHANGE_SONG\020\005\022\016\n\nSET_VOLU"
  "ME\020\006\022\026\n\022SET_TRACK_POSITION\020\007\022\017\n\013INSERT_U"
  "RLS\020\010\022\020\n\014REMOVE_SONGS\020\t\022\021\n\rOPEN_PLAYLIST"
  "\020\n\022\022\n\016CLOSE_PLAYLIST\020\013\022\023\n\017UPDATE_PLAYLIS"
  "T\020<\022\016\n\nGET_LYRICS\020\016\022\022\n\016DOWNLOAD_SONGS\020\017\022"
  "\027\n\023SONG_OFFER_RESPONSE\020\020\022\010\n\004LOVE\020\014\022\007\n\003BA"
  "N\020\r\022\016\n\nSTOP_AFTER\020\021\022\017\n\013GET_LIBRARY\020\022\022\r\n\t"
  "RATE_SONG\020\023\022\021\n\rGLOBAL_SEARCH\020d\022\030\n\024REQUES"
  "T_SAVED_RADIOS\020n\022\022\n\rREQUEST_FILES\020\310\001\022\021\n\014"
  "APPEND_FILES\020\311\001\022\016\n\nDISCONNECT\020\002\022\010\n\004PLAY\020"
  "\024\022\r\n\tPLAYPAUSE\020\025\022\t\n\005PAUSE\020\026\022\010\n\004STOP\020\027\022\010\n"
  "\004NEXT\020\030\022\014\n\010PREVIOUS\020\031\022\024\n\020SHUFFLE_PLAYLIS"
  "T\020\032\022\n\n\006REPEAT\020\033\022\013\n\007SHUFFLE\020\034\022\010\n\004INFO\020(\022\024"
  "\n\020CURRENT_METAINFO\020)\022\r\n\tPLAYLISTS\020*\022\022\n\016P"
  "LAYLIST_SONGS\020+\022\030\n\024ENGINE_STATE_CHANGED\020"
  ",\022\016\n\nKEEP_ALIVE\020-\022\031\n\025UPDATE_TRACK_POSITI"
  "ON\020.\022\033\n\027ACTIVE_PLAYLIST_CHANGED\020/\022\034\n\030FIR"
  "ST_DATA_SENT_COMPLETE\0200\022\n\n\006LYRICS\0201\022\023\n\017S"
  "ONG_FILE_CHUNK\0202\022\030\n\024DOWNLOAD_QUEUE_EMPTY"
  "\0203\022\021\n\rLIBRARY_CHUNK\0204\022\027\n\023DOWNLOAD_TOTAL_"
  "SIZE\0205\022\030\n\024GLOBAL_SEARCH_RESULT\0206\022\025\n\021TRAN"
  "SCODING_FILES\0207\022\030\n\024GLOBAL_SEARCH_STATUS\020"
  "8\022\017\n\nLIST_FILES\020\312\001*;\n\013EngineState\022\t\n\005Emp"
  "ty\020\000\022\010\n\004Idle\020\001\022\013\n\007Playing\020\002\022\n\n\006Paused\020\003*"
  "|\n\nRepeatMode\022\016\n\nRepeat_Off\020\000\022\020\n\014Repeat_"
  "Track\020\001\022\020\n\014Repeat_Album\020\002\022\023\n\017Repeat_Play"
  "list\020\003\022\023\n\017Repeat_OneByOne\020\004\022\020\n\014Repeat_In"
  "tro\020\005*\\\n\013ShuffleMode\022\017\n\013Shuffle_Off\020\000\022\017\n"
  "\013Shuffle_All\020\001\022\027\n\023Shuffle_InsideAlbum\020\002\022"
  "\022\n\016Shuffle_Albums\020\003*k\n\020ReasonDisconnect\022"
  "\023\n\017Server_Shutdown\020\001\022\023\n\017Wrong_Auth_Code\020"
  "\002\022\025\n\021Not_Authenticated\020\003\022\026\n\022Download_For"
  "bidden\020\004*G\n\014DownloadItem\022\017\n\013CurrentItem\020"
  "\001\022\r\n\tItemAlbum\020\002\022\r\n\tAPlaylist\020\003\022\010\n\004Urls\020"
  "\004*G\n\022GlobalSearchStatus\022\027\n\023GlobalSearchS"
  "tarted\020\001\022\030\n\024GlobalSearchFinished\020\002"
  ;
static ::_pbi::once_flag descriptor_table_remotecontrolmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_remotecontrolmessages_2eproto = {
    false, false, 7914, descriptor_table_protodef_remotecontrolmessages_2eproto,
    "remotecontrolmessages.proto",
    &descriptor_table_remotecontrolmessages_2eproto_once, nullptr, 0, 42,
    schemas, file_default_instances, TableStruct_remotecontrolmessages_2eproto::offsets,
    file_level_metadata_remotecontrolmessages_2eproto, file_level_enum_descriptors_remotecontrolmessages_2eproto,
    file_level_service_descriptors_remotecontrolmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_remotecontrolmessages_2eproto_getter() {
  return &descriptor_table_remotecontrolmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_remotecontrolmessages_2eproto(&descriptor_table_remotecontrolmessages_2eproto);
namespace cpb {
namespace remote {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SongMetadata_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[0];
}
bool SongMetadata_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 99:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SongMetadata_Type SongMetadata::UNKNOWN;
constexpr SongMetadata_Type SongMetadata::ASF;
constexpr SongMetadata_Type SongMetadata::FLAC;
constexpr SongMetadata_Type SongMetadata::MP4;
constexpr SongMetadata_Type SongMetadata::MPC;
constexpr SongMetadata_Type SongMetadata::MPEG;
constexpr SongMetadata_Type SongMetadata::OGGFLAC;
constexpr SongMetadata_Type SongMetadata::OGGSPEEX;
constexpr SongMetadata_Type SongMetadata::OGGVORBIS;
constexpr SongMetadata_Type SongMetadata::AIFF;
constexpr SongMetadata_Type SongMetadata::WAV;
constexpr SongMetadata_Type SongMetadata::TRUEAUDIO;
constexpr SongMetadata_Type SongMetadata::CDDA;
constexpr SongMetadata_Type SongMetadata::OGGOPUS;
constexpr SongMetadata_Type SongMetadata::WAVPACK;
constexpr SongMetadata_Type SongMetadata::SPC;
constexpr SongMetadata_Type SongMetadata::VGM;
constexpr SongMetadata_Type SongMetadata::APE;
constexpr SongMetadata_Type SongMetadata::DSF;
constexpr SongMetadata_Type SongMetadata::STREAM;
constexpr SongMetadata_Type SongMetadata::Type_MIN;
constexpr SongMetadata_Type SongMetadata::Type_MAX;
constexpr int SongMetadata::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseListFiles_Error_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[1];
}
bool ResponseListFiles_Error_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ResponseListFiles_Error ResponseListFiles::NONE;
constexpr ResponseListFiles_Error ResponseListFiles::ROOT_DIR_NOT_SET;
constexpr ResponseListFiles_Error ResponseListFiles::DIR_NOT_ACCESSIBLE;
constexpr ResponseListFiles_Error ResponseListFiles::DIR_NOT_EXIST;
constexpr ResponseListFiles_Error ResponseListFiles::UNKNOWN;
constexpr ResponseListFiles_Error ResponseListFiles::Error_MIN;
constexpr ResponseListFiles_Error ResponseListFiles::Error_MAX;
constexpr int ResponseListFiles::Error_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[2];
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 60:
    case 100:
    case 110:
    case 200:
    case 201:
    case 202:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EngineState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[3];
}
bool EngineState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RepeatMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[4];
}
bool RepeatMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShuffleMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[5];
}
bool ShuffleMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReasonDisconnect_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[6];
}
bool ReasonDisconnect_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadItem_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[7];
}
bool DownloadItem_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlobalSearchStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_remotecontrolmessages_2eproto);
  return file_level_enum_descriptors_remotecontrolmessages_2eproto[8];
}
bool GlobalSearchStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SongMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<SongMetadata>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_album(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_artist(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_albumartist(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_track(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_disc(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_pretty_year(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_genre(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_playcount(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_pretty_length(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_art(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_local(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_file_size(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_art_automatic(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_art_manual(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

SongMetadata::SongMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.SongMetadata)
}
SongMetadata::SongMetadata(const SongMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SongMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.album_){}
    , decltype(_impl_.artist_){}
    , decltype(_impl_.albumartist_){}
    , decltype(_impl_.pretty_year_){}
    , decltype(_impl_.genre_){}
    , decltype(_impl_.pretty_length_){}
    , decltype(_impl_.art_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.art_automatic_){}
    , decltype(_impl_.art_manual_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.track_){}
    , decltype(_impl_.disc_){}
    , decltype(_impl_.playcount_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.is_local_){}
    , decltype(_impl_.file_size_){}
    , decltype(_impl_.rating_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.album_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.album_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_album()) {
    _this->_impl_.album_.Set(from._internal_album(), 
      _this->GetArenaForAllocation());
  }
  _impl_.artist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artist()) {
    _this->_impl_.artist_.Set(from._internal_artist(), 
      _this->GetArenaForAllocation());
  }
  _impl_.albumartist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_albumartist()) {
    _this->_impl_.albumartist_.Set(from._internal_albumartist(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pretty_year_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pretty_year_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pretty_year()) {
    _this->_impl_.pretty_year_.Set(from._internal_pretty_year(), 
      _this->GetArenaForAllocation());
  }
  _impl_.genre_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.genre_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_genre()) {
    _this->_impl_.genre_.Set(from._internal_genre(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pretty_length_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pretty_length_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pretty_length()) {
    _this->_impl_.pretty_length_.Set(from._internal_pretty_length(), 
      _this->GetArenaForAllocation());
  }
  _impl_.art_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_art()) {
    _this->_impl_.art_.Set(from._internal_art(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.art_automatic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_art_automatic()) {
    _this->_impl_.art_automatic_.Set(from._internal_art_automatic(), 
      _this->GetArenaForAllocation());
  }
  _impl_.art_manual_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_manual_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_art_manual()) {
    _this->_impl_.art_manual_.Set(from._internal_art_manual(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.SongMetadata)
}

inline void SongMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.album_){}
    , decltype(_impl_.artist_){}
    , decltype(_impl_.albumartist_){}
    , decltype(_impl_.pretty_year_){}
    , decltype(_impl_.genre_){}
    , decltype(_impl_.pretty_length_){}
    , decltype(_impl_.art_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.art_automatic_){}
    , decltype(_impl_.art_manual_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.index_){0}
    , decltype(_impl_.track_){0}
    , decltype(_impl_.disc_){0}
    , decltype(_impl_.playcount_){0}
    , decltype(_impl_.length_){0}
    , decltype(_impl_.is_local_){false}
    , decltype(_impl_.file_size_){0}
    , decltype(_impl_.rating_){0}
    , decltype(_impl_.type_){0}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.album_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.album_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.artist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.albumartist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pretty_year_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pretty_year_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.genre_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.genre_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pretty_length_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pretty_length_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.art_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.art_automatic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.art_manual_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_manual_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SongMetadata::~SongMetadata() {
  // @@protoc_insertion_point(destructor:cpb.remote.SongMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SongMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
  _impl_.album_.Destroy();
  _impl_.artist_.Destroy();
  _impl_.albumartist_.Destroy();
  _impl_.pretty_year_.Destroy();
  _impl_.genre_.Destroy();
  _impl_.pretty_length_.Destroy();
  _impl_.art_.Destroy();
  _impl_.filename_.Destroy();
  _impl_.url_.Destroy();
  _impl_.art_automatic_.Destroy();
  _impl_.art_manual_.Destroy();
}

void SongMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SongMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.SongMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.album_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.artist_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.albumartist_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.pretty_year_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.genre_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.pretty_length_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.art_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.art_automatic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.art_manual_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.disc_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.disc_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.playcount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.playcount_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SongMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string album = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_album();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.album");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string artist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_artist();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.artist");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string albumartist = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_albumartist();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.albumartist");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 track = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_track(&has_bits);
          _impl_.track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 disc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_disc(&has_bits);
          _impl_.disc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pretty_year = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_pretty_year();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.pretty_year");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string genre = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_genre();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.genre");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 playcount = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_playcount(&has_bits);
          _impl_.playcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pretty_length = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_pretty_length();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.pretty_length");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bytes art = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_art();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 length = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_local = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_local(&has_bits);
          _impl_.is_local_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filename = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 file_size = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_file_size(&has_bits);
          _impl_.file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float rating = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_rating(&has_bits);
          _impl_.rating_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string art_automatic = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_art_automatic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.art_automatic");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string art_manual = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_art_manual();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.SongMetadata.art_manual");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.SongMetadata.Type type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::SongMetadata_Type_IsValid(val))) {
            _internal_set_type(static_cast<::cpb::remote::SongMetadata_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SongMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.SongMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional int32 index = 2;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_index(), target);
  }

  // optional string title = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // optional string album = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_album().data(), static_cast<int>(this->_internal_album().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.album");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_album(), target);
  }

  // optional string artist = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_artist().data(), static_cast<int>(this->_internal_artist().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.artist");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_artist(), target);
  }

  // optional string albumartist = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_albumartist().data(), static_cast<int>(this->_internal_albumartist().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.albumartist");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_albumartist(), target);
  }

  // optional int32 track = 7;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_track(), target);
  }

  // optional int32 disc = 8;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_disc(), target);
  }

  // optional string pretty_year = 9;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pretty_year().data(), static_cast<int>(this->_internal_pretty_year().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.pretty_year");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_pretty_year(), target);
  }

  // optional string genre = 10;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_genre().data(), static_cast<int>(this->_internal_genre().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.genre");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_genre(), target);
  }

  // optional int32 playcount = 11;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_playcount(), target);
  }

  // optional string pretty_length = 12;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pretty_length().data(), static_cast<int>(this->_internal_pretty_length().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.pretty_length");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_pretty_length(), target);
  }

  // optional bytes art = 13;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_art(), target);
  }

  // optional int32 length = 14;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_length(), target);
  }

  // optional bool is_local = 15;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_local(), target);
  }

  // optional string filename = 16;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.filename");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_filename(), target);
  }

  // optional int32 file_size = 17;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_file_size(), target);
  }

  // optional float rating = 18;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_rating(), target);
  }

  // optional string url = 19;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.url");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_url(), target);
  }

  // optional string art_automatic = 20;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_art_automatic().data(), static_cast<int>(this->_internal_art_automatic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.art_automatic");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_art_automatic(), target);
  }

  // optional string art_manual = 21;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_art_manual().data(), static_cast<int>(this->_internal_art_manual().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.SongMetadata.art_manual");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_art_manual(), target);
  }

  // optional .cpb.remote.SongMetadata.Type type = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.SongMetadata)
  return target;
}

size_t SongMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.SongMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string title = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string album = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_album());
    }

    // optional string artist = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_artist());
    }

    // optional string albumartist = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_albumartist());
    }

    // optional string pretty_year = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pretty_year());
    }

    // optional string genre = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_genre());
    }

    // optional string pretty_length = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pretty_length());
    }

    // optional bytes art = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_art());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string filename = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional string url = 19;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string art_automatic = 20;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_art_automatic());
    }

    // optional string art_manual = 21;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_art_manual());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // optional int32 index = 2;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
    }

    // optional int32 track = 7;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_track());
    }

    // optional int32 disc = 8;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_disc());
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional int32 playcount = 11;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playcount());
    }

    // optional int32 length = 14;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_length());
    }

    // optional bool is_local = 15;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional int32 file_size = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_file_size());
    }

    // optional float rating = 18;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional .cpb.remote.SongMetadata.Type type = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SongMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SongMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SongMetadata::GetClassData() const { return &_class_data_; }


void SongMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SongMetadata*>(&to_msg);
  auto& from = static_cast<const SongMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.SongMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_album(from._internal_album());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_artist(from._internal_artist());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_albumartist(from._internal_albumartist());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_pretty_year(from._internal_pretty_year());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_genre(from._internal_genre());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_pretty_length(from._internal_pretty_length());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_art(from._internal_art());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_art_automatic(from._internal_art_automatic());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_art_manual(from._internal_art_manual());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.track_ = from._impl_.track_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.disc_ = from._impl_.disc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.playcount_ = from._impl_.playcount_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.is_local_ = from._impl_.is_local_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.file_size_ = from._impl_.file_size_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.rating_ = from._impl_.rating_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SongMetadata::CopyFrom(const SongMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.SongMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SongMetadata::IsInitialized() const {
  return true;
}

void SongMetadata::InternalSwap(SongMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.album_, lhs_arena,
      &other->_impl_.album_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.artist_, lhs_arena,
      &other->_impl_.artist_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.albumartist_, lhs_arena,
      &other->_impl_.albumartist_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pretty_year_, lhs_arena,
      &other->_impl_.pretty_year_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.genre_, lhs_arena,
      &other->_impl_.genre_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pretty_length_, lhs_arena,
      &other->_impl_.pretty_length_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.art_, lhs_arena,
      &other->_impl_.art_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.art_automatic_, lhs_arena,
      &other->_impl_.art_automatic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.art_manual_, lhs_arena,
      &other->_impl_.art_manual_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SongMetadata, _impl_.type_)
      + sizeof(SongMetadata::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SongMetadata, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SongMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[0]);
}

// ===================================================================

class Playlist::_Internal {
 public:
  using HasBits = decltype(std::declval<Playlist>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_item_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_closed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_favorite(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Playlist::Playlist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.Playlist)
}
Playlist::Playlist(const Playlist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Playlist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.item_count_){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.closed_){}
    , decltype(_impl_.favorite_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.favorite_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.favorite_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.Playlist)
}

inline void Playlist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.item_count_){0}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.closed_){false}
    , decltype(_impl_.favorite_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Playlist::~Playlist() {
  // @@protoc_insertion_point(destructor:cpb.remote.Playlist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Playlist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Playlist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Playlist::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.Playlist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.favorite_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.favorite_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Playlist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Playlist.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 item_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_item_count(&has_bits);
          _impl_.item_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool active = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool closed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_closed(&has_bits);
          _impl_.closed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool favorite = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_favorite(&has_bits);
          _impl_.favorite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Playlist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.Playlist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Playlist.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional int32 item_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_item_count(), target);
  }

  // optional bool active = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_active(), target);
  }

  // optional bool closed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_closed(), target);
  }

  // optional bool favorite = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_favorite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.Playlist)
  return target;
}

size_t Playlist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.Playlist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // optional int32 item_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_count());
    }

    // optional bool active = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool closed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool favorite = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Playlist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Playlist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Playlist::GetClassData() const { return &_class_data_; }


void Playlist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Playlist*>(&to_msg);
  auto& from = static_cast<const Playlist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.Playlist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.item_count_ = from._impl_.item_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.closed_ = from._impl_.closed_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.favorite_ = from._impl_.favorite_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Playlist::CopyFrom(const Playlist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.Playlist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Playlist::IsInitialized() const {
  return true;
}

void Playlist::InternalSwap(Playlist* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Playlist, _impl_.favorite_)
      + sizeof(Playlist::_impl_.favorite_)
      - PROTOBUF_FIELD_OFFSET(Playlist, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Playlist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[1]);
}

// ===================================================================

class RequestPlaylists::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestPlaylists>()._impl_._has_bits_);
  static void set_has_include_closed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestPlaylists::RequestPlaylists(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestPlaylists)
}
RequestPlaylists::RequestPlaylists(const RequestPlaylists& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestPlaylists* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.include_closed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.include_closed_ = from._impl_.include_closed_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestPlaylists)
}

inline void RequestPlaylists::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.include_closed_){false}
  };
}

RequestPlaylists::~RequestPlaylists() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestPlaylists)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestPlaylists::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestPlaylists::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestPlaylists::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestPlaylists)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.include_closed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestPlaylists::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool include_closed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_include_closed(&has_bits);
          _impl_.include_closed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestPlaylists::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestPlaylists)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool include_closed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_include_closed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestPlaylists)
  return target;
}

size_t RequestPlaylists::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestPlaylists)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool include_closed = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestPlaylists::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestPlaylists::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestPlaylists::GetClassData() const { return &_class_data_; }


void RequestPlaylists::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestPlaylists*>(&to_msg);
  auto& from = static_cast<const RequestPlaylists&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestPlaylists)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_include_closed()) {
    _this->_internal_set_include_closed(from._internal_include_closed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestPlaylists::CopyFrom(const RequestPlaylists& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestPlaylists)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestPlaylists::IsInitialized() const {
  return true;
}

void RequestPlaylists::InternalSwap(RequestPlaylists* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.include_closed_, other->_impl_.include_closed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestPlaylists::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[2]);
}

// ===================================================================

class RequestPlaylistSongs::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestPlaylistSongs>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestPlaylistSongs::RequestPlaylistSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestPlaylistSongs)
}
RequestPlaylistSongs::RequestPlaylistSongs(const RequestPlaylistSongs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestPlaylistSongs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestPlaylistSongs)
}

inline void RequestPlaylistSongs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){0}
  };
}

RequestPlaylistSongs::~RequestPlaylistSongs() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestPlaylistSongs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestPlaylistSongs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestPlaylistSongs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestPlaylistSongs::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestPlaylistSongs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestPlaylistSongs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestPlaylistSongs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestPlaylistSongs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestPlaylistSongs)
  return target;
}

size_t RequestPlaylistSongs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestPlaylistSongs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestPlaylistSongs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestPlaylistSongs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestPlaylistSongs::GetClassData() const { return &_class_data_; }


void RequestPlaylistSongs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestPlaylistSongs*>(&to_msg);
  auto& from = static_cast<const RequestPlaylistSongs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestPlaylistSongs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestPlaylistSongs::CopyFrom(const RequestPlaylistSongs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestPlaylistSongs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestPlaylistSongs::IsInitialized() const {
  return true;
}

void RequestPlaylistSongs::InternalSwap(RequestPlaylistSongs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestPlaylistSongs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[3]);
}

// ===================================================================

class RequestChangeSong::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestChangeSong>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_song_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RequestChangeSong::RequestChangeSong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestChangeSong)
}
RequestChangeSong::RequestChangeSong(const RequestChangeSong& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestChangeSong* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_id_){}
    , decltype(_impl_.song_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.playlist_id_, &from._impl_.playlist_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.song_index_) -
    reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.song_index_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestChangeSong)
}

inline void RequestChangeSong::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_id_){0}
    , decltype(_impl_.song_index_){0}
  };
}

RequestChangeSong::~RequestChangeSong() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestChangeSong)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestChangeSong::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestChangeSong::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestChangeSong::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestChangeSong)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.playlist_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.song_index_) -
        reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.song_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestChangeSong::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 song_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_song_index(&has_bits);
          _impl_.song_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestChangeSong::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestChangeSong)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  // optional int32 song_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_song_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestChangeSong)
  return target;
}

size_t RequestChangeSong::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestChangeSong)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 playlist_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
    }

    // optional int32 song_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_song_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestChangeSong::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestChangeSong::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestChangeSong::GetClassData() const { return &_class_data_; }


void RequestChangeSong::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestChangeSong*>(&to_msg);
  auto& from = static_cast<const RequestChangeSong&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestChangeSong)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.song_index_ = from._impl_.song_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestChangeSong::CopyFrom(const RequestChangeSong& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestChangeSong)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestChangeSong::IsInitialized() const {
  return true;
}

void RequestChangeSong::InternalSwap(RequestChangeSong* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestChangeSong, _impl_.song_index_)
      + sizeof(RequestChangeSong::_impl_.song_index_)
      - PROTOBUF_FIELD_OFFSET(RequestChangeSong, _impl_.playlist_id_)>(
          reinterpret_cast<char*>(&_impl_.playlist_id_),
          reinterpret_cast<char*>(&other->_impl_.playlist_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestChangeSong::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[4]);
}

// ===================================================================

class RequestSetVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestSetVolume>()._impl_._has_bits_);
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestSetVolume::RequestSetVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestSetVolume)
}
RequestSetVolume::RequestSetVolume(const RequestSetVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestSetVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.volume_ = from._impl_.volume_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestSetVolume)
}

inline void RequestSetVolume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.volume_){0}
  };
}

RequestSetVolume::~RequestSetVolume() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestSetVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestSetVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestSetVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestSetVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestSetVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.volume_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestSetVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 volume = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestSetVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestSetVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 volume = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_volume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestSetVolume)
  return target;
}

size_t RequestSetVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestSetVolume)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 volume = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_volume());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestSetVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestSetVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestSetVolume::GetClassData() const { return &_class_data_; }


void RequestSetVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestSetVolume*>(&to_msg);
  auto& from = static_cast<const RequestSetVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestSetVolume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_volume()) {
    _this->_internal_set_volume(from._internal_volume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestSetVolume::CopyFrom(const RequestSetVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestSetVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSetVolume::IsInitialized() const {
  return true;
}

void RequestSetVolume::InternalSwap(RequestSetVolume* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.volume_, other->_impl_.volume_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestSetVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[5]);
}

// ===================================================================

class Repeat::_Internal {
 public:
  using HasBits = decltype(std::declval<Repeat>()._impl_._has_bits_);
  static void set_has_repeat_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Repeat::Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.Repeat)
}
Repeat::Repeat(const Repeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Repeat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.repeat_mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.repeat_mode_ = from._impl_.repeat_mode_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.Repeat)
}

inline void Repeat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.repeat_mode_){0}
  };
}

Repeat::~Repeat() {
  // @@protoc_insertion_point(destructor:cpb.remote.Repeat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Repeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Repeat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Repeat::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.Repeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.repeat_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Repeat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.RepeatMode repeat_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::RepeatMode_IsValid(val))) {
            _internal_set_repeat_mode(static_cast<::cpb::remote::RepeatMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Repeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.Repeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.RepeatMode repeat_mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_repeat_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.Repeat)
  return target;
}

size_t Repeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.Repeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.remote.RepeatMode repeat_mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_repeat_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Repeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Repeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Repeat::GetClassData() const { return &_class_data_; }


void Repeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Repeat*>(&to_msg);
  auto& from = static_cast<const Repeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.Repeat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_repeat_mode()) {
    _this->_internal_set_repeat_mode(from._internal_repeat_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Repeat::CopyFrom(const Repeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.Repeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Repeat::IsInitialized() const {
  return true;
}

void Repeat::InternalSwap(Repeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.repeat_mode_, other->_impl_.repeat_mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Repeat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[6]);
}

// ===================================================================

class Shuffle::_Internal {
 public:
  using HasBits = decltype(std::declval<Shuffle>()._impl_._has_bits_);
  static void set_has_shuffle_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Shuffle::Shuffle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.Shuffle)
}
Shuffle::Shuffle(const Shuffle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Shuffle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shuffle_mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.shuffle_mode_ = from._impl_.shuffle_mode_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.Shuffle)
}

inline void Shuffle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shuffle_mode_){0}
  };
}

Shuffle::~Shuffle() {
  // @@protoc_insertion_point(destructor:cpb.remote.Shuffle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Shuffle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Shuffle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Shuffle::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.Shuffle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.shuffle_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Shuffle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.ShuffleMode shuffle_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::ShuffleMode_IsValid(val))) {
            _internal_set_shuffle_mode(static_cast<::cpb::remote::ShuffleMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Shuffle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.Shuffle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.ShuffleMode shuffle_mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_shuffle_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.Shuffle)
  return target;
}

size_t Shuffle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.Shuffle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.remote.ShuffleMode shuffle_mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_shuffle_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Shuffle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Shuffle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Shuffle::GetClassData() const { return &_class_data_; }


void Shuffle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Shuffle*>(&to_msg);
  auto& from = static_cast<const Shuffle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.Shuffle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_shuffle_mode()) {
    _this->_internal_set_shuffle_mode(from._internal_shuffle_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Shuffle::CopyFrom(const Shuffle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.Shuffle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Shuffle::IsInitialized() const {
  return true;
}

void Shuffle::InternalSwap(Shuffle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.shuffle_mode_, other->_impl_.shuffle_mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Shuffle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[7]);
}

// ===================================================================

class ResponseClementineInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseClementineInfo>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_allow_downloads(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ResponseClementineInfo::ResponseClementineInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseClementineInfo)
}
ResponseClementineInfo::ResponseClementineInfo(const ResponseClementineInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseClementineInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.files_music_extensions_){from._impl_.files_music_extensions_}
    , decltype(_impl_.version_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.allow_downloads_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.state_, &from._impl_.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allow_downloads_) -
    reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.allow_downloads_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseClementineInfo)
}

inline void ResponseClementineInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.files_music_extensions_){arena}
    , decltype(_impl_.version_){}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.allow_downloads_){false}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseClementineInfo::~ResponseClementineInfo() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseClementineInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseClementineInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.files_music_extensions_.~RepeatedPtrField();
  _impl_.version_.Destroy();
}

void ResponseClementineInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseClementineInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseClementineInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.files_music_extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.allow_downloads_) -
        reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.allow_downloads_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseClementineInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.ResponseClementineInfo.version");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.EngineState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::EngineState_IsValid(val))) {
            _internal_set_state(static_cast<::cpb::remote::EngineState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_downloads = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_allow_downloads(&has_bits);
          _impl_.allow_downloads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string files_music_extensions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_files_music_extensions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "cpb.remote.ResponseClementineInfo.files_music_extensions");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseClementineInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseClementineInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.ResponseClementineInfo.version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // optional .cpb.remote.EngineState state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_state(), target);
  }

  // optional bool allow_downloads = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_downloads(), target);
  }

  // repeated string files_music_extensions = 4;
  for (int i = 0, n = this->_internal_files_music_extensions_size(); i < n; i++) {
    const auto& s = this->_internal_files_music_extensions(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.ResponseClementineInfo.files_music_extensions");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseClementineInfo)
  return target;
}

size_t ResponseClementineInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseClementineInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string files_music_extensions = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.files_music_extensions_.size());
  for (int i = 0, n = _impl_.files_music_extensions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.files_music_extensions_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .cpb.remote.EngineState state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional bool allow_downloads = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseClementineInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseClementineInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseClementineInfo::GetClassData() const { return &_class_data_; }


void ResponseClementineInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseClementineInfo*>(&to_msg);
  auto& from = static_cast<const ResponseClementineInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseClementineInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.files_music_extensions_.MergeFrom(from._impl_.files_music_extensions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.allow_downloads_ = from._impl_.allow_downloads_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseClementineInfo::CopyFrom(const ResponseClementineInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseClementineInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseClementineInfo::IsInitialized() const {
  return true;
}

void ResponseClementineInfo::InternalSwap(ResponseClementineInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.files_music_extensions_.InternalSwap(&other->_impl_.files_music_extensions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResponseClementineInfo, _impl_.allow_downloads_)
      + sizeof(ResponseClementineInfo::_impl_.allow_downloads_)
      - PROTOBUF_FIELD_OFFSET(ResponseClementineInfo, _impl_.state_)>(
          reinterpret_cast<char*>(&_impl_.state_),
          reinterpret_cast<char*>(&other->_impl_.state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseClementineInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[8]);
}

// ===================================================================

class ResponseCurrentMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseCurrentMetadata>()._impl_._has_bits_);
  static const ::cpb::remote::SongMetadata& song_metadata(const ResponseCurrentMetadata* msg);
  static void set_has_song_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cpb::remote::SongMetadata&
ResponseCurrentMetadata::_Internal::song_metadata(const ResponseCurrentMetadata* msg) {
  return *msg->_impl_.song_metadata_;
}
ResponseCurrentMetadata::ResponseCurrentMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseCurrentMetadata)
}
ResponseCurrentMetadata::ResponseCurrentMetadata(const ResponseCurrentMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseCurrentMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.song_metadata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_song_metadata()) {
    _this->_impl_.song_metadata_ = new ::cpb::remote::SongMetadata(*from._impl_.song_metadata_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseCurrentMetadata)
}

inline void ResponseCurrentMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.song_metadata_){nullptr}
  };
}

ResponseCurrentMetadata::~ResponseCurrentMetadata() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseCurrentMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseCurrentMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.song_metadata_;
}

void ResponseCurrentMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseCurrentMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseCurrentMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.song_metadata_ != nullptr);
    _impl_.song_metadata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseCurrentMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.SongMetadata song_metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_song_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseCurrentMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseCurrentMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.SongMetadata song_metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::song_metadata(this),
        _Internal::song_metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseCurrentMetadata)
  return target;
}

size_t ResponseCurrentMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseCurrentMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.remote.SongMetadata song_metadata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.song_metadata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseCurrentMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseCurrentMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseCurrentMetadata::GetClassData() const { return &_class_data_; }


void ResponseCurrentMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseCurrentMetadata*>(&to_msg);
  auto& from = static_cast<const ResponseCurrentMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseCurrentMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_song_metadata()) {
    _this->_internal_mutable_song_metadata()->::cpb::remote::SongMetadata::MergeFrom(
        from._internal_song_metadata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseCurrentMetadata::CopyFrom(const ResponseCurrentMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseCurrentMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseCurrentMetadata::IsInitialized() const {
  return true;
}

void ResponseCurrentMetadata::InternalSwap(ResponseCurrentMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.song_metadata_, other->_impl_.song_metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseCurrentMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[9]);
}

// ===================================================================

class ResponsePlaylists::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponsePlaylists>()._impl_._has_bits_);
  static void set_has_include_closed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResponsePlaylists::ResponsePlaylists(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponsePlaylists)
}
ResponsePlaylists::ResponsePlaylists(const ResponsePlaylists& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponsePlaylists* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_){from._impl_.playlist_}
    , decltype(_impl_.include_closed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.include_closed_ = from._impl_.include_closed_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponsePlaylists)
}

inline void ResponsePlaylists::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_){arena}
    , decltype(_impl_.include_closed_){false}
  };
}

ResponsePlaylists::~ResponsePlaylists() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponsePlaylists)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponsePlaylists::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.playlist_.~RepeatedPtrField();
}

void ResponsePlaylists::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponsePlaylists::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponsePlaylists)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.playlist_.Clear();
  _impl_.include_closed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponsePlaylists::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cpb.remote.Playlist playlist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_playlist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool include_closed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_include_closed(&has_bits);
          _impl_.include_closed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponsePlaylists::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponsePlaylists)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cpb.remote.Playlist playlist = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_playlist_size()); i < n; i++) {
    const auto& repfield = this->_internal_playlist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool include_closed = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_include_closed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponsePlaylists)
  return target;
}

size_t ResponsePlaylists::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponsePlaylists)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cpb.remote.Playlist playlist = 1;
  total_size += 1UL * this->_internal_playlist_size();
  for (const auto& msg : this->_impl_.playlist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool include_closed = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponsePlaylists::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponsePlaylists::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponsePlaylists::GetClassData() const { return &_class_data_; }


void ResponsePlaylists::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponsePlaylists*>(&to_msg);
  auto& from = static_cast<const ResponsePlaylists&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponsePlaylists)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.playlist_.MergeFrom(from._impl_.playlist_);
  if (from._internal_has_include_closed()) {
    _this->_internal_set_include_closed(from._internal_include_closed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponsePlaylists::CopyFrom(const ResponsePlaylists& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponsePlaylists)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponsePlaylists::IsInitialized() const {
  return true;
}

void ResponsePlaylists::InternalSwap(ResponsePlaylists* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.playlist_.InternalSwap(&other->_impl_.playlist_);
  swap(_impl_.include_closed_, other->_impl_.include_closed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponsePlaylists::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[10]);
}

// ===================================================================

class ResponsePlaylistSongs::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponsePlaylistSongs>()._impl_._has_bits_);
  static const ::cpb::remote::Playlist& requested_playlist(const ResponsePlaylistSongs* msg);
  static void set_has_requested_playlist(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::cpb::remote::Playlist&
ResponsePlaylistSongs::_Internal::requested_playlist(const ResponsePlaylistSongs* msg) {
  return *msg->_impl_.requested_playlist_;
}
ResponsePlaylistSongs::ResponsePlaylistSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponsePlaylistSongs)
}
ResponsePlaylistSongs::ResponsePlaylistSongs(const ResponsePlaylistSongs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponsePlaylistSongs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.songs_){from._impl_.songs_}
    , decltype(_impl_.requested_playlist_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_requested_playlist()) {
    _this->_impl_.requested_playlist_ = new ::cpb::remote::Playlist(*from._impl_.requested_playlist_);
  }
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponsePlaylistSongs)
}

inline void ResponsePlaylistSongs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.songs_){arena}
    , decltype(_impl_.requested_playlist_){nullptr}
  };
}

ResponsePlaylistSongs::~ResponsePlaylistSongs() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponsePlaylistSongs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponsePlaylistSongs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.songs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.requested_playlist_;
}

void ResponsePlaylistSongs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponsePlaylistSongs::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponsePlaylistSongs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.songs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.requested_playlist_ != nullptr);
    _impl_.requested_playlist_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponsePlaylistSongs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.Playlist requested_playlist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_requested_playlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .cpb.remote.SongMetadata songs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_songs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponsePlaylistSongs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponsePlaylistSongs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.Playlist requested_playlist = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::requested_playlist(this),
        _Internal::requested_playlist(this).GetCachedSize(), target, stream);
  }

  // repeated .cpb.remote.SongMetadata songs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_songs_size()); i < n; i++) {
    const auto& repfield = this->_internal_songs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponsePlaylistSongs)
  return target;
}

size_t ResponsePlaylistSongs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponsePlaylistSongs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cpb.remote.SongMetadata songs = 2;
  total_size += 1UL * this->_internal_songs_size();
  for (const auto& msg : this->_impl_.songs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .cpb.remote.Playlist requested_playlist = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.requested_playlist_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponsePlaylistSongs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponsePlaylistSongs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponsePlaylistSongs::GetClassData() const { return &_class_data_; }


void ResponsePlaylistSongs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponsePlaylistSongs*>(&to_msg);
  auto& from = static_cast<const ResponsePlaylistSongs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponsePlaylistSongs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.songs_.MergeFrom(from._impl_.songs_);
  if (from._internal_has_requested_playlist()) {
    _this->_internal_mutable_requested_playlist()->::cpb::remote::Playlist::MergeFrom(
        from._internal_requested_playlist());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponsePlaylistSongs::CopyFrom(const ResponsePlaylistSongs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponsePlaylistSongs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponsePlaylistSongs::IsInitialized() const {
  return true;
}

void ResponsePlaylistSongs::InternalSwap(ResponsePlaylistSongs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.songs_.InternalSwap(&other->_impl_.songs_);
  swap(_impl_.requested_playlist_, other->_impl_.requested_playlist_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponsePlaylistSongs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[11]);
}

// ===================================================================

class ResponseEngineStateChanged::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseEngineStateChanged>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResponseEngineStateChanged::ResponseEngineStateChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseEngineStateChanged)
}
ResponseEngineStateChanged::ResponseEngineStateChanged(const ResponseEngineStateChanged& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseEngineStateChanged* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseEngineStateChanged)
}

inline void ResponseEngineStateChanged::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){0}
  };
}

ResponseEngineStateChanged::~ResponseEngineStateChanged() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseEngineStateChanged)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseEngineStateChanged::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseEngineStateChanged::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseEngineStateChanged::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseEngineStateChanged)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseEngineStateChanged::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.EngineState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::EngineState_IsValid(val))) {
            _internal_set_state(static_cast<::cpb::remote::EngineState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseEngineStateChanged::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseEngineStateChanged)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.EngineState state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseEngineStateChanged)
  return target;
}

size_t ResponseEngineStateChanged::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseEngineStateChanged)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.remote.EngineState state = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseEngineStateChanged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseEngineStateChanged::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseEngineStateChanged::GetClassData() const { return &_class_data_; }


void ResponseEngineStateChanged::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseEngineStateChanged*>(&to_msg);
  auto& from = static_cast<const ResponseEngineStateChanged&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseEngineStateChanged)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseEngineStateChanged::CopyFrom(const ResponseEngineStateChanged& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseEngineStateChanged)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseEngineStateChanged::IsInitialized() const {
  return true;
}

void ResponseEngineStateChanged::InternalSwap(ResponseEngineStateChanged* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseEngineStateChanged::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[12]);
}

// ===================================================================

class ResponseUpdateTrackPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseUpdateTrackPosition>()._impl_._has_bits_);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResponseUpdateTrackPosition::ResponseUpdateTrackPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseUpdateTrackPosition)
}
ResponseUpdateTrackPosition::ResponseUpdateTrackPosition(const ResponseUpdateTrackPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseUpdateTrackPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.position_ = from._impl_.position_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseUpdateTrackPosition)
}

inline void ResponseUpdateTrackPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){0}
  };
}

ResponseUpdateTrackPosition::~ResponseUpdateTrackPosition() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseUpdateTrackPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseUpdateTrackPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseUpdateTrackPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseUpdateTrackPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseUpdateTrackPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseUpdateTrackPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseUpdateTrackPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseUpdateTrackPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseUpdateTrackPosition)
  return target;
}

size_t ResponseUpdateTrackPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseUpdateTrackPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_position());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseUpdateTrackPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseUpdateTrackPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseUpdateTrackPosition::GetClassData() const { return &_class_data_; }


void ResponseUpdateTrackPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseUpdateTrackPosition*>(&to_msg);
  auto& from = static_cast<const ResponseUpdateTrackPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseUpdateTrackPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_set_position(from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseUpdateTrackPosition::CopyFrom(const ResponseUpdateTrackPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseUpdateTrackPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUpdateTrackPosition::IsInitialized() const {
  return true;
}

void ResponseUpdateTrackPosition::InternalSwap(ResponseUpdateTrackPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseUpdateTrackPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[13]);
}

// ===================================================================

class RequestConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestConnect>()._impl_._has_bits_);
  static void set_has_auth_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_send_playlist_songs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_downloader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RequestConnect::RequestConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestConnect)
}
RequestConnect::RequestConnect(const RequestConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestConnect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_code_){}
    , decltype(_impl_.send_playlist_songs_){}
    , decltype(_impl_.downloader_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.auth_code_, &from._impl_.auth_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.downloader_) -
    reinterpret_cast<char*>(&_impl_.auth_code_)) + sizeof(_impl_.downloader_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestConnect)
}

inline void RequestConnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.auth_code_){0}
    , decltype(_impl_.send_playlist_songs_){false}
    , decltype(_impl_.downloader_){false}
  };
}

RequestConnect::~RequestConnect() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestConnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestConnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.auth_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.downloader_) -
        reinterpret_cast<char*>(&_impl_.auth_code_)) + sizeof(_impl_.downloader_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestConnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 auth_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_auth_code(&has_bits);
          _impl_.auth_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool send_playlist_songs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_send_playlist_songs(&has_bits);
          _impl_.send_playlist_songs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool downloader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_downloader(&has_bits);
          _impl_.downloader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 auth_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_auth_code(), target);
  }

  // optional bool send_playlist_songs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_send_playlist_songs(), target);
  }

  // optional bool downloader = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_downloader(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestConnect)
  return target;
}

size_t RequestConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestConnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 auth_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_auth_code());
    }

    // optional bool send_playlist_songs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool downloader = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestConnect::GetClassData() const { return &_class_data_; }


void RequestConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestConnect*>(&to_msg);
  auto& from = static_cast<const RequestConnect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestConnect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.auth_code_ = from._impl_.auth_code_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.send_playlist_songs_ = from._impl_.send_playlist_songs_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.downloader_ = from._impl_.downloader_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestConnect::CopyFrom(const RequestConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestConnect::IsInitialized() const {
  return true;
}

void RequestConnect::InternalSwap(RequestConnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestConnect, _impl_.downloader_)
      + sizeof(RequestConnect::_impl_.downloader_)
      - PROTOBUF_FIELD_OFFSET(RequestConnect, _impl_.auth_code_)>(
          reinterpret_cast<char*>(&_impl_.auth_code_),
          reinterpret_cast<char*>(&other->_impl_.auth_code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestConnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[14]);
}

// ===================================================================

class ResponseDisconnect::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseDisconnect>()._impl_._has_bits_);
  static void set_has_reason_disconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResponseDisconnect::ResponseDisconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseDisconnect)
}
ResponseDisconnect::ResponseDisconnect(const ResponseDisconnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseDisconnect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_disconnect_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.reason_disconnect_ = from._impl_.reason_disconnect_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseDisconnect)
}

inline void ResponseDisconnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_disconnect_){1}
  };
}

ResponseDisconnect::~ResponseDisconnect() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseDisconnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseDisconnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseDisconnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseDisconnect::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseDisconnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reason_disconnect_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseDisconnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.ReasonDisconnect reason_disconnect = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::ReasonDisconnect_IsValid(val))) {
            _internal_set_reason_disconnect(static_cast<::cpb::remote::ReasonDisconnect>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseDisconnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseDisconnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.ReasonDisconnect reason_disconnect = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reason_disconnect(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseDisconnect)
  return target;
}

size_t ResponseDisconnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseDisconnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .cpb.remote.ReasonDisconnect reason_disconnect = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_reason_disconnect());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseDisconnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseDisconnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseDisconnect::GetClassData() const { return &_class_data_; }


void ResponseDisconnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseDisconnect*>(&to_msg);
  auto& from = static_cast<const ResponseDisconnect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseDisconnect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reason_disconnect()) {
    _this->_internal_set_reason_disconnect(from._internal_reason_disconnect());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseDisconnect::CopyFrom(const ResponseDisconnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseDisconnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseDisconnect::IsInitialized() const {
  return true;
}

void ResponseDisconnect::InternalSwap(ResponseDisconnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reason_disconnect_, other->_impl_.reason_disconnect_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseDisconnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[15]);
}

// ===================================================================

class ResponseActiveChanged::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseActiveChanged>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResponseActiveChanged::ResponseActiveChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseActiveChanged)
}
ResponseActiveChanged::ResponseActiveChanged(const ResponseActiveChanged& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseActiveChanged* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseActiveChanged)
}

inline void ResponseActiveChanged::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){0}
  };
}

ResponseActiveChanged::~ResponseActiveChanged() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseActiveChanged)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseActiveChanged::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseActiveChanged::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseActiveChanged::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseActiveChanged)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseActiveChanged::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseActiveChanged::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseActiveChanged)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseActiveChanged)
  return target;
}

size_t ResponseActiveChanged::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseActiveChanged)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseActiveChanged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseActiveChanged::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseActiveChanged::GetClassData() const { return &_class_data_; }


void ResponseActiveChanged::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseActiveChanged*>(&to_msg);
  auto& from = static_cast<const ResponseActiveChanged&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseActiveChanged)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_id()) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseActiveChanged::CopyFrom(const ResponseActiveChanged& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseActiveChanged)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseActiveChanged::IsInitialized() const {
  return true;
}

void ResponseActiveChanged::InternalSwap(ResponseActiveChanged* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseActiveChanged::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[16]);
}

// ===================================================================

class RequestSetTrackPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestSetTrackPosition>()._impl_._has_bits_);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestSetTrackPosition::RequestSetTrackPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestSetTrackPosition)
}
RequestSetTrackPosition::RequestSetTrackPosition(const RequestSetTrackPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestSetTrackPosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.position_ = from._impl_.position_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestSetTrackPosition)
}

inline void RequestSetTrackPosition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){0}
  };
}

RequestSetTrackPosition::~RequestSetTrackPosition() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestSetTrackPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestSetTrackPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestSetTrackPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestSetTrackPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestSetTrackPosition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestSetTrackPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestSetTrackPosition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestSetTrackPosition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestSetTrackPosition)
  return target;
}

size_t RequestSetTrackPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestSetTrackPosition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_position());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestSetTrackPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestSetTrackPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestSetTrackPosition::GetClassData() const { return &_class_data_; }


void RequestSetTrackPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestSetTrackPosition*>(&to_msg);
  auto& from = static_cast<const RequestSetTrackPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestSetTrackPosition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _this->_internal_set_position(from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestSetTrackPosition::CopyFrom(const RequestSetTrackPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestSetTrackPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSetTrackPosition::IsInitialized() const {
  return true;
}

void RequestSetTrackPosition::InternalSwap(RequestSetTrackPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestSetTrackPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[17]);
}

// ===================================================================

class RequestInsertUrls::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestInsertUrls>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_play_now(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enqueue(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_new_playlist_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestInsertUrls::RequestInsertUrls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestInsertUrls)
}
RequestInsertUrls::RequestInsertUrls(const RequestInsertUrls& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestInsertUrls* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.urls_){from._impl_.urls_}
    , decltype(_impl_.songs_){from._impl_.songs_}
    , decltype(_impl_.new_playlist_name_){}
    , decltype(_impl_.playlist_id_){}
    , decltype(_impl_.play_now_){}
    , decltype(_impl_.enqueue_){}
    , decltype(_impl_.position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.new_playlist_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_playlist_name()) {
    _this->_impl_.new_playlist_name_.Set(from._internal_new_playlist_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.playlist_id_, &from._impl_.playlist_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.position_) -
    reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.position_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestInsertUrls)
}

inline void RequestInsertUrls::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.urls_){arena}
    , decltype(_impl_.songs_){arena}
    , decltype(_impl_.new_playlist_name_){}
    , decltype(_impl_.playlist_id_){0}
    , decltype(_impl_.play_now_){false}
    , decltype(_impl_.enqueue_){false}
    , decltype(_impl_.position_){-1}
  };
  _impl_.new_playlist_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestInsertUrls::~RequestInsertUrls() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestInsertUrls)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestInsertUrls::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.urls_.~RepeatedPtrField();
  _impl_.songs_.~RepeatedPtrField();
  _impl_.new_playlist_name_.Destroy();
}

void RequestInsertUrls::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestInsertUrls::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestInsertUrls)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.urls_.Clear();
  _impl_.songs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.new_playlist_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.playlist_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enqueue_) -
        reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.enqueue_));
    _impl_.position_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestInsertUrls::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string urls = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_urls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "cpb.remote.RequestInsertUrls.urls");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 position = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool play_now = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_play_now(&has_bits);
          _impl_.play_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enqueue = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_enqueue(&has_bits);
          _impl_.enqueue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .cpb.remote.SongMetadata songs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_songs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string new_playlist_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_new_playlist_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestInsertUrls.new_playlist_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestInsertUrls::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestInsertUrls)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  // repeated string urls = 2;
  for (int i = 0, n = this->_internal_urls_size(); i < n; i++) {
    const auto& s = this->_internal_urls(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestInsertUrls.urls");
    target = stream->WriteString(2, s, target);
  }

  // optional int32 position = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_position(), target);
  }

  // optional bool play_now = 4 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_play_now(), target);
  }

  // optional bool enqueue = 5 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_enqueue(), target);
  }

  // repeated .cpb.remote.SongMetadata songs = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_songs_size()); i < n; i++) {
    const auto& repfield = this->_internal_songs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string new_playlist_name = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_new_playlist_name().data(), static_cast<int>(this->_internal_new_playlist_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestInsertUrls.new_playlist_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_new_playlist_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestInsertUrls)
  return target;
}

size_t RequestInsertUrls::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestInsertUrls)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string urls = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.urls_.size());
  for (int i = 0, n = _impl_.urls_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.urls_.Get(i));
  }

  // repeated .cpb.remote.SongMetadata songs = 6;
  total_size += 1UL * this->_internal_songs_size();
  for (const auto& msg : this->_impl_.songs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string new_playlist_name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_playlist_name());
    }

    // optional int32 playlist_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
    }

    // optional bool play_now = 4 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool enqueue = 5 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional int32 position = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_position());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestInsertUrls::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestInsertUrls::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestInsertUrls::GetClassData() const { return &_class_data_; }


void RequestInsertUrls::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestInsertUrls*>(&to_msg);
  auto& from = static_cast<const RequestInsertUrls&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestInsertUrls)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.urls_.MergeFrom(from._impl_.urls_);
  _this->_impl_.songs_.MergeFrom(from._impl_.songs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_playlist_name(from._internal_new_playlist_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.play_now_ = from._impl_.play_now_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.enqueue_ = from._impl_.enqueue_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestInsertUrls::CopyFrom(const RequestInsertUrls& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestInsertUrls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestInsertUrls::IsInitialized() const {
  return true;
}

void RequestInsertUrls::InternalSwap(RequestInsertUrls* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.urls_.InternalSwap(&other->_impl_.urls_);
  _impl_.songs_.InternalSwap(&other->_impl_.songs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_playlist_name_, lhs_arena,
      &other->_impl_.new_playlist_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestInsertUrls, _impl_.enqueue_)
      + sizeof(RequestInsertUrls::_impl_.enqueue_)
      - PROTOBUF_FIELD_OFFSET(RequestInsertUrls, _impl_.playlist_id_)>(
          reinterpret_cast<char*>(&_impl_.playlist_id_),
          reinterpret_cast<char*>(&other->_impl_.playlist_id_));
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestInsertUrls::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[18]);
}

// ===================================================================

class RequestRemoveSongs::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestRemoveSongs>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestRemoveSongs::RequestRemoveSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestRemoveSongs)
}
RequestRemoveSongs::RequestRemoveSongs(const RequestRemoveSongs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestRemoveSongs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.songs_){from._impl_.songs_}
    , decltype(_impl_.playlist_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestRemoveSongs)
}

inline void RequestRemoveSongs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.songs_){arena}
    , decltype(_impl_.playlist_id_){0}
  };
}

RequestRemoveSongs::~RequestRemoveSongs() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestRemoveSongs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestRemoveSongs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.songs_.~RepeatedField();
}

void RequestRemoveSongs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestRemoveSongs::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestRemoveSongs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.songs_.Clear();
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestRemoveSongs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 songs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_songs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_songs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestRemoveSongs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestRemoveSongs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  // repeated int32 songs = 2;
  for (int i = 0, n = this->_internal_songs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_songs(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestRemoveSongs)
  return target;
}

size_t RequestRemoveSongs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestRemoveSongs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 songs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.songs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_songs_size());
    total_size += data_size;
  }

  // optional int32 playlist_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestRemoveSongs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestRemoveSongs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestRemoveSongs::GetClassData() const { return &_class_data_; }


void RequestRemoveSongs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestRemoveSongs*>(&to_msg);
  auto& from = static_cast<const RequestRemoveSongs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestRemoveSongs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.songs_.MergeFrom(from._impl_.songs_);
  if (from._internal_has_playlist_id()) {
    _this->_internal_set_playlist_id(from._internal_playlist_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestRemoveSongs::CopyFrom(const RequestRemoveSongs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestRemoveSongs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoveSongs::IsInitialized() const {
  return true;
}

void RequestRemoveSongs::InternalSwap(RequestRemoveSongs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.songs_.InternalSwap(&other->_impl_.songs_);
  swap(_impl_.playlist_id_, other->_impl_.playlist_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestRemoveSongs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[19]);
}

// ===================================================================

class RequestOpenPlaylist::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestOpenPlaylist>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestOpenPlaylist::RequestOpenPlaylist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestOpenPlaylist)
}
RequestOpenPlaylist::RequestOpenPlaylist(const RequestOpenPlaylist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestOpenPlaylist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestOpenPlaylist)
}

inline void RequestOpenPlaylist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_id_){0}
  };
}

RequestOpenPlaylist::~RequestOpenPlaylist() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestOpenPlaylist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestOpenPlaylist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestOpenPlaylist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestOpenPlaylist::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestOpenPlaylist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.playlist_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestOpenPlaylist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestOpenPlaylist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestOpenPlaylist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestOpenPlaylist)
  return target;
}

size_t RequestOpenPlaylist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestOpenPlaylist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 playlist_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestOpenPlaylist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestOpenPlaylist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestOpenPlaylist::GetClassData() const { return &_class_data_; }


void RequestOpenPlaylist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestOpenPlaylist*>(&to_msg);
  auto& from = static_cast<const RequestOpenPlaylist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestOpenPlaylist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playlist_id()) {
    _this->_internal_set_playlist_id(from._internal_playlist_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestOpenPlaylist::CopyFrom(const RequestOpenPlaylist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestOpenPlaylist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestOpenPlaylist::IsInitialized() const {
  return true;
}

void RequestOpenPlaylist::InternalSwap(RequestOpenPlaylist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.playlist_id_, other->_impl_.playlist_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestOpenPlaylist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[20]);
}

// ===================================================================

class RequestClosePlaylist::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestClosePlaylist>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestClosePlaylist::RequestClosePlaylist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestClosePlaylist)
}
RequestClosePlaylist::RequestClosePlaylist(const RequestClosePlaylist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestClosePlaylist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestClosePlaylist)
}

inline void RequestClosePlaylist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playlist_id_){0}
  };
}

RequestClosePlaylist::~RequestClosePlaylist() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestClosePlaylist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestClosePlaylist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestClosePlaylist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestClosePlaylist::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestClosePlaylist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.playlist_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestClosePlaylist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestClosePlaylist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestClosePlaylist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestClosePlaylist)
  return target;
}

size_t RequestClosePlaylist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestClosePlaylist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 playlist_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestClosePlaylist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestClosePlaylist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestClosePlaylist::GetClassData() const { return &_class_data_; }


void RequestClosePlaylist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestClosePlaylist*>(&to_msg);
  auto& from = static_cast<const RequestClosePlaylist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestClosePlaylist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playlist_id()) {
    _this->_internal_set_playlist_id(from._internal_playlist_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestClosePlaylist::CopyFrom(const RequestClosePlaylist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestClosePlaylist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestClosePlaylist::IsInitialized() const {
  return true;
}

void RequestClosePlaylist::InternalSwap(RequestClosePlaylist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.playlist_id_, other->_impl_.playlist_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestClosePlaylist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[21]);
}

// ===================================================================

class RequestUpdatePlaylist::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestUpdatePlaylist>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_playlist_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_favorite(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_create_new_playlist(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_clear_playlist(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

RequestUpdatePlaylist::RequestUpdatePlaylist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestUpdatePlaylist)
}
RequestUpdatePlaylist::RequestUpdatePlaylist(const RequestUpdatePlaylist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestUpdatePlaylist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_playlist_name_){}
    , decltype(_impl_.playlist_id_){}
    , decltype(_impl_.favorite_){}
    , decltype(_impl_.create_new_playlist_){}
    , decltype(_impl_.clear_playlist_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.new_playlist_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_playlist_name()) {
    _this->_impl_.new_playlist_name_.Set(from._internal_new_playlist_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.playlist_id_, &from._impl_.playlist_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clear_playlist_) -
    reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.clear_playlist_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestUpdatePlaylist)
}

inline void RequestUpdatePlaylist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_playlist_name_){}
    , decltype(_impl_.playlist_id_){0}
    , decltype(_impl_.favorite_){false}
    , decltype(_impl_.create_new_playlist_){false}
    , decltype(_impl_.clear_playlist_){false}
  };
  _impl_.new_playlist_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestUpdatePlaylist::~RequestUpdatePlaylist() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestUpdatePlaylist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestUpdatePlaylist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_playlist_name_.Destroy();
}

void RequestUpdatePlaylist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestUpdatePlaylist::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestUpdatePlaylist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.new_playlist_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.playlist_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clear_playlist_) -
        reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.clear_playlist_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestUpdatePlaylist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string new_playlist_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_playlist_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestUpdatePlaylist.new_playlist_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool favorite = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_favorite(&has_bits);
          _impl_.favorite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool create_new_playlist = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_create_new_playlist(&has_bits);
          _impl_.create_new_playlist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clear_playlist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_clear_playlist(&has_bits);
          _impl_.clear_playlist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestUpdatePlaylist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestUpdatePlaylist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  // optional string new_playlist_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_new_playlist_name().data(), static_cast<int>(this->_internal_new_playlist_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestUpdatePlaylist.new_playlist_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_playlist_name(), target);
  }

  // optional bool favorite = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_favorite(), target);
  }

  // optional bool create_new_playlist = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_create_new_playlist(), target);
  }

  // optional bool clear_playlist = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_clear_playlist(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestUpdatePlaylist)
  return target;
}

size_t RequestUpdatePlaylist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestUpdatePlaylist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string new_playlist_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_playlist_name());
    }

    // optional int32 playlist_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
    }

    // optional bool favorite = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool create_new_playlist = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool clear_playlist = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestUpdatePlaylist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestUpdatePlaylist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestUpdatePlaylist::GetClassData() const { return &_class_data_; }


void RequestUpdatePlaylist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestUpdatePlaylist*>(&to_msg);
  auto& from = static_cast<const RequestUpdatePlaylist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestUpdatePlaylist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_playlist_name(from._internal_new_playlist_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.favorite_ = from._impl_.favorite_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.create_new_playlist_ = from._impl_.create_new_playlist_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.clear_playlist_ = from._impl_.clear_playlist_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestUpdatePlaylist::CopyFrom(const RequestUpdatePlaylist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestUpdatePlaylist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdatePlaylist::IsInitialized() const {
  return true;
}

void RequestUpdatePlaylist::InternalSwap(RequestUpdatePlaylist* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_playlist_name_, lhs_arena,
      &other->_impl_.new_playlist_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestUpdatePlaylist, _impl_.clear_playlist_)
      + sizeof(RequestUpdatePlaylist::_impl_.clear_playlist_)
      - PROTOBUF_FIELD_OFFSET(RequestUpdatePlaylist, _impl_.playlist_id_)>(
          reinterpret_cast<char*>(&_impl_.playlist_id_),
          reinterpret_cast<char*>(&other->_impl_.playlist_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestUpdatePlaylist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[22]);
}

// ===================================================================

class ResponseLyrics::_Internal {
 public:
};

ResponseLyrics::ResponseLyrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseLyrics)
}
ResponseLyrics::ResponseLyrics(const ResponseLyrics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseLyrics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lyrics_){from._impl_.lyrics_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseLyrics)
}

inline void ResponseLyrics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lyrics_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponseLyrics::~ResponseLyrics() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseLyrics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseLyrics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lyrics_.~RepeatedPtrField();
}

void ResponseLyrics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseLyrics::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseLyrics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lyrics_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseLyrics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cpb.remote.Lyric lyrics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lyrics(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseLyrics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseLyrics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cpb.remote.Lyric lyrics = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lyrics_size()); i < n; i++) {
    const auto& repfield = this->_internal_lyrics(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseLyrics)
  return target;
}

size_t ResponseLyrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseLyrics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cpb.remote.Lyric lyrics = 1;
  total_size += 1UL * this->_internal_lyrics_size();
  for (const auto& msg : this->_impl_.lyrics_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseLyrics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseLyrics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseLyrics::GetClassData() const { return &_class_data_; }


void ResponseLyrics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseLyrics*>(&to_msg);
  auto& from = static_cast<const ResponseLyrics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseLyrics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lyrics_.MergeFrom(from._impl_.lyrics_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseLyrics::CopyFrom(const ResponseLyrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseLyrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseLyrics::IsInitialized() const {
  return true;
}

void ResponseLyrics::InternalSwap(ResponseLyrics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.lyrics_.InternalSwap(&other->_impl_.lyrics_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseLyrics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[23]);
}

// ===================================================================

class Lyric::_Internal {
 public:
  using HasBits = decltype(std::declval<Lyric>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Lyric::Lyric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.Lyric)
}
Lyric::Lyric(const Lyric& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Lyric* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.content_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content()) {
    _this->_impl_.content_.Set(from._internal_content(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.remote.Lyric)
}

inline void Lyric::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.content_){}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Lyric::~Lyric() {
  // @@protoc_insertion_point(destructor:cpb.remote.Lyric)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lyric::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.title_.Destroy();
  _impl_.content_.Destroy();
}

void Lyric::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lyric::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.Lyric)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.content_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Lyric::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Lyric.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Lyric.title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string content = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Lyric.content");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lyric::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.Lyric)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Lyric.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // optional string title = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Lyric.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // optional string content = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_content().data(), static_cast<int>(this->_internal_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Lyric.content");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.Lyric)
  return target;
}

size_t Lyric::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.Lyric)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string content = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Lyric::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Lyric::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Lyric::GetClassData() const { return &_class_data_; }


void Lyric::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Lyric*>(&to_msg);
  auto& from = static_cast<const Lyric&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.Lyric)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_content(from._internal_content());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Lyric::CopyFrom(const Lyric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.Lyric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lyric::IsInitialized() const {
  return true;
}

void Lyric::InternalSwap(Lyric* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.content_, lhs_arena,
      &other->_impl_.content_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Lyric::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[24]);
}

// ===================================================================

class RequestDownloadSongs::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestDownloadSongs>()._impl_._has_bits_);
  static void set_has_download_item(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_relative_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestDownloadSongs::RequestDownloadSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestDownloadSongs)
}
RequestDownloadSongs::RequestDownloadSongs(const RequestDownloadSongs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestDownloadSongs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.urls_){from._impl_.urls_}
    , decltype(_impl_.songs_ids_){from._impl_.songs_ids_}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.playlist_id_){}
    , decltype(_impl_.download_item_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relative_path()) {
    _this->_impl_.relative_path_.Set(from._internal_relative_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.playlist_id_, &from._impl_.playlist_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.download_item_) -
    reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.download_item_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestDownloadSongs)
}

inline void RequestDownloadSongs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.urls_){arena}
    , decltype(_impl_.songs_ids_){arena}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.playlist_id_){0}
    , decltype(_impl_.download_item_){1}
  };
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestDownloadSongs::~RequestDownloadSongs() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestDownloadSongs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestDownloadSongs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.urls_.~RepeatedPtrField();
  _impl_.songs_ids_.~RepeatedField();
  _impl_.relative_path_.Destroy();
}

void RequestDownloadSongs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestDownloadSongs::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestDownloadSongs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.urls_.Clear();
  _impl_.songs_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.relative_path_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.playlist_id_ = 0;
    _impl_.download_item_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestDownloadSongs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .cpb.remote.DownloadItem download_item = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::DownloadItem_IsValid(val))) {
            _internal_set_download_item(static_cast<::cpb::remote::DownloadItem>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 playlist_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string urls = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_urls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "cpb.remote.RequestDownloadSongs.urls");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 songs_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_songs_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_songs_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string relative_path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_relative_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestDownloadSongs.relative_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestDownloadSongs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestDownloadSongs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.DownloadItem download_item = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_download_item(), target);
  }

  // optional int32 playlist_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_playlist_id(), target);
  }

  // repeated string urls = 3;
  for (int i = 0, n = this->_internal_urls_size(); i < n; i++) {
    const auto& s = this->_internal_urls(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestDownloadSongs.urls");
    target = stream->WriteString(3, s, target);
  }

  // repeated int32 songs_ids = 4;
  for (int i = 0, n = this->_internal_songs_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_songs_ids(i), target);
  }

  // optional string relative_path = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_relative_path().data(), static_cast<int>(this->_internal_relative_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestDownloadSongs.relative_path");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_relative_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestDownloadSongs)
  return target;
}

size_t RequestDownloadSongs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestDownloadSongs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string urls = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.urls_.size());
  for (int i = 0, n = _impl_.urls_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.urls_.Get(i));
  }

  // repeated int32 songs_ids = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.songs_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_songs_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string relative_path = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_relative_path());
    }

    // optional int32 playlist_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
    }

    // optional .cpb.remote.DownloadItem download_item = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_download_item());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestDownloadSongs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestDownloadSongs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestDownloadSongs::GetClassData() const { return &_class_data_; }


void RequestDownloadSongs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestDownloadSongs*>(&to_msg);
  auto& from = static_cast<const RequestDownloadSongs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestDownloadSongs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.urls_.MergeFrom(from._impl_.urls_);
  _this->_impl_.songs_ids_.MergeFrom(from._impl_.songs_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_relative_path(from._internal_relative_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.download_item_ = from._impl_.download_item_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestDownloadSongs::CopyFrom(const RequestDownloadSongs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestDownloadSongs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDownloadSongs::IsInitialized() const {
  return true;
}

void RequestDownloadSongs::InternalSwap(RequestDownloadSongs* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.urls_.InternalSwap(&other->_impl_.urls_);
  _impl_.songs_ids_.InternalSwap(&other->_impl_.songs_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relative_path_, lhs_arena,
      &other->_impl_.relative_path_, rhs_arena
  );
  swap(_impl_.playlist_id_, other->_impl_.playlist_id_);
  swap(_impl_.download_item_, other->_impl_.download_item_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestDownloadSongs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[25]);
}

// ===================================================================

class ResponseSongFileChunk::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseSongFileChunk>()._impl_._has_bits_);
  static void set_has_chunk_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_chunk_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_file_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_file_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::cpb::remote::SongMetadata& song_metadata(const ResponseSongFileChunk* msg);
  static void set_has_song_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_file_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::cpb::remote::SongMetadata&
ResponseSongFileChunk::_Internal::song_metadata(const ResponseSongFileChunk* msg) {
  return *msg->_impl_.song_metadata_;
}
ResponseSongFileChunk::ResponseSongFileChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseSongFileChunk)
}
ResponseSongFileChunk::ResponseSongFileChunk(const ResponseSongFileChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseSongFileChunk* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.file_hash_){}
    , decltype(_impl_.song_metadata_){nullptr}
    , decltype(_impl_.chunk_number_){}
    , decltype(_impl_.chunk_count_){}
    , decltype(_impl_.file_number_){}
    , decltype(_impl_.file_count_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_hash()) {
    _this->_impl_.file_hash_.Set(from._internal_file_hash(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_song_metadata()) {
    _this->_impl_.song_metadata_ = new ::cpb::remote::SongMetadata(*from._impl_.song_metadata_);
  }
  ::memcpy(&_impl_.chunk_number_, &from._impl_.chunk_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.chunk_number_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseSongFileChunk)
}

inline void ResponseSongFileChunk::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.file_hash_){}
    , decltype(_impl_.song_metadata_){nullptr}
    , decltype(_impl_.chunk_number_){0}
    , decltype(_impl_.chunk_count_){0}
    , decltype(_impl_.file_number_){0}
    , decltype(_impl_.file_count_){0}
    , decltype(_impl_.size_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseSongFileChunk::~ResponseSongFileChunk() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseSongFileChunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseSongFileChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  _impl_.file_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.song_metadata_;
}

void ResponseSongFileChunk::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseSongFileChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseSongFileChunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.file_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.song_metadata_ != nullptr);
      _impl_.song_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.chunk_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.chunk_number_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseSongFileChunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 chunk_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chunk_number(&has_bits);
          _impl_.chunk_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 chunk_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_chunk_count(&has_bits);
          _impl_.chunk_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 file_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_file_number(&has_bits);
          _impl_.file_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 file_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_file_count(&has_bits);
          _impl_.file_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.SongMetadata song_metadata = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_song_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes file_hash = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_file_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseSongFileChunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseSongFileChunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 chunk_number = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_chunk_number(), target);
  }

  // optional int32 chunk_count = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_chunk_count(), target);
  }

  // optional int32 file_number = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_file_number(), target);
  }

  // optional int32 file_count = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_file_count(), target);
  }

  // optional .cpb.remote.SongMetadata song_metadata = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::song_metadata(this),
        _Internal::song_metadata(this).GetCachedSize(), target, stream);
  }

  // optional bytes data = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_data(), target);
  }

  // optional int32 size = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_size(), target);
  }

  // optional bytes file_hash = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_file_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseSongFileChunk)
  return target;
}

size_t ResponseSongFileChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseSongFileChunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes data = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bytes file_hash = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_file_hash());
    }

    // optional .cpb.remote.SongMetadata song_metadata = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.song_metadata_);
    }

    // optional int32 chunk_number = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chunk_number());
    }

    // optional int32 chunk_count = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chunk_count());
    }

    // optional int32 file_number = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_file_number());
    }

    // optional int32 file_count = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_file_count());
    }

    // optional int32 size = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseSongFileChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseSongFileChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseSongFileChunk::GetClassData() const { return &_class_data_; }


void ResponseSongFileChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseSongFileChunk*>(&to_msg);
  auto& from = static_cast<const ResponseSongFileChunk&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseSongFileChunk)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_file_hash(from._internal_file_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_song_metadata()->::cpb::remote::SongMetadata::MergeFrom(
          from._internal_song_metadata());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.chunk_number_ = from._impl_.chunk_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.chunk_count_ = from._impl_.chunk_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.file_number_ = from._impl_.file_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.file_count_ = from._impl_.file_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseSongFileChunk::CopyFrom(const ResponseSongFileChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseSongFileChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseSongFileChunk::IsInitialized() const {
  return true;
}

void ResponseSongFileChunk::InternalSwap(ResponseSongFileChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_hash_, lhs_arena,
      &other->_impl_.file_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResponseSongFileChunk, _impl_.size_)
      + sizeof(ResponseSongFileChunk::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(ResponseSongFileChunk, _impl_.song_metadata_)>(
          reinterpret_cast<char*>(&_impl_.song_metadata_),
          reinterpret_cast<char*>(&other->_impl_.song_metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseSongFileChunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[26]);
}

// ===================================================================

class ResponseLibraryChunk::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseLibraryChunk>()._impl_._has_bits_);
  static void set_has_chunk_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_chunk_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_file_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResponseLibraryChunk::ResponseLibraryChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseLibraryChunk)
}
ResponseLibraryChunk::ResponseLibraryChunk(const ResponseLibraryChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseLibraryChunk* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.file_hash_){}
    , decltype(_impl_.chunk_number_){}
    , decltype(_impl_.chunk_count_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.file_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_file_hash()) {
    _this->_impl_.file_hash_.Set(from._internal_file_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.chunk_number_, &from._impl_.chunk_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.chunk_number_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseLibraryChunk)
}

inline void ResponseLibraryChunk::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.file_hash_){}
    , decltype(_impl_.chunk_number_){0}
    , decltype(_impl_.chunk_count_){0}
    , decltype(_impl_.size_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseLibraryChunk::~ResponseLibraryChunk() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseLibraryChunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseLibraryChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  _impl_.file_hash_.Destroy();
}

void ResponseLibraryChunk::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseLibraryChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseLibraryChunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.file_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.chunk_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.chunk_number_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseLibraryChunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 chunk_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chunk_number(&has_bits);
          _impl_.chunk_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 chunk_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_chunk_count(&has_bits);
          _impl_.chunk_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes file_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_file_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseLibraryChunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseLibraryChunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 chunk_number = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_chunk_number(), target);
  }

  // optional int32 chunk_count = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_chunk_count(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional int32 size = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_size(), target);
  }

  // optional bytes file_hash = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_file_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseLibraryChunk)
  return target;
}

size_t ResponseLibraryChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseLibraryChunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bytes file_hash = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_file_hash());
    }

    // optional int32 chunk_number = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chunk_number());
    }

    // optional int32 chunk_count = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chunk_count());
    }

    // optional int32 size = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseLibraryChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseLibraryChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseLibraryChunk::GetClassData() const { return &_class_data_; }


void ResponseLibraryChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseLibraryChunk*>(&to_msg);
  auto& from = static_cast<const ResponseLibraryChunk&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseLibraryChunk)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_file_hash(from._internal_file_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.chunk_number_ = from._impl_.chunk_number_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.chunk_count_ = from._impl_.chunk_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseLibraryChunk::CopyFrom(const ResponseLibraryChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseLibraryChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseLibraryChunk::IsInitialized() const {
  return true;
}

void ResponseLibraryChunk::InternalSwap(ResponseLibraryChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.file_hash_, lhs_arena,
      &other->_impl_.file_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResponseLibraryChunk, _impl_.size_)
      + sizeof(ResponseLibraryChunk::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(ResponseLibraryChunk, _impl_.chunk_number_)>(
          reinterpret_cast<char*>(&_impl_.chunk_number_),
          reinterpret_cast<char*>(&other->_impl_.chunk_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseLibraryChunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[27]);
}

// ===================================================================

class ResponseSongOffer::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseSongOffer>()._impl_._has_bits_);
  static void set_has_accepted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ResponseSongOffer::ResponseSongOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseSongOffer)
}
ResponseSongOffer::ResponseSongOffer(const ResponseSongOffer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseSongOffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accepted_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.accepted_ = from._impl_.accepted_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseSongOffer)
}

inline void ResponseSongOffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accepted_){false}
  };
}

ResponseSongOffer::~ResponseSongOffer() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseSongOffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseSongOffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseSongOffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseSongOffer::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseSongOffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.accepted_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseSongOffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool accepted = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_accepted(&has_bits);
          _impl_.accepted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseSongOffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseSongOffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool accepted = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_accepted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseSongOffer)
  return target;
}

size_t ResponseSongOffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseSongOffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool accepted = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseSongOffer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseSongOffer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseSongOffer::GetClassData() const { return &_class_data_; }


void ResponseSongOffer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseSongOffer*>(&to_msg);
  auto& from = static_cast<const ResponseSongOffer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseSongOffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_accepted()) {
    _this->_internal_set_accepted(from._internal_accepted());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseSongOffer::CopyFrom(const ResponseSongOffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseSongOffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseSongOffer::IsInitialized() const {
  return true;
}

void ResponseSongOffer::InternalSwap(ResponseSongOffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.accepted_, other->_impl_.accepted_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseSongOffer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[28]);
}

// ===================================================================

class RequestRateSong::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestRateSong>()._impl_._has_bits_);
  static void set_has_rating(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestRateSong::RequestRateSong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestRateSong)
}
RequestRateSong::RequestRateSong(const RequestRateSong& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestRateSong* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rating_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.rating_ = from._impl_.rating_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestRateSong)
}

inline void RequestRateSong::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rating_){0}
  };
}

RequestRateSong::~RequestRateSong() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestRateSong)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestRateSong::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequestRateSong::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestRateSong::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestRateSong)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rating_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestRateSong::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float rating = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_rating(&has_bits);
          _impl_.rating_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestRateSong::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestRateSong)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float rating = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_rating(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestRateSong)
  return target;
}

size_t RequestRateSong::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestRateSong)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float rating = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestRateSong::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestRateSong::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestRateSong::GetClassData() const { return &_class_data_; }


void RequestRateSong::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestRateSong*>(&to_msg);
  auto& from = static_cast<const RequestRateSong&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestRateSong)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rating()) {
    _this->_internal_set_rating(from._internal_rating());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestRateSong::CopyFrom(const RequestRateSong& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestRateSong)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRateSong::IsInitialized() const {
  return true;
}

void RequestRateSong::InternalSwap(RequestRateSong* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rating_, other->_impl_.rating_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestRateSong::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[29]);
}

// ===================================================================

class ResponseDownloadTotalSize::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseDownloadTotalSize>()._impl_._has_bits_);
  static void set_has_total_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_file_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResponseDownloadTotalSize::ResponseDownloadTotalSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseDownloadTotalSize)
}
ResponseDownloadTotalSize::ResponseDownloadTotalSize(const ResponseDownloadTotalSize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseDownloadTotalSize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.total_size_){}
    , decltype(_impl_.file_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.total_size_, &from._impl_.total_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.file_count_) -
    reinterpret_cast<char*>(&_impl_.total_size_)) + sizeof(_impl_.file_count_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseDownloadTotalSize)
}

inline void ResponseDownloadTotalSize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.total_size_){0}
    , decltype(_impl_.file_count_){0}
  };
}

ResponseDownloadTotalSize::~ResponseDownloadTotalSize() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseDownloadTotalSize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseDownloadTotalSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseDownloadTotalSize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseDownloadTotalSize::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseDownloadTotalSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.total_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.file_count_) -
        reinterpret_cast<char*>(&_impl_.total_size_)) + sizeof(_impl_.file_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseDownloadTotalSize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 total_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_total_size(&has_bits);
          _impl_.total_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 file_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_file_count(&has_bits);
          _impl_.file_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseDownloadTotalSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseDownloadTotalSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 total_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_total_size(), target);
  }

  // optional int32 file_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_file_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseDownloadTotalSize)
  return target;
}

size_t ResponseDownloadTotalSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseDownloadTotalSize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 total_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total_size());
    }

    // optional int32 file_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_file_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseDownloadTotalSize::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseDownloadTotalSize::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseDownloadTotalSize::GetClassData() const { return &_class_data_; }


void ResponseDownloadTotalSize::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseDownloadTotalSize*>(&to_msg);
  auto& from = static_cast<const ResponseDownloadTotalSize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseDownloadTotalSize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.total_size_ = from._impl_.total_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.file_count_ = from._impl_.file_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseDownloadTotalSize::CopyFrom(const ResponseDownloadTotalSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseDownloadTotalSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseDownloadTotalSize::IsInitialized() const {
  return true;
}

void ResponseDownloadTotalSize::InternalSwap(ResponseDownloadTotalSize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResponseDownloadTotalSize, _impl_.file_count_)
      + sizeof(ResponseDownloadTotalSize::_impl_.file_count_)
      - PROTOBUF_FIELD_OFFSET(ResponseDownloadTotalSize, _impl_.total_size_)>(
          reinterpret_cast<char*>(&_impl_.total_size_),
          reinterpret_cast<char*>(&other->_impl_.total_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseDownloadTotalSize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[30]);
}

// ===================================================================

class RequestGlobalSearch::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestGlobalSearch>()._impl_._has_bits_);
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestGlobalSearch::RequestGlobalSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestGlobalSearch)
}
RequestGlobalSearch::RequestGlobalSearch(const RequestGlobalSearch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestGlobalSearch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.query_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.query_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_query()) {
    _this->_impl_.query_.Set(from._internal_query(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestGlobalSearch)
}

inline void RequestGlobalSearch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.query_){}
  };
  _impl_.query_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestGlobalSearch::~RequestGlobalSearch() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestGlobalSearch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestGlobalSearch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.query_.Destroy();
}

void RequestGlobalSearch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestGlobalSearch::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestGlobalSearch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.query_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestGlobalSearch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string query = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_query();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestGlobalSearch.query");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestGlobalSearch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestGlobalSearch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string query = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_query().data(), static_cast<int>(this->_internal_query().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestGlobalSearch.query");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_query(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestGlobalSearch)
  return target;
}

size_t RequestGlobalSearch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestGlobalSearch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string query = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_query());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestGlobalSearch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestGlobalSearch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestGlobalSearch::GetClassData() const { return &_class_data_; }


void RequestGlobalSearch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestGlobalSearch*>(&to_msg);
  auto& from = static_cast<const RequestGlobalSearch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestGlobalSearch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_query()) {
    _this->_internal_set_query(from._internal_query());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestGlobalSearch::CopyFrom(const RequestGlobalSearch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestGlobalSearch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGlobalSearch::IsInitialized() const {
  return true;
}

void RequestGlobalSearch::InternalSwap(RequestGlobalSearch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.query_, lhs_arena,
      &other->_impl_.query_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestGlobalSearch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[31]);
}

// ===================================================================

class ResponseGlobalSearch::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseGlobalSearch>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_search_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_search_provider_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ResponseGlobalSearch::ResponseGlobalSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseGlobalSearch)
}
ResponseGlobalSearch::ResponseGlobalSearch(const ResponseGlobalSearch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseGlobalSearch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.song_metadata_){from._impl_.song_metadata_}
    , decltype(_impl_.query_){}
    , decltype(_impl_.search_provider_){}
    , decltype(_impl_.search_provider_icon_){}
    , decltype(_impl_.id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.query_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_query()) {
    _this->_impl_.query_.Set(from._internal_query(), 
      _this->GetArenaForAllocation());
  }
  _impl_.search_provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_provider_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_search_provider()) {
    _this->_impl_.search_provider_.Set(from._internal_search_provider(), 
      _this->GetArenaForAllocation());
  }
  _impl_.search_provider_icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_provider_icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_search_provider_icon()) {
    _this->_impl_.search_provider_icon_.Set(from._internal_search_provider_icon(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseGlobalSearch)
}

inline void ResponseGlobalSearch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.song_metadata_){arena}
    , decltype(_impl_.query_){}
    , decltype(_impl_.search_provider_){}
    , decltype(_impl_.search_provider_icon_){}
    , decltype(_impl_.id_){0}
  };
  _impl_.query_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.search_provider_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_provider_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.search_provider_icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_provider_icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseGlobalSearch::~ResponseGlobalSearch() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseGlobalSearch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseGlobalSearch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.song_metadata_.~RepeatedPtrField();
  _impl_.query_.Destroy();
  _impl_.search_provider_.Destroy();
  _impl_.search_provider_icon_.Destroy();
}

void ResponseGlobalSearch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseGlobalSearch::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseGlobalSearch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.song_metadata_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.query_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.search_provider_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.search_provider_icon_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseGlobalSearch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_query();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.ResponseGlobalSearch.query");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string search_provider = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_search_provider();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.ResponseGlobalSearch.search_provider");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .cpb.remote.SongMetadata song_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_song_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes search_provider_icon = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_search_provider_icon();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseGlobalSearch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseGlobalSearch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string query = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_query().data(), static_cast<int>(this->_internal_query().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.ResponseGlobalSearch.query");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_query(), target);
  }

  // optional string search_provider = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_search_provider().data(), static_cast<int>(this->_internal_search_provider().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.ResponseGlobalSearch.search_provider");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_search_provider(), target);
  }

  // repeated .cpb.remote.SongMetadata song_metadata = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_song_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_song_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes search_provider_icon = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_search_provider_icon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseGlobalSearch)
  return target;
}

size_t ResponseGlobalSearch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseGlobalSearch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cpb.remote.SongMetadata song_metadata = 4;
  total_size += 1UL * this->_internal_song_metadata_size();
  for (const auto& msg : this->_impl_.song_metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string query = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_query());
    }

    // optional string search_provider = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_search_provider());
    }

    // optional bytes search_provider_icon = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_search_provider_icon());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseGlobalSearch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseGlobalSearch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseGlobalSearch::GetClassData() const { return &_class_data_; }


void ResponseGlobalSearch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseGlobalSearch*>(&to_msg);
  auto& from = static_cast<const ResponseGlobalSearch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseGlobalSearch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.song_metadata_.MergeFrom(from._impl_.song_metadata_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_query(from._internal_query());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_search_provider(from._internal_search_provider());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_search_provider_icon(from._internal_search_provider_icon());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseGlobalSearch::CopyFrom(const ResponseGlobalSearch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseGlobalSearch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGlobalSearch::IsInitialized() const {
  return true;
}

void ResponseGlobalSearch::InternalSwap(ResponseGlobalSearch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.song_metadata_.InternalSwap(&other->_impl_.song_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.query_, lhs_arena,
      &other->_impl_.query_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.search_provider_, lhs_arena,
      &other->_impl_.search_provider_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.search_provider_icon_, lhs_arena,
      &other->_impl_.search_provider_icon_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseGlobalSearch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[32]);
}

// ===================================================================

class ResponseTranscoderStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseTranscoderStatus>()._impl_._has_bits_);
  static void set_has_processed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResponseTranscoderStatus::ResponseTranscoderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseTranscoderStatus)
}
ResponseTranscoderStatus::ResponseTranscoderStatus(const ResponseTranscoderStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseTranscoderStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.processed_){}
    , decltype(_impl_.total_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.processed_, &from._impl_.processed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_) -
    reinterpret_cast<char*>(&_impl_.processed_)) + sizeof(_impl_.total_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseTranscoderStatus)
}

inline void ResponseTranscoderStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.processed_){0}
    , decltype(_impl_.total_){0}
  };
}

ResponseTranscoderStatus::~ResponseTranscoderStatus() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseTranscoderStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseTranscoderStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResponseTranscoderStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseTranscoderStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseTranscoderStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.processed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_) -
        reinterpret_cast<char*>(&_impl_.processed_)) + sizeof(_impl_.total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseTranscoderStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 processed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_processed(&has_bits);
          _impl_.processed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 total = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_total(&has_bits);
          _impl_.total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseTranscoderStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseTranscoderStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 processed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_processed(), target);
  }

  // optional int32 total = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseTranscoderStatus)
  return target;
}

size_t ResponseTranscoderStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseTranscoderStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 processed = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_processed());
    }

    // optional int32 total = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseTranscoderStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseTranscoderStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseTranscoderStatus::GetClassData() const { return &_class_data_; }


void ResponseTranscoderStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseTranscoderStatus*>(&to_msg);
  auto& from = static_cast<const ResponseTranscoderStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseTranscoderStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.processed_ = from._impl_.processed_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_ = from._impl_.total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseTranscoderStatus::CopyFrom(const ResponseTranscoderStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseTranscoderStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseTranscoderStatus::IsInitialized() const {
  return true;
}

void ResponseTranscoderStatus::InternalSwap(ResponseTranscoderStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResponseTranscoderStatus, _impl_.total_)
      + sizeof(ResponseTranscoderStatus::_impl_.total_)
      - PROTOBUF_FIELD_OFFSET(ResponseTranscoderStatus, _impl_.processed_)>(
          reinterpret_cast<char*>(&_impl_.processed_),
          reinterpret_cast<char*>(&other->_impl_.processed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseTranscoderStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[33]);
}

// ===================================================================

class ResponseGlobalSearchStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseGlobalSearchStatus>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ResponseGlobalSearchStatus::ResponseGlobalSearchStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseGlobalSearchStatus)
}
ResponseGlobalSearchStatus::ResponseGlobalSearchStatus(const ResponseGlobalSearchStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseGlobalSearchStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.query_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.query_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_query()) {
    _this->_impl_.query_.Set(from._internal_query(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseGlobalSearchStatus)
}

inline void ResponseGlobalSearchStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.query_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.status_){1}
  };
  _impl_.query_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.query_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseGlobalSearchStatus::~ResponseGlobalSearchStatus() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseGlobalSearchStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseGlobalSearchStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.query_.Destroy();
}

void ResponseGlobalSearchStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseGlobalSearchStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseGlobalSearchStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.query_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.id_ = 0;
    _impl_.status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseGlobalSearchStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_query();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.ResponseGlobalSearchStatus.query");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.GlobalSearchStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::GlobalSearchStatus_IsValid(val))) {
            _internal_set_status(static_cast<::cpb::remote::GlobalSearchStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseGlobalSearchStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseGlobalSearchStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string query = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_query().data(), static_cast<int>(this->_internal_query().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.ResponseGlobalSearchStatus.query");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_query(), target);
  }

  // optional .cpb.remote.GlobalSearchStatus status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseGlobalSearchStatus)
  return target;
}

size_t ResponseGlobalSearchStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseGlobalSearchStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string query = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_query());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // optional .cpb.remote.GlobalSearchStatus status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseGlobalSearchStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseGlobalSearchStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseGlobalSearchStatus::GetClassData() const { return &_class_data_; }


void ResponseGlobalSearchStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseGlobalSearchStatus*>(&to_msg);
  auto& from = static_cast<const ResponseGlobalSearchStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseGlobalSearchStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_query(from._internal_query());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseGlobalSearchStatus::CopyFrom(const ResponseGlobalSearchStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseGlobalSearchStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGlobalSearchStatus::IsInitialized() const {
  return true;
}

void ResponseGlobalSearchStatus::InternalSwap(ResponseGlobalSearchStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.query_, lhs_arena,
      &other->_impl_.query_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseGlobalSearchStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[34]);
}

// ===================================================================

class RequestListFiles::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestListFiles>()._impl_._has_bits_);
  static void set_has_relative_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RequestListFiles::RequestListFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestListFiles)
}
RequestListFiles::RequestListFiles(const RequestListFiles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestListFiles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relative_path_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relative_path()) {
    _this->_impl_.relative_path_.Set(from._internal_relative_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestListFiles)
}

inline void RequestListFiles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.relative_path_){}
  };
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestListFiles::~RequestListFiles() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestListFiles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestListFiles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.relative_path_.Destroy();
}

void RequestListFiles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestListFiles::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestListFiles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.relative_path_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestListFiles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string relative_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_relative_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestListFiles.relative_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestListFiles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestListFiles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string relative_path = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_relative_path().data(), static_cast<int>(this->_internal_relative_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestListFiles.relative_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_relative_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestListFiles)
  return target;
}

size_t RequestListFiles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestListFiles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string relative_path = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_relative_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestListFiles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestListFiles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestListFiles::GetClassData() const { return &_class_data_; }


void RequestListFiles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestListFiles*>(&to_msg);
  auto& from = static_cast<const RequestListFiles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestListFiles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_relative_path()) {
    _this->_internal_set_relative_path(from._internal_relative_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestListFiles::CopyFrom(const RequestListFiles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestListFiles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestListFiles::IsInitialized() const {
  return true;
}

void RequestListFiles::InternalSwap(RequestListFiles* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relative_path_, lhs_arena,
      &other->_impl_.relative_path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestListFiles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[35]);
}

// ===================================================================

class FileMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<FileMetadata>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FileMetadata::FileMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.FileMetadata)
}
FileMetadata::FileMetadata(const FileMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FileMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.is_dir_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.is_dir_ = from._impl_.is_dir_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.FileMetadata)
}

inline void FileMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.is_dir_){false}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileMetadata::~FileMetadata() {
  // @@protoc_insertion_point(destructor:cpb.remote.FileMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void FileMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.FileMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  _impl_.is_dir_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.FileMetadata.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_dir(&has_bits);
          _impl_.is_dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.FileMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.FileMetadata.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional bool is_dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_dir(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.FileMetadata)
  return target;
}

size_t FileMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.FileMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional bool is_dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FileMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileMetadata::GetClassData() const { return &_class_data_; }


void FileMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FileMetadata*>(&to_msg);
  auto& from = static_cast<const FileMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.FileMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_dir_ = from._impl_.is_dir_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileMetadata::CopyFrom(const FileMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.FileMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileMetadata::IsInitialized() const {
  return true;
}

void FileMetadata::InternalSwap(FileMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  swap(_impl_.is_dir_, other->_impl_.is_dir_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[36]);
}

// ===================================================================

class ResponseListFiles::_Internal {
 public:
  using HasBits = decltype(std::declval<ResponseListFiles>()._impl_._has_bits_);
  static void set_has_relative_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ResponseListFiles::ResponseListFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseListFiles)
}
ResponseListFiles::ResponseListFiles(const ResponseListFiles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseListFiles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.files_){from._impl_.files_}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relative_path()) {
    _this->_impl_.relative_path_.Set(from._internal_relative_path(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.error_ = from._impl_.error_;
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseListFiles)
}

inline void ResponseListFiles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.files_){arena}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.error_){0}
  };
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseListFiles::~ResponseListFiles() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseListFiles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseListFiles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.files_.~RepeatedPtrField();
  _impl_.relative_path_.Destroy();
}

void ResponseListFiles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseListFiles::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseListFiles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.files_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.relative_path_.ClearNonDefaultToEmpty();
  }
  _impl_.error_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseListFiles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string relative_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_relative_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.ResponseListFiles.relative_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .cpb.remote.FileMetadata files = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_files(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseListFiles.Error error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::ResponseListFiles_Error_IsValid(val))) {
            _internal_set_error(static_cast<::cpb::remote::ResponseListFiles_Error>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseListFiles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseListFiles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string relative_path = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_relative_path().data(), static_cast<int>(this->_internal_relative_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.ResponseListFiles.relative_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_relative_path(), target);
  }

  // repeated .cpb.remote.FileMetadata files = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_files_size()); i < n; i++) {
    const auto& repfield = this->_internal_files(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseListFiles.Error error = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseListFiles)
  return target;
}

size_t ResponseListFiles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseListFiles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cpb.remote.FileMetadata files = 2;
  total_size += 1UL * this->_internal_files_size();
  for (const auto& msg : this->_impl_.files_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string relative_path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_relative_path());
    }

    // optional .cpb.remote.ResponseListFiles.Error error = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseListFiles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseListFiles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseListFiles::GetClassData() const { return &_class_data_; }


void ResponseListFiles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseListFiles*>(&to_msg);
  auto& from = static_cast<const ResponseListFiles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseListFiles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.files_.MergeFrom(from._impl_.files_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_relative_path(from._internal_relative_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseListFiles::CopyFrom(const ResponseListFiles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseListFiles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseListFiles::IsInitialized() const {
  return true;
}

void ResponseListFiles::InternalSwap(ResponseListFiles* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.files_.InternalSwap(&other->_impl_.files_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relative_path_, lhs_arena,
      &other->_impl_.relative_path_, rhs_arena
  );
  swap(_impl_.error_, other->_impl_.error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseListFiles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[37]);
}

// ===================================================================

class RequestAppendFiles::_Internal {
 public:
  using HasBits = decltype(std::declval<RequestAppendFiles>()._impl_._has_bits_);
  static void set_has_playlist_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_new_playlist_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_relative_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_play_now(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_clear_first(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

RequestAppendFiles::RequestAppendFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.RequestAppendFiles)
}
RequestAppendFiles::RequestAppendFiles(const RequestAppendFiles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestAppendFiles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.files_){from._impl_.files_}
    , decltype(_impl_.new_playlist_name_){}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.playlist_id_){}
    , decltype(_impl_.play_now_){}
    , decltype(_impl_.clear_first_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.new_playlist_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_playlist_name()) {
    _this->_impl_.new_playlist_name_.Set(from._internal_new_playlist_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relative_path()) {
    _this->_impl_.relative_path_.Set(from._internal_relative_path(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.playlist_id_, &from._impl_.playlist_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clear_first_) -
    reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.clear_first_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.RequestAppendFiles)
}

inline void RequestAppendFiles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.files_){arena}
    , decltype(_impl_.new_playlist_name_){}
    , decltype(_impl_.relative_path_){}
    , decltype(_impl_.playlist_id_){0}
    , decltype(_impl_.play_now_){false}
    , decltype(_impl_.clear_first_){false}
  };
  _impl_.new_playlist_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.relative_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestAppendFiles::~RequestAppendFiles() {
  // @@protoc_insertion_point(destructor:cpb.remote.RequestAppendFiles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestAppendFiles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.files_.~RepeatedPtrField();
  _impl_.new_playlist_name_.Destroy();
  _impl_.relative_path_.Destroy();
}

void RequestAppendFiles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestAppendFiles::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.RequestAppendFiles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.files_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.new_playlist_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.relative_path_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.playlist_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clear_first_) -
        reinterpret_cast<char*>(&_impl_.playlist_id_)) + sizeof(_impl_.clear_first_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestAppendFiles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 playlist_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_playlist_id(&has_bits);
          _impl_.playlist_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string new_playlist_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_playlist_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestAppendFiles.new_playlist_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string relative_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_relative_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.RequestAppendFiles.relative_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string files = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_files();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "cpb.remote.RequestAppendFiles.files");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool play_now = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_play_now(&has_bits);
          _impl_.play_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clear_first = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_clear_first(&has_bits);
          _impl_.clear_first_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestAppendFiles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.RequestAppendFiles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 playlist_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playlist_id(), target);
  }

  // optional string new_playlist_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_new_playlist_name().data(), static_cast<int>(this->_internal_new_playlist_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestAppendFiles.new_playlist_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_playlist_name(), target);
  }

  // optional string relative_path = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_relative_path().data(), static_cast<int>(this->_internal_relative_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestAppendFiles.relative_path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_relative_path(), target);
  }

  // repeated string files = 4;
  for (int i = 0, n = this->_internal_files_size(); i < n; i++) {
    const auto& s = this->_internal_files(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.RequestAppendFiles.files");
    target = stream->WriteString(4, s, target);
  }

  // optional bool play_now = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_play_now(), target);
  }

  // optional bool clear_first = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_clear_first(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.RequestAppendFiles)
  return target;
}

size_t RequestAppendFiles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.RequestAppendFiles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string files = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.files_.size());
  for (int i = 0, n = _impl_.files_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.files_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string new_playlist_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_playlist_name());
    }

    // optional string relative_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_relative_path());
    }

    // optional int32 playlist_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playlist_id());
    }

    // optional bool play_now = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool clear_first = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestAppendFiles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestAppendFiles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestAppendFiles::GetClassData() const { return &_class_data_; }


void RequestAppendFiles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestAppendFiles*>(&to_msg);
  auto& from = static_cast<const RequestAppendFiles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.RequestAppendFiles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.files_.MergeFrom(from._impl_.files_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_playlist_name(from._internal_new_playlist_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_relative_path(from._internal_relative_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.playlist_id_ = from._impl_.playlist_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.play_now_ = from._impl_.play_now_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.clear_first_ = from._impl_.clear_first_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestAppendFiles::CopyFrom(const RequestAppendFiles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.RequestAppendFiles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAppendFiles::IsInitialized() const {
  return true;
}

void RequestAppendFiles::InternalSwap(RequestAppendFiles* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.files_.InternalSwap(&other->_impl_.files_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_playlist_name_, lhs_arena,
      &other->_impl_.new_playlist_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.relative_path_, lhs_arena,
      &other->_impl_.relative_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestAppendFiles, _impl_.clear_first_)
      + sizeof(RequestAppendFiles::_impl_.clear_first_)
      - PROTOBUF_FIELD_OFFSET(RequestAppendFiles, _impl_.playlist_id_)>(
          reinterpret_cast<char*>(&_impl_.playlist_id_),
          reinterpret_cast<char*>(&other->_impl_.playlist_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestAppendFiles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[38]);
}

// ===================================================================

class Stream::_Internal {
 public:
  using HasBits = decltype(std::declval<Stream>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_url_logo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Stream::Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.Stream)
}
Stream::Stream(const Stream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stream* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.url_logo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_logo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_logo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url_logo()) {
    _this->_impl_.url_logo_.Set(from._internal_url_logo(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:cpb.remote.Stream)
}

inline void Stream::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.url_logo_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_logo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_logo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Stream::~Stream() {
  // @@protoc_insertion_point(destructor:cpb.remote.Stream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.url_.Destroy();
  _impl_.url_logo_.Destroy();
}

void Stream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stream::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.Stream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.url_logo_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Stream.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Stream.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string url_logo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url_logo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "cpb.remote.Stream.url_logo");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.Stream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Stream.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Stream.url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // optional string url_logo = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url_logo().data(), static_cast<int>(this->_internal_url_logo().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "cpb.remote.Stream.url_logo");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url_logo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.Stream)
  return target;
}

size_t Stream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.Stream)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string url_logo = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url_logo());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stream::GetClassData() const { return &_class_data_; }


void Stream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stream*>(&to_msg);
  auto& from = static_cast<const Stream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.Stream)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_url_logo(from._internal_url_logo());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stream::CopyFrom(const Stream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.Stream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream::IsInitialized() const {
  return true;
}

void Stream::InternalSwap(Stream* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_logo_, lhs_arena,
      &other->_impl_.url_logo_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Stream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[39]);
}

// ===================================================================

class ResponseSavedRadios::_Internal {
 public:
};

ResponseSavedRadios::ResponseSavedRadios(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.ResponseSavedRadios)
}
ResponseSavedRadios::ResponseSavedRadios(const ResponseSavedRadios& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseSavedRadios* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.streams_){from._impl_.streams_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:cpb.remote.ResponseSavedRadios)
}

inline void ResponseSavedRadios::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.streams_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponseSavedRadios::~ResponseSavedRadios() {
  // @@protoc_insertion_point(destructor:cpb.remote.ResponseSavedRadios)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseSavedRadios::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.streams_.~RepeatedPtrField();
}

void ResponseSavedRadios::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseSavedRadios::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.ResponseSavedRadios)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.streams_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseSavedRadios::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .cpb.remote.Stream streams = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_streams(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseSavedRadios::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.ResponseSavedRadios)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .cpb.remote.Stream streams = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_streams_size()); i < n; i++) {
    const auto& repfield = this->_internal_streams(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.ResponseSavedRadios)
  return target;
}

size_t ResponseSavedRadios::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.ResponseSavedRadios)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .cpb.remote.Stream streams = 1;
  total_size += 1UL * this->_internal_streams_size();
  for (const auto& msg : this->_impl_.streams_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseSavedRadios::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseSavedRadios::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseSavedRadios::GetClassData() const { return &_class_data_; }


void ResponseSavedRadios::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseSavedRadios*>(&to_msg);
  auto& from = static_cast<const ResponseSavedRadios&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.ResponseSavedRadios)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.streams_.MergeFrom(from._impl_.streams_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseSavedRadios::CopyFrom(const ResponseSavedRadios& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.ResponseSavedRadios)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseSavedRadios::IsInitialized() const {
  return true;
}

void ResponseSavedRadios::InternalSwap(ResponseSavedRadios* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.streams_.InternalSwap(&other->_impl_.streams_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseSavedRadios::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[40]);
}

// ===================================================================

class Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Message>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::cpb::remote::RequestConnect& request_connect(const Message* msg);
  static void set_has_request_connect(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::cpb::remote::RequestPlaylists& request_playlists(const Message* msg);
  static void set_has_request_playlists(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::cpb::remote::RequestPlaylistSongs& request_playlist_songs(const Message* msg);
  static void set_has_request_playlist_songs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::cpb::remote::RequestChangeSong& request_change_song(const Message* msg);
  static void set_has_request_change_song(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::cpb::remote::RequestSetVolume& request_set_volume(const Message* msg);
  static void set_has_request_set_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::cpb::remote::RequestSetTrackPosition& request_set_track_position(const Message* msg);
  static void set_has_request_set_track_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::cpb::remote::RequestInsertUrls& request_insert_urls(const Message* msg);
  static void set_has_request_insert_urls(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::cpb::remote::RequestRemoveSongs& request_remove_songs(const Message* msg);
  static void set_has_request_remove_songs(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::cpb::remote::RequestOpenPlaylist& request_open_playlist(const Message* msg);
  static void set_has_request_open_playlist(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::cpb::remote::RequestClosePlaylist& request_close_playlist(const Message* msg);
  static void set_has_request_close_playlist(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::cpb::remote::RequestUpdatePlaylist& request_update_playlist(const Message* msg);
  static void set_has_request_update_playlist(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::cpb::remote::RequestDownloadSongs& request_download_songs(const Message* msg);
  static void set_has_request_download_songs(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::cpb::remote::RequestRateSong& request_rate_song(const Message* msg);
  static void set_has_request_rate_song(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::cpb::remote::RequestGlobalSearch& request_global_search(const Message* msg);
  static void set_has_request_global_search(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::cpb::remote::RequestListFiles& request_list_files(const Message* msg);
  static void set_has_request_list_files(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::cpb::remote::RequestAppendFiles& request_append_files(const Message* msg);
  static void set_has_request_append_files(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::cpb::remote::Repeat& repeat(const Message* msg);
  static void set_has_repeat(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::cpb::remote::Shuffle& shuffle(const Message* msg);
  static void set_has_shuffle(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::cpb::remote::ResponseClementineInfo& response_clementine_info(const Message* msg);
  static void set_has_response_clementine_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::cpb::remote::ResponseCurrentMetadata& response_current_metadata(const Message* msg);
  static void set_has_response_current_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::cpb::remote::ResponsePlaylists& response_playlists(const Message* msg);
  static void set_has_response_playlists(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::cpb::remote::ResponsePlaylistSongs& response_playlist_songs(const Message* msg);
  static void set_has_response_playlist_songs(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::cpb::remote::ResponseEngineStateChanged& response_engine_state_changed(const Message* msg);
  static void set_has_response_engine_state_changed(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::cpb::remote::ResponseUpdateTrackPosition& response_update_track_position(const Message* msg);
  static void set_has_response_update_track_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::cpb::remote::ResponseDisconnect& response_disconnect(const Message* msg);
  static void set_has_response_disconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::cpb::remote::ResponseActiveChanged& response_active_changed(const Message* msg);
  static void set_has_response_active_changed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::cpb::remote::ResponseLyrics& response_lyrics(const Message* msg);
  static void set_has_response_lyrics(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::cpb::remote::ResponseSongFileChunk& response_song_file_chunk(const Message* msg);
  static void set_has_response_song_file_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::cpb::remote::ResponseSongOffer& response_song_offer(const Message* msg);
  static void set_has_response_song_offer(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::cpb::remote::ResponseLibraryChunk& response_library_chunk(const Message* msg);
  static void set_has_response_library_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::cpb::remote::ResponseDownloadTotalSize& response_download_total_size(const Message* msg);
  static void set_has_response_download_total_size(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::cpb::remote::ResponseGlobalSearch& response_global_search(const Message* msg);
  static void set_has_response_global_search(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::cpb::remote::ResponseTranscoderStatus& response_transcoder_status(const Message* msg);
  static void set_has_response_transcoder_status(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::cpb::remote::ResponseGlobalSearchStatus& response_global_search_status(const Message* msg);
  static void set_has_response_global_search_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::cpb::remote::ResponseListFiles& response_list_files(const Message* msg);
  static void set_has_response_list_files(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::cpb::remote::ResponseSavedRadios& response_saved_radios(const Message* msg);
  static void set_has_response_saved_radios(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
};

const ::cpb::remote::RequestConnect&
Message::_Internal::request_connect(const Message* msg) {
  return *msg->_impl_.request_connect_;
}
const ::cpb::remote::RequestPlaylists&
Message::_Internal::request_playlists(const Message* msg) {
  return *msg->_impl_.request_playlists_;
}
const ::cpb::remote::RequestPlaylistSongs&
Message::_Internal::request_playlist_songs(const Message* msg) {
  return *msg->_impl_.request_playlist_songs_;
}
const ::cpb::remote::RequestChangeSong&
Message::_Internal::request_change_song(const Message* msg) {
  return *msg->_impl_.request_change_song_;
}
const ::cpb::remote::RequestSetVolume&
Message::_Internal::request_set_volume(const Message* msg) {
  return *msg->_impl_.request_set_volume_;
}
const ::cpb::remote::RequestSetTrackPosition&
Message::_Internal::request_set_track_position(const Message* msg) {
  return *msg->_impl_.request_set_track_position_;
}
const ::cpb::remote::RequestInsertUrls&
Message::_Internal::request_insert_urls(const Message* msg) {
  return *msg->_impl_.request_insert_urls_;
}
const ::cpb::remote::RequestRemoveSongs&
Message::_Internal::request_remove_songs(const Message* msg) {
  return *msg->_impl_.request_remove_songs_;
}
const ::cpb::remote::RequestOpenPlaylist&
Message::_Internal::request_open_playlist(const Message* msg) {
  return *msg->_impl_.request_open_playlist_;
}
const ::cpb::remote::RequestClosePlaylist&
Message::_Internal::request_close_playlist(const Message* msg) {
  return *msg->_impl_.request_close_playlist_;
}
const ::cpb::remote::RequestUpdatePlaylist&
Message::_Internal::request_update_playlist(const Message* msg) {
  return *msg->_impl_.request_update_playlist_;
}
const ::cpb::remote::RequestDownloadSongs&
Message::_Internal::request_download_songs(const Message* msg) {
  return *msg->_impl_.request_download_songs_;
}
const ::cpb::remote::RequestRateSong&
Message::_Internal::request_rate_song(const Message* msg) {
  return *msg->_impl_.request_rate_song_;
}
const ::cpb::remote::RequestGlobalSearch&
Message::_Internal::request_global_search(const Message* msg) {
  return *msg->_impl_.request_global_search_;
}
const ::cpb::remote::RequestListFiles&
Message::_Internal::request_list_files(const Message* msg) {
  return *msg->_impl_.request_list_files_;
}
const ::cpb::remote::RequestAppendFiles&
Message::_Internal::request_append_files(const Message* msg) {
  return *msg->_impl_.request_append_files_;
}
const ::cpb::remote::Repeat&
Message::_Internal::repeat(const Message* msg) {
  return *msg->_impl_.repeat_;
}
const ::cpb::remote::Shuffle&
Message::_Internal::shuffle(const Message* msg) {
  return *msg->_impl_.shuffle_;
}
const ::cpb::remote::ResponseClementineInfo&
Message::_Internal::response_clementine_info(const Message* msg) {
  return *msg->_impl_.response_clementine_info_;
}
const ::cpb::remote::ResponseCurrentMetadata&
Message::_Internal::response_current_metadata(const Message* msg) {
  return *msg->_impl_.response_current_metadata_;
}
const ::cpb::remote::ResponsePlaylists&
Message::_Internal::response_playlists(const Message* msg) {
  return *msg->_impl_.response_playlists_;
}
const ::cpb::remote::ResponsePlaylistSongs&
Message::_Internal::response_playlist_songs(const Message* msg) {
  return *msg->_impl_.response_playlist_songs_;
}
const ::cpb::remote::ResponseEngineStateChanged&
Message::_Internal::response_engine_state_changed(const Message* msg) {
  return *msg->_impl_.response_engine_state_changed_;
}
const ::cpb::remote::ResponseUpdateTrackPosition&
Message::_Internal::response_update_track_position(const Message* msg) {
  return *msg->_impl_.response_update_track_position_;
}
const ::cpb::remote::ResponseDisconnect&
Message::_Internal::response_disconnect(const Message* msg) {
  return *msg->_impl_.response_disconnect_;
}
const ::cpb::remote::ResponseActiveChanged&
Message::_Internal::response_active_changed(const Message* msg) {
  return *msg->_impl_.response_active_changed_;
}
const ::cpb::remote::ResponseLyrics&
Message::_Internal::response_lyrics(const Message* msg) {
  return *msg->_impl_.response_lyrics_;
}
const ::cpb::remote::ResponseSongFileChunk&
Message::_Internal::response_song_file_chunk(const Message* msg) {
  return *msg->_impl_.response_song_file_chunk_;
}
const ::cpb::remote::ResponseSongOffer&
Message::_Internal::response_song_offer(const Message* msg) {
  return *msg->_impl_.response_song_offer_;
}
const ::cpb::remote::ResponseLibraryChunk&
Message::_Internal::response_library_chunk(const Message* msg) {
  return *msg->_impl_.response_library_chunk_;
}
const ::cpb::remote::ResponseDownloadTotalSize&
Message::_Internal::response_download_total_size(const Message* msg) {
  return *msg->_impl_.response_download_total_size_;
}
const ::cpb::remote::ResponseGlobalSearch&
Message::_Internal::response_global_search(const Message* msg) {
  return *msg->_impl_.response_global_search_;
}
const ::cpb::remote::ResponseTranscoderStatus&
Message::_Internal::response_transcoder_status(const Message* msg) {
  return *msg->_impl_.response_transcoder_status_;
}
const ::cpb::remote::ResponseGlobalSearchStatus&
Message::_Internal::response_global_search_status(const Message* msg) {
  return *msg->_impl_.response_global_search_status_;
}
const ::cpb::remote::ResponseListFiles&
Message::_Internal::response_list_files(const Message* msg) {
  return *msg->_impl_.response_list_files_;
}
const ::cpb::remote::ResponseSavedRadios&
Message::_Internal::response_saved_radios(const Message* msg) {
  return *msg->_impl_.response_saved_radios_;
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:cpb.remote.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.request_playlist_songs_){nullptr}
    , decltype(_impl_.request_change_song_){nullptr}
    , decltype(_impl_.request_set_volume_){nullptr}
    , decltype(_impl_.repeat_){nullptr}
    , decltype(_impl_.shuffle_){nullptr}
    , decltype(_impl_.response_clementine_info_){nullptr}
    , decltype(_impl_.response_current_metadata_){nullptr}
    , decltype(_impl_.response_playlists_){nullptr}
    , decltype(_impl_.response_playlist_songs_){nullptr}
    , decltype(_impl_.response_engine_state_changed_){nullptr}
    , decltype(_impl_.response_update_track_position_){nullptr}
    , decltype(_impl_.request_connect_){nullptr}
    , decltype(_impl_.response_disconnect_){nullptr}
    , decltype(_impl_.request_set_track_position_){nullptr}
    , decltype(_impl_.response_active_changed_){nullptr}
    , decltype(_impl_.request_insert_urls_){nullptr}
    , decltype(_impl_.request_remove_songs_){nullptr}
    , decltype(_impl_.request_playlists_){nullptr}
    , decltype(_impl_.request_open_playlist_){nullptr}
    , decltype(_impl_.request_close_playlist_){nullptr}
    , decltype(_impl_.response_lyrics_){nullptr}
    , decltype(_impl_.request_download_songs_){nullptr}
    , decltype(_impl_.response_song_file_chunk_){nullptr}
    , decltype(_impl_.response_song_offer_){nullptr}
    , decltype(_impl_.response_library_chunk_){nullptr}
    , decltype(_impl_.request_rate_song_){nullptr}
    , decltype(_impl_.response_download_total_size_){nullptr}
    , decltype(_impl_.request_global_search_){nullptr}
    , decltype(_impl_.response_global_search_){nullptr}
    , decltype(_impl_.response_transcoder_status_){nullptr}
    , decltype(_impl_.response_global_search_status_){nullptr}
    , decltype(_impl_.request_list_files_){nullptr}
    , decltype(_impl_.request_append_files_){nullptr}
    , decltype(_impl_.response_list_files_){nullptr}
    , decltype(_impl_.request_update_playlist_){nullptr}
    , decltype(_impl_.response_saved_radios_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_request_playlist_songs()) {
    _this->_impl_.request_playlist_songs_ = new ::cpb::remote::RequestPlaylistSongs(*from._impl_.request_playlist_songs_);
  }
  if (from._internal_has_request_change_song()) {
    _this->_impl_.request_change_song_ = new ::cpb::remote::RequestChangeSong(*from._impl_.request_change_song_);
  }
  if (from._internal_has_request_set_volume()) {
    _this->_impl_.request_set_volume_ = new ::cpb::remote::RequestSetVolume(*from._impl_.request_set_volume_);
  }
  if (from._internal_has_repeat()) {
    _this->_impl_.repeat_ = new ::cpb::remote::Repeat(*from._impl_.repeat_);
  }
  if (from._internal_has_shuffle()) {
    _this->_impl_.shuffle_ = new ::cpb::remote::Shuffle(*from._impl_.shuffle_);
  }
  if (from._internal_has_response_clementine_info()) {
    _this->_impl_.response_clementine_info_ = new ::cpb::remote::ResponseClementineInfo(*from._impl_.response_clementine_info_);
  }
  if (from._internal_has_response_current_metadata()) {
    _this->_impl_.response_current_metadata_ = new ::cpb::remote::ResponseCurrentMetadata(*from._impl_.response_current_metadata_);
  }
  if (from._internal_has_response_playlists()) {
    _this->_impl_.response_playlists_ = new ::cpb::remote::ResponsePlaylists(*from._impl_.response_playlists_);
  }
  if (from._internal_has_response_playlist_songs()) {
    _this->_impl_.response_playlist_songs_ = new ::cpb::remote::ResponsePlaylistSongs(*from._impl_.response_playlist_songs_);
  }
  if (from._internal_has_response_engine_state_changed()) {
    _this->_impl_.response_engine_state_changed_ = new ::cpb::remote::ResponseEngineStateChanged(*from._impl_.response_engine_state_changed_);
  }
  if (from._internal_has_response_update_track_position()) {
    _this->_impl_.response_update_track_position_ = new ::cpb::remote::ResponseUpdateTrackPosition(*from._impl_.response_update_track_position_);
  }
  if (from._internal_has_request_connect()) {
    _this->_impl_.request_connect_ = new ::cpb::remote::RequestConnect(*from._impl_.request_connect_);
  }
  if (from._internal_has_response_disconnect()) {
    _this->_impl_.response_disconnect_ = new ::cpb::remote::ResponseDisconnect(*from._impl_.response_disconnect_);
  }
  if (from._internal_has_request_set_track_position()) {
    _this->_impl_.request_set_track_position_ = new ::cpb::remote::RequestSetTrackPosition(*from._impl_.request_set_track_position_);
  }
  if (from._internal_has_response_active_changed()) {
    _this->_impl_.response_active_changed_ = new ::cpb::remote::ResponseActiveChanged(*from._impl_.response_active_changed_);
  }
  if (from._internal_has_request_insert_urls()) {
    _this->_impl_.request_insert_urls_ = new ::cpb::remote::RequestInsertUrls(*from._impl_.request_insert_urls_);
  }
  if (from._internal_has_request_remove_songs()) {
    _this->_impl_.request_remove_songs_ = new ::cpb::remote::RequestRemoveSongs(*from._impl_.request_remove_songs_);
  }
  if (from._internal_has_request_playlists()) {
    _this->_impl_.request_playlists_ = new ::cpb::remote::RequestPlaylists(*from._impl_.request_playlists_);
  }
  if (from._internal_has_request_open_playlist()) {
    _this->_impl_.request_open_playlist_ = new ::cpb::remote::RequestOpenPlaylist(*from._impl_.request_open_playlist_);
  }
  if (from._internal_has_request_close_playlist()) {
    _this->_impl_.request_close_playlist_ = new ::cpb::remote::RequestClosePlaylist(*from._impl_.request_close_playlist_);
  }
  if (from._internal_has_response_lyrics()) {
    _this->_impl_.response_lyrics_ = new ::cpb::remote::ResponseLyrics(*from._impl_.response_lyrics_);
  }
  if (from._internal_has_request_download_songs()) {
    _this->_impl_.request_download_songs_ = new ::cpb::remote::RequestDownloadSongs(*from._impl_.request_download_songs_);
  }
  if (from._internal_has_response_song_file_chunk()) {
    _this->_impl_.response_song_file_chunk_ = new ::cpb::remote::ResponseSongFileChunk(*from._impl_.response_song_file_chunk_);
  }
  if (from._internal_has_response_song_offer()) {
    _this->_impl_.response_song_offer_ = new ::cpb::remote::ResponseSongOffer(*from._impl_.response_song_offer_);
  }
  if (from._internal_has_response_library_chunk()) {
    _this->_impl_.response_library_chunk_ = new ::cpb::remote::ResponseLibraryChunk(*from._impl_.response_library_chunk_);
  }
  if (from._internal_has_request_rate_song()) {
    _this->_impl_.request_rate_song_ = new ::cpb::remote::RequestRateSong(*from._impl_.request_rate_song_);
  }
  if (from._internal_has_response_download_total_size()) {
    _this->_impl_.response_download_total_size_ = new ::cpb::remote::ResponseDownloadTotalSize(*from._impl_.response_download_total_size_);
  }
  if (from._internal_has_request_global_search()) {
    _this->_impl_.request_global_search_ = new ::cpb::remote::RequestGlobalSearch(*from._impl_.request_global_search_);
  }
  if (from._internal_has_response_global_search()) {
    _this->_impl_.response_global_search_ = new ::cpb::remote::ResponseGlobalSearch(*from._impl_.response_global_search_);
  }
  if (from._internal_has_response_transcoder_status()) {
    _this->_impl_.response_transcoder_status_ = new ::cpb::remote::ResponseTranscoderStatus(*from._impl_.response_transcoder_status_);
  }
  if (from._internal_has_response_global_search_status()) {
    _this->_impl_.response_global_search_status_ = new ::cpb::remote::ResponseGlobalSearchStatus(*from._impl_.response_global_search_status_);
  }
  if (from._internal_has_request_list_files()) {
    _this->_impl_.request_list_files_ = new ::cpb::remote::RequestListFiles(*from._impl_.request_list_files_);
  }
  if (from._internal_has_request_append_files()) {
    _this->_impl_.request_append_files_ = new ::cpb::remote::RequestAppendFiles(*from._impl_.request_append_files_);
  }
  if (from._internal_has_response_list_files()) {
    _this->_impl_.response_list_files_ = new ::cpb::remote::ResponseListFiles(*from._impl_.response_list_files_);
  }
  if (from._internal_has_request_update_playlist()) {
    _this->_impl_.request_update_playlist_ = new ::cpb::remote::RequestUpdatePlaylist(*from._impl_.request_update_playlist_);
  }
  if (from._internal_has_response_saved_radios()) {
    _this->_impl_.response_saved_radios_ = new ::cpb::remote::ResponseSavedRadios(*from._impl_.response_saved_radios_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:cpb.remote.Message)
}

inline void Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.request_playlist_songs_){nullptr}
    , decltype(_impl_.request_change_song_){nullptr}
    , decltype(_impl_.request_set_volume_){nullptr}
    , decltype(_impl_.repeat_){nullptr}
    , decltype(_impl_.shuffle_){nullptr}
    , decltype(_impl_.response_clementine_info_){nullptr}
    , decltype(_impl_.response_current_metadata_){nullptr}
    , decltype(_impl_.response_playlists_){nullptr}
    , decltype(_impl_.response_playlist_songs_){nullptr}
    , decltype(_impl_.response_engine_state_changed_){nullptr}
    , decltype(_impl_.response_update_track_position_){nullptr}
    , decltype(_impl_.request_connect_){nullptr}
    , decltype(_impl_.response_disconnect_){nullptr}
    , decltype(_impl_.request_set_track_position_){nullptr}
    , decltype(_impl_.response_active_changed_){nullptr}
    , decltype(_impl_.request_insert_urls_){nullptr}
    , decltype(_impl_.request_remove_songs_){nullptr}
    , decltype(_impl_.request_playlists_){nullptr}
    , decltype(_impl_.request_open_playlist_){nullptr}
    , decltype(_impl_.request_close_playlist_){nullptr}
    , decltype(_impl_.response_lyrics_){nullptr}
    , decltype(_impl_.request_download_songs_){nullptr}
    , decltype(_impl_.response_song_file_chunk_){nullptr}
    , decltype(_impl_.response_song_offer_){nullptr}
    , decltype(_impl_.response_library_chunk_){nullptr}
    , decltype(_impl_.request_rate_song_){nullptr}
    , decltype(_impl_.response_download_total_size_){nullptr}
    , decltype(_impl_.request_global_search_){nullptr}
    , decltype(_impl_.response_global_search_){nullptr}
    , decltype(_impl_.response_transcoder_status_){nullptr}
    , decltype(_impl_.response_global_search_status_){nullptr}
    , decltype(_impl_.request_list_files_){nullptr}
    , decltype(_impl_.request_append_files_){nullptr}
    , decltype(_impl_.response_list_files_){nullptr}
    , decltype(_impl_.request_update_playlist_){nullptr}
    , decltype(_impl_.response_saved_radios_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.version_){21}
  };
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:cpb.remote.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.request_playlist_songs_;
  if (this != internal_default_instance()) delete _impl_.request_change_song_;
  if (this != internal_default_instance()) delete _impl_.request_set_volume_;
  if (this != internal_default_instance()) delete _impl_.repeat_;
  if (this != internal_default_instance()) delete _impl_.shuffle_;
  if (this != internal_default_instance()) delete _impl_.response_clementine_info_;
  if (this != internal_default_instance()) delete _impl_.response_current_metadata_;
  if (this != internal_default_instance()) delete _impl_.response_playlists_;
  if (this != internal_default_instance()) delete _impl_.response_playlist_songs_;
  if (this != internal_default_instance()) delete _impl_.response_engine_state_changed_;
  if (this != internal_default_instance()) delete _impl_.response_update_track_position_;
  if (this != internal_default_instance()) delete _impl_.request_connect_;
  if (this != internal_default_instance()) delete _impl_.response_disconnect_;
  if (this != internal_default_instance()) delete _impl_.request_set_track_position_;
  if (this != internal_default_instance()) delete _impl_.response_active_changed_;
  if (this != internal_default_instance()) delete _impl_.request_insert_urls_;
  if (this != internal_default_instance()) delete _impl_.request_remove_songs_;
  if (this != internal_default_instance()) delete _impl_.request_playlists_;
  if (this != internal_default_instance()) delete _impl_.request_open_playlist_;
  if (this != internal_default_instance()) delete _impl_.request_close_playlist_;
  if (this != internal_default_instance()) delete _impl_.response_lyrics_;
  if (this != internal_default_instance()) delete _impl_.request_download_songs_;
  if (this != internal_default_instance()) delete _impl_.response_song_file_chunk_;
  if (this != internal_default_instance()) delete _impl_.response_song_offer_;
  if (this != internal_default_instance()) delete _impl_.response_library_chunk_;
  if (this != internal_default_instance()) delete _impl_.request_rate_song_;
  if (this != internal_default_instance()) delete _impl_.response_download_total_size_;
  if (this != internal_default_instance()) delete _impl_.request_global_search_;
  if (this != internal_default_instance()) delete _impl_.response_global_search_;
  if (this != internal_default_instance()) delete _impl_.response_transcoder_status_;
  if (this != internal_default_instance()) delete _impl_.response_global_search_status_;
  if (this != internal_default_instance()) delete _impl_.request_list_files_;
  if (this != internal_default_instance()) delete _impl_.request_append_files_;
  if (this != internal_default_instance()) delete _impl_.response_list_files_;
  if (this != internal_default_instance()) delete _impl_.request_update_playlist_;
  if (this != internal_default_instance()) delete _impl_.response_saved_radios_;
}

void Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:cpb.remote.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.request_playlist_songs_ != nullptr);
      _impl_.request_playlist_songs_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.request_change_song_ != nullptr);
      _impl_.request_change_song_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.request_set_volume_ != nullptr);
      _impl_.request_set_volume_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.repeat_ != nullptr);
      _impl_.repeat_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.shuffle_ != nullptr);
      _impl_.shuffle_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.response_clementine_info_ != nullptr);
      _impl_.response_clementine_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.response_current_metadata_ != nullptr);
      _impl_.response_current_metadata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.response_playlists_ != nullptr);
      _impl_.response_playlists_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.response_playlist_songs_ != nullptr);
      _impl_.response_playlist_songs_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.response_engine_state_changed_ != nullptr);
      _impl_.response_engine_state_changed_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.response_update_track_position_ != nullptr);
      _impl_.response_update_track_position_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.request_connect_ != nullptr);
      _impl_.request_connect_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.response_disconnect_ != nullptr);
      _impl_.response_disconnect_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.request_set_track_position_ != nullptr);
      _impl_.request_set_track_position_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.response_active_changed_ != nullptr);
      _impl_.response_active_changed_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.request_insert_urls_ != nullptr);
      _impl_.request_insert_urls_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.request_remove_songs_ != nullptr);
      _impl_.request_remove_songs_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.request_playlists_ != nullptr);
      _impl_.request_playlists_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.request_open_playlist_ != nullptr);
      _impl_.request_open_playlist_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.request_close_playlist_ != nullptr);
      _impl_.request_close_playlist_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.response_lyrics_ != nullptr);
      _impl_.response_lyrics_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(_impl_.request_download_songs_ != nullptr);
      _impl_.request_download_songs_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(_impl_.response_song_file_chunk_ != nullptr);
      _impl_.response_song_file_chunk_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(_impl_.response_song_offer_ != nullptr);
      _impl_.response_song_offer_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(_impl_.response_library_chunk_ != nullptr);
      _impl_.response_library_chunk_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(_impl_.request_rate_song_ != nullptr);
      _impl_.request_rate_song_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(_impl_.response_download_total_size_ != nullptr);
      _impl_.response_download_total_size_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(_impl_.request_global_search_ != nullptr);
      _impl_.request_global_search_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(_impl_.response_global_search_ != nullptr);
      _impl_.response_global_search_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(_impl_.response_transcoder_status_ != nullptr);
      _impl_.response_transcoder_status_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(_impl_.response_global_search_status_ != nullptr);
      _impl_.response_global_search_status_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(_impl_.request_list_files_ != nullptr);
      _impl_.request_list_files_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.request_append_files_ != nullptr);
      _impl_.request_append_files_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.response_list_files_ != nullptr);
      _impl_.response_list_files_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.request_update_playlist_ != nullptr);
      _impl_.request_update_playlist_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.response_saved_radios_ != nullptr);
      _impl_.response_saved_radios_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    _impl_.type_ = 0;
    _impl_.version_ = 21;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 version = 1 [default = 21];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&_impl_._has_bits_);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.MsgType type = 2 [default = UNKNOWN];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::cpb::remote::MsgType_IsValid(val))) {
            _internal_set_type(static_cast<::cpb::remote::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestPlaylistSongs request_playlist_songs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_playlist_songs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestChangeSong request_change_song = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_change_song(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestSetVolume request_set_volume = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_set_volume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.Repeat repeat = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.Shuffle shuffle = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_shuffle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseClementineInfo response_clementine_info = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_clementine_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseCurrentMetadata response_current_metadata = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_current_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponsePlaylists response_playlists = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_playlists(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponsePlaylistSongs response_playlist_songs = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_playlist_songs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseEngineStateChanged response_engine_state_changed = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_engine_state_changed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseUpdateTrackPosition response_update_track_position = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_update_track_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestConnect request_connect = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_connect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseDisconnect response_disconnect = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_disconnect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestSetTrackPosition request_set_track_position = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_set_track_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseActiveChanged response_active_changed = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_active_changed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestInsertUrls request_insert_urls = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_insert_urls(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestRemoveSongs request_remove_songs = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_remove_songs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestPlaylists request_playlists = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_playlists(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestOpenPlaylist request_open_playlist = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_open_playlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestClosePlaylist request_close_playlist = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_close_playlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseLyrics response_lyrics = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_lyrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestDownloadSongs request_download_songs = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_download_songs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseSongFileChunk response_song_file_chunk = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_song_file_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseSongOffer response_song_offer = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_song_offer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseLibraryChunk response_library_chunk = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_library_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestRateSong request_rate_song = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_rate_song(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseDownloadTotalSize response_download_total_size = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_download_total_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestGlobalSearch request_global_search = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_global_search(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseGlobalSearch response_global_search = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_global_search(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseTranscoderStatus response_transcoder_status = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_transcoder_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseGlobalSearchStatus response_global_search_status = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_global_search_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestListFiles request_list_files = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_list_files(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestAppendFiles request_append_files = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_append_files(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseListFiles response_list_files = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_list_files(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.RequestUpdatePlaylist request_update_playlist = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_update_playlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .cpb.remote.ResponseSavedRadios response_saved_radios = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_response_saved_radios(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cpb.remote.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[1];
  // optional int32 version = 1 [default = 21];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
  }

  // optional .cpb.remote.MsgType type = 2 [default = UNKNOWN];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .cpb.remote.RequestPlaylistSongs request_playlist_songs = 10;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::request_playlist_songs(this),
        _Internal::request_playlist_songs(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestChangeSong request_change_song = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::request_change_song(this),
        _Internal::request_change_song(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestSetVolume request_set_volume = 12;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::request_set_volume(this),
        _Internal::request_set_volume(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.Repeat repeat = 13;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::repeat(this),
        _Internal::repeat(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.Shuffle shuffle = 14;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::shuffle(this),
        _Internal::shuffle(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseClementineInfo response_clementine_info = 15;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::response_clementine_info(this),
        _Internal::response_clementine_info(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseCurrentMetadata response_current_metadata = 16;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::response_current_metadata(this),
        _Internal::response_current_metadata(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponsePlaylists response_playlists = 17;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::response_playlists(this),
        _Internal::response_playlists(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponsePlaylistSongs response_playlist_songs = 18;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::response_playlist_songs(this),
        _Internal::response_playlist_songs(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseEngineStateChanged response_engine_state_changed = 19;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::response_engine_state_changed(this),
        _Internal::response_engine_state_changed(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseUpdateTrackPosition response_update_track_position = 20;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::response_update_track_position(this),
        _Internal::response_update_track_position(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestConnect request_connect = 21;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::request_connect(this),
        _Internal::request_connect(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseDisconnect response_disconnect = 22;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::response_disconnect(this),
        _Internal::response_disconnect(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestSetTrackPosition request_set_track_position = 23;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::request_set_track_position(this),
        _Internal::request_set_track_position(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseActiveChanged response_active_changed = 24;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::response_active_changed(this),
        _Internal::response_active_changed(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestInsertUrls request_insert_urls = 25;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::request_insert_urls(this),
        _Internal::request_insert_urls(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestRemoveSongs request_remove_songs = 26;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::request_remove_songs(this),
        _Internal::request_remove_songs(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestPlaylists request_playlists = 27;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::request_playlists(this),
        _Internal::request_playlists(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestOpenPlaylist request_open_playlist = 28;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::request_open_playlist(this),
        _Internal::request_open_playlist(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestClosePlaylist request_close_playlist = 29;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::request_close_playlist(this),
        _Internal::request_close_playlist(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseLyrics response_lyrics = 30;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::response_lyrics(this),
        _Internal::response_lyrics(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestDownloadSongs request_download_songs = 31;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::request_download_songs(this),
        _Internal::request_download_songs(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseSongFileChunk response_song_file_chunk = 32;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::response_song_file_chunk(this),
        _Internal::response_song_file_chunk(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseSongOffer response_song_offer = 33;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::response_song_offer(this),
        _Internal::response_song_offer(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseLibraryChunk response_library_chunk = 34;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::response_library_chunk(this),
        _Internal::response_library_chunk(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestRateSong request_rate_song = 35;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::request_rate_song(this),
        _Internal::request_rate_song(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseDownloadTotalSize response_download_total_size = 36;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::response_download_total_size(this),
        _Internal::response_download_total_size(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestGlobalSearch request_global_search = 37;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::request_global_search(this),
        _Internal::request_global_search(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseGlobalSearch response_global_search = 38;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::response_global_search(this),
        _Internal::response_global_search(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseTranscoderStatus response_transcoder_status = 39;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::response_transcoder_status(this),
        _Internal::response_transcoder_status(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseGlobalSearchStatus response_global_search_status = 40;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(40, _Internal::response_global_search_status(this),
        _Internal::response_global_search_status(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestListFiles request_list_files = 50;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(50, _Internal::request_list_files(this),
        _Internal::request_list_files(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional .cpb.remote.RequestAppendFiles request_append_files = 51;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(51, _Internal::request_append_files(this),
        _Internal::request_append_files(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseListFiles response_list_files = 52;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(52, _Internal::response_list_files(this),
        _Internal::response_list_files(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.RequestUpdatePlaylist request_update_playlist = 53;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(53, _Internal::request_update_playlist(this),
        _Internal::request_update_playlist(this).GetCachedSize(), target, stream);
  }

  // optional .cpb.remote.ResponseSavedRadios response_saved_radios = 54;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(54, _Internal::response_saved_radios(this),
        _Internal::response_saved_radios(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cpb.remote.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cpb.remote.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .cpb.remote.RequestPlaylistSongs request_playlist_songs = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_playlist_songs_);
    }

    // optional .cpb.remote.RequestChangeSong request_change_song = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_change_song_);
    }

    // optional .cpb.remote.RequestSetVolume request_set_volume = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_set_volume_);
    }

    // optional .cpb.remote.Repeat repeat = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.repeat_);
    }

    // optional .cpb.remote.Shuffle shuffle = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shuffle_);
    }

    // optional .cpb.remote.ResponseClementineInfo response_clementine_info = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_clementine_info_);
    }

    // optional .cpb.remote.ResponseCurrentMetadata response_current_metadata = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_current_metadata_);
    }

    // optional .cpb.remote.ResponsePlaylists response_playlists = 17;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_playlists_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .cpb.remote.ResponsePlaylistSongs response_playlist_songs = 18;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_playlist_songs_);
    }

    // optional .cpb.remote.ResponseEngineStateChanged response_engine_state_changed = 19;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_engine_state_changed_);
    }

    // optional .cpb.remote.ResponseUpdateTrackPosition response_update_track_position = 20;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_update_track_position_);
    }

    // optional .cpb.remote.RequestConnect request_connect = 21;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_connect_);
    }

    // optional .cpb.remote.ResponseDisconnect response_disconnect = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_disconnect_);
    }

    // optional .cpb.remote.RequestSetTrackPosition request_set_track_position = 23;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_set_track_position_);
    }

    // optional .cpb.remote.ResponseActiveChanged response_active_changed = 24;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_active_changed_);
    }

    // optional .cpb.remote.RequestInsertUrls request_insert_urls = 25;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_insert_urls_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .cpb.remote.RequestRemoveSongs request_remove_songs = 26;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_remove_songs_);
    }

    // optional .cpb.remote.RequestPlaylists request_playlists = 27;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_playlists_);
    }

    // optional .cpb.remote.RequestOpenPlaylist request_open_playlist = 28;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_open_playlist_);
    }

    // optional .cpb.remote.RequestClosePlaylist request_close_playlist = 29;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_close_playlist_);
    }

    // optional .cpb.remote.ResponseLyrics response_lyrics = 30;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_lyrics_);
    }

    // optional .cpb.remote.RequestDownloadSongs request_download_songs = 31;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_download_songs_);
    }

    // optional .cpb.remote.ResponseSongFileChunk response_song_file_chunk = 32;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_song_file_chunk_);
    }

    // optional .cpb.remote.ResponseSongOffer response_song_offer = 33;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_song_offer_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .cpb.remote.ResponseLibraryChunk response_library_chunk = 34;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_library_chunk_);
    }

    // optional .cpb.remote.RequestRateSong request_rate_song = 35;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_rate_song_);
    }

    // optional .cpb.remote.ResponseDownloadTotalSize response_download_total_size = 36;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_download_total_size_);
    }

    // optional .cpb.remote.RequestGlobalSearch request_global_search = 37;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_global_search_);
    }

    // optional .cpb.remote.ResponseGlobalSearch response_global_search = 38;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_global_search_);
    }

    // optional .cpb.remote.ResponseTranscoderStatus response_transcoder_status = 39;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_transcoder_status_);
    }

    // optional .cpb.remote.ResponseGlobalSearchStatus response_global_search_status = 40;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_global_search_status_);
    }

    // optional .cpb.remote.RequestListFiles request_list_files = 50;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_list_files_);
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000003fu) {
    // optional .cpb.remote.RequestAppendFiles request_append_files = 51;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_append_files_);
    }

    // optional .cpb.remote.ResponseListFiles response_list_files = 52;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_list_files_);
    }

    // optional .cpb.remote.RequestUpdatePlaylist request_update_playlist = 53;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.request_update_playlist_);
    }

    // optional .cpb.remote.ResponseSavedRadios response_saved_radios = 54;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.response_saved_radios_);
    }

    // optional .cpb.remote.MsgType type = 2 [default = UNKNOWN];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 version = 1 [default = 21];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }


void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message*>(&to_msg);
  auto& from = static_cast<const Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cpb.remote.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_request_playlist_songs()->::cpb::remote::RequestPlaylistSongs::MergeFrom(
          from._internal_request_playlist_songs());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_request_change_song()->::cpb::remote::RequestChangeSong::MergeFrom(
          from._internal_request_change_song());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_request_set_volume()->::cpb::remote::RequestSetVolume::MergeFrom(
          from._internal_request_set_volume());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_repeat()->::cpb::remote::Repeat::MergeFrom(
          from._internal_repeat());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_shuffle()->::cpb::remote::Shuffle::MergeFrom(
          from._internal_shuffle());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_response_clementine_info()->::cpb::remote::ResponseClementineInfo::MergeFrom(
          from._internal_response_clementine_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_response_current_metadata()->::cpb::remote::ResponseCurrentMetadata::MergeFrom(
          from._internal_response_current_metadata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_response_playlists()->::cpb::remote::ResponsePlaylists::MergeFrom(
          from._internal_response_playlists());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_response_playlist_songs()->::cpb::remote::ResponsePlaylistSongs::MergeFrom(
          from._internal_response_playlist_songs());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_response_engine_state_changed()->::cpb::remote::ResponseEngineStateChanged::MergeFrom(
          from._internal_response_engine_state_changed());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_response_update_track_position()->::cpb::remote::ResponseUpdateTrackPosition::MergeFrom(
          from._internal_response_update_track_position());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_request_connect()->::cpb::remote::RequestConnect::MergeFrom(
          from._internal_request_connect());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_response_disconnect()->::cpb::remote::ResponseDisconnect::MergeFrom(
          from._internal_response_disconnect());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_request_set_track_position()->::cpb::remote::RequestSetTrackPosition::MergeFrom(
          from._internal_request_set_track_position());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_response_active_changed()->::cpb::remote::ResponseActiveChanged::MergeFrom(
          from._internal_response_active_changed());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_request_insert_urls()->::cpb::remote::RequestInsertUrls::MergeFrom(
          from._internal_request_insert_urls());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_request_remove_songs()->::cpb::remote::RequestRemoveSongs::MergeFrom(
          from._internal_request_remove_songs());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_request_playlists()->::cpb::remote::RequestPlaylists::MergeFrom(
          from._internal_request_playlists());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_request_open_playlist()->::cpb::remote::RequestOpenPlaylist::MergeFrom(
          from._internal_request_open_playlist());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_request_close_playlist()->::cpb::remote::RequestClosePlaylist::MergeFrom(
          from._internal_request_close_playlist());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_response_lyrics()->::cpb::remote::ResponseLyrics::MergeFrom(
          from._internal_response_lyrics());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_request_download_songs()->::cpb::remote::RequestDownloadSongs::MergeFrom(
          from._internal_request_download_songs());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_response_song_file_chunk()->::cpb::remote::ResponseSongFileChunk::MergeFrom(
          from._internal_response_song_file_chunk());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_response_song_offer()->::cpb::remote::ResponseSongOffer::MergeFrom(
          from._internal_response_song_offer());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_response_library_chunk()->::cpb::remote::ResponseLibraryChunk::MergeFrom(
          from._internal_response_library_chunk());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_request_rate_song()->::cpb::remote::RequestRateSong::MergeFrom(
          from._internal_request_rate_song());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_response_download_total_size()->::cpb::remote::ResponseDownloadTotalSize::MergeFrom(
          from._internal_response_download_total_size());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_request_global_search()->::cpb::remote::RequestGlobalSearch::MergeFrom(
          from._internal_request_global_search());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_response_global_search()->::cpb::remote::ResponseGlobalSearch::MergeFrom(
          from._internal_response_global_search());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_response_transcoder_status()->::cpb::remote::ResponseTranscoderStatus::MergeFrom(
          from._internal_response_transcoder_status());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_response_global_search_status()->::cpb::remote::ResponseGlobalSearchStatus::MergeFrom(
          from._internal_response_global_search_status());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_request_list_files()->::cpb::remote::RequestListFiles::MergeFrom(
          from._internal_request_list_files());
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_request_append_files()->::cpb::remote::RequestAppendFiles::MergeFrom(
          from._internal_request_append_files());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_response_list_files()->::cpb::remote::ResponseListFiles::MergeFrom(
          from._internal_response_list_files());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_request_update_playlist()->::cpb::remote::RequestUpdatePlaylist::MergeFrom(
          from._internal_request_update_playlist());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_response_saved_radios()->::cpb::remote::ResponseSavedRadios::MergeFrom(
          from._internal_response_saved_radios());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cpb.remote.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message, _impl_.type_)
      + sizeof(Message::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(Message, _impl_.request_playlist_songs_)>(
          reinterpret_cast<char*>(&_impl_.request_playlist_songs_),
          reinterpret_cast<char*>(&other->_impl_.request_playlist_songs_));
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_remotecontrolmessages_2eproto_getter, &descriptor_table_remotecontrolmessages_2eproto_once,
      file_level_metadata_remotecontrolmessages_2eproto[41]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace remote
}  // namespace cpb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::cpb::remote::SongMetadata*
Arena::CreateMaybeMessage< ::cpb::remote::SongMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::SongMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::Playlist*
Arena::CreateMaybeMessage< ::cpb::remote::Playlist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::Playlist >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestPlaylists*
Arena::CreateMaybeMessage< ::cpb::remote::RequestPlaylists >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestPlaylists >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestPlaylistSongs*
Arena::CreateMaybeMessage< ::cpb::remote::RequestPlaylistSongs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestPlaylistSongs >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestChangeSong*
Arena::CreateMaybeMessage< ::cpb::remote::RequestChangeSong >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestChangeSong >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestSetVolume*
Arena::CreateMaybeMessage< ::cpb::remote::RequestSetVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestSetVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::Repeat*
Arena::CreateMaybeMessage< ::cpb::remote::Repeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::Repeat >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::Shuffle*
Arena::CreateMaybeMessage< ::cpb::remote::Shuffle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::Shuffle >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseClementineInfo*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseClementineInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseClementineInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseCurrentMetadata*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseCurrentMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseCurrentMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponsePlaylists*
Arena::CreateMaybeMessage< ::cpb::remote::ResponsePlaylists >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponsePlaylists >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponsePlaylistSongs*
Arena::CreateMaybeMessage< ::cpb::remote::ResponsePlaylistSongs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponsePlaylistSongs >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseEngineStateChanged*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseEngineStateChanged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseEngineStateChanged >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseUpdateTrackPosition*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseUpdateTrackPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseUpdateTrackPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestConnect*
Arena::CreateMaybeMessage< ::cpb::remote::RequestConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseDisconnect*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseDisconnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseDisconnect >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseActiveChanged*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseActiveChanged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseActiveChanged >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestSetTrackPosition*
Arena::CreateMaybeMessage< ::cpb::remote::RequestSetTrackPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestSetTrackPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestInsertUrls*
Arena::CreateMaybeMessage< ::cpb::remote::RequestInsertUrls >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestInsertUrls >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestRemoveSongs*
Arena::CreateMaybeMessage< ::cpb::remote::RequestRemoveSongs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestRemoveSongs >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestOpenPlaylist*
Arena::CreateMaybeMessage< ::cpb::remote::RequestOpenPlaylist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestOpenPlaylist >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestClosePlaylist*
Arena::CreateMaybeMessage< ::cpb::remote::RequestClosePlaylist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestClosePlaylist >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestUpdatePlaylist*
Arena::CreateMaybeMessage< ::cpb::remote::RequestUpdatePlaylist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestUpdatePlaylist >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseLyrics*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseLyrics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseLyrics >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::Lyric*
Arena::CreateMaybeMessage< ::cpb::remote::Lyric >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::Lyric >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestDownloadSongs*
Arena::CreateMaybeMessage< ::cpb::remote::RequestDownloadSongs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestDownloadSongs >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseSongFileChunk*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseSongFileChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseSongFileChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseLibraryChunk*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseLibraryChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseLibraryChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseSongOffer*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseSongOffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseSongOffer >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestRateSong*
Arena::CreateMaybeMessage< ::cpb::remote::RequestRateSong >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestRateSong >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseDownloadTotalSize*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseDownloadTotalSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseDownloadTotalSize >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestGlobalSearch*
Arena::CreateMaybeMessage< ::cpb::remote::RequestGlobalSearch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestGlobalSearch >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseGlobalSearch*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseGlobalSearch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseGlobalSearch >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseTranscoderStatus*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseTranscoderStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseTranscoderStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseGlobalSearchStatus*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseGlobalSearchStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseGlobalSearchStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestListFiles*
Arena::CreateMaybeMessage< ::cpb::remote::RequestListFiles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestListFiles >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::FileMetadata*
Arena::CreateMaybeMessage< ::cpb::remote::FileMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::FileMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseListFiles*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseListFiles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseListFiles >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::RequestAppendFiles*
Arena::CreateMaybeMessage< ::cpb::remote::RequestAppendFiles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::RequestAppendFiles >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::Stream*
Arena::CreateMaybeMessage< ::cpb::remote::Stream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::Stream >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::ResponseSavedRadios*
Arena::CreateMaybeMessage< ::cpb::remote::ResponseSavedRadios >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::ResponseSavedRadios >(arena);
}
template<> PROTOBUF_NOINLINE ::cpb::remote::Message*
Arena::CreateMaybeMessage< ::cpb::remote::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cpb::remote::Message >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
