// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remotecontrolmessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remotecontrolmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remotecontrolmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remotecontrolmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remotecontrolmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_remotecontrolmessages_2eproto;
namespace cpb {
namespace remote {
class FileMetadata;
struct FileMetadataDefaultTypeInternal;
extern FileMetadataDefaultTypeInternal _FileMetadata_default_instance_;
class Lyric;
struct LyricDefaultTypeInternal;
extern LyricDefaultTypeInternal _Lyric_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Playlist;
struct PlaylistDefaultTypeInternal;
extern PlaylistDefaultTypeInternal _Playlist_default_instance_;
class Repeat;
struct RepeatDefaultTypeInternal;
extern RepeatDefaultTypeInternal _Repeat_default_instance_;
class RequestAppendFiles;
struct RequestAppendFilesDefaultTypeInternal;
extern RequestAppendFilesDefaultTypeInternal _RequestAppendFiles_default_instance_;
class RequestChangeSong;
struct RequestChangeSongDefaultTypeInternal;
extern RequestChangeSongDefaultTypeInternal _RequestChangeSong_default_instance_;
class RequestClosePlaylist;
struct RequestClosePlaylistDefaultTypeInternal;
extern RequestClosePlaylistDefaultTypeInternal _RequestClosePlaylist_default_instance_;
class RequestConnect;
struct RequestConnectDefaultTypeInternal;
extern RequestConnectDefaultTypeInternal _RequestConnect_default_instance_;
class RequestDownloadSongs;
struct RequestDownloadSongsDefaultTypeInternal;
extern RequestDownloadSongsDefaultTypeInternal _RequestDownloadSongs_default_instance_;
class RequestGlobalSearch;
struct RequestGlobalSearchDefaultTypeInternal;
extern RequestGlobalSearchDefaultTypeInternal _RequestGlobalSearch_default_instance_;
class RequestInsertUrls;
struct RequestInsertUrlsDefaultTypeInternal;
extern RequestInsertUrlsDefaultTypeInternal _RequestInsertUrls_default_instance_;
class RequestListFiles;
struct RequestListFilesDefaultTypeInternal;
extern RequestListFilesDefaultTypeInternal _RequestListFiles_default_instance_;
class RequestOpenPlaylist;
struct RequestOpenPlaylistDefaultTypeInternal;
extern RequestOpenPlaylistDefaultTypeInternal _RequestOpenPlaylist_default_instance_;
class RequestPlaylistSongs;
struct RequestPlaylistSongsDefaultTypeInternal;
extern RequestPlaylistSongsDefaultTypeInternal _RequestPlaylistSongs_default_instance_;
class RequestPlaylists;
struct RequestPlaylistsDefaultTypeInternal;
extern RequestPlaylistsDefaultTypeInternal _RequestPlaylists_default_instance_;
class RequestRateSong;
struct RequestRateSongDefaultTypeInternal;
extern RequestRateSongDefaultTypeInternal _RequestRateSong_default_instance_;
class RequestRemoveSongs;
struct RequestRemoveSongsDefaultTypeInternal;
extern RequestRemoveSongsDefaultTypeInternal _RequestRemoveSongs_default_instance_;
class RequestSetTrackPosition;
struct RequestSetTrackPositionDefaultTypeInternal;
extern RequestSetTrackPositionDefaultTypeInternal _RequestSetTrackPosition_default_instance_;
class RequestSetVolume;
struct RequestSetVolumeDefaultTypeInternal;
extern RequestSetVolumeDefaultTypeInternal _RequestSetVolume_default_instance_;
class RequestUpdatePlaylist;
struct RequestUpdatePlaylistDefaultTypeInternal;
extern RequestUpdatePlaylistDefaultTypeInternal _RequestUpdatePlaylist_default_instance_;
class ResponseActiveChanged;
struct ResponseActiveChangedDefaultTypeInternal;
extern ResponseActiveChangedDefaultTypeInternal _ResponseActiveChanged_default_instance_;
class ResponseClementineInfo;
struct ResponseClementineInfoDefaultTypeInternal;
extern ResponseClementineInfoDefaultTypeInternal _ResponseClementineInfo_default_instance_;
class ResponseCurrentMetadata;
struct ResponseCurrentMetadataDefaultTypeInternal;
extern ResponseCurrentMetadataDefaultTypeInternal _ResponseCurrentMetadata_default_instance_;
class ResponseDisconnect;
struct ResponseDisconnectDefaultTypeInternal;
extern ResponseDisconnectDefaultTypeInternal _ResponseDisconnect_default_instance_;
class ResponseDownloadTotalSize;
struct ResponseDownloadTotalSizeDefaultTypeInternal;
extern ResponseDownloadTotalSizeDefaultTypeInternal _ResponseDownloadTotalSize_default_instance_;
class ResponseEngineStateChanged;
struct ResponseEngineStateChangedDefaultTypeInternal;
extern ResponseEngineStateChangedDefaultTypeInternal _ResponseEngineStateChanged_default_instance_;
class ResponseGlobalSearch;
struct ResponseGlobalSearchDefaultTypeInternal;
extern ResponseGlobalSearchDefaultTypeInternal _ResponseGlobalSearch_default_instance_;
class ResponseGlobalSearchStatus;
struct ResponseGlobalSearchStatusDefaultTypeInternal;
extern ResponseGlobalSearchStatusDefaultTypeInternal _ResponseGlobalSearchStatus_default_instance_;
class ResponseLibraryChunk;
struct ResponseLibraryChunkDefaultTypeInternal;
extern ResponseLibraryChunkDefaultTypeInternal _ResponseLibraryChunk_default_instance_;
class ResponseListFiles;
struct ResponseListFilesDefaultTypeInternal;
extern ResponseListFilesDefaultTypeInternal _ResponseListFiles_default_instance_;
class ResponseLyrics;
struct ResponseLyricsDefaultTypeInternal;
extern ResponseLyricsDefaultTypeInternal _ResponseLyrics_default_instance_;
class ResponsePlaylistSongs;
struct ResponsePlaylistSongsDefaultTypeInternal;
extern ResponsePlaylistSongsDefaultTypeInternal _ResponsePlaylistSongs_default_instance_;
class ResponsePlaylists;
struct ResponsePlaylistsDefaultTypeInternal;
extern ResponsePlaylistsDefaultTypeInternal _ResponsePlaylists_default_instance_;
class ResponseSavedRadios;
struct ResponseSavedRadiosDefaultTypeInternal;
extern ResponseSavedRadiosDefaultTypeInternal _ResponseSavedRadios_default_instance_;
class ResponseSongFileChunk;
struct ResponseSongFileChunkDefaultTypeInternal;
extern ResponseSongFileChunkDefaultTypeInternal _ResponseSongFileChunk_default_instance_;
class ResponseSongOffer;
struct ResponseSongOfferDefaultTypeInternal;
extern ResponseSongOfferDefaultTypeInternal _ResponseSongOffer_default_instance_;
class ResponseTranscoderStatus;
struct ResponseTranscoderStatusDefaultTypeInternal;
extern ResponseTranscoderStatusDefaultTypeInternal _ResponseTranscoderStatus_default_instance_;
class ResponseUpdateTrackPosition;
struct ResponseUpdateTrackPositionDefaultTypeInternal;
extern ResponseUpdateTrackPositionDefaultTypeInternal _ResponseUpdateTrackPosition_default_instance_;
class Shuffle;
struct ShuffleDefaultTypeInternal;
extern ShuffleDefaultTypeInternal _Shuffle_default_instance_;
class SongMetadata;
struct SongMetadataDefaultTypeInternal;
extern SongMetadataDefaultTypeInternal _SongMetadata_default_instance_;
class Stream;
struct StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
}  // namespace remote
}  // namespace cpb
PROTOBUF_NAMESPACE_OPEN
template<> ::cpb::remote::FileMetadata* Arena::CreateMaybeMessage<::cpb::remote::FileMetadata>(Arena*);
template<> ::cpb::remote::Lyric* Arena::CreateMaybeMessage<::cpb::remote::Lyric>(Arena*);
template<> ::cpb::remote::Message* Arena::CreateMaybeMessage<::cpb::remote::Message>(Arena*);
template<> ::cpb::remote::Playlist* Arena::CreateMaybeMessage<::cpb::remote::Playlist>(Arena*);
template<> ::cpb::remote::Repeat* Arena::CreateMaybeMessage<::cpb::remote::Repeat>(Arena*);
template<> ::cpb::remote::RequestAppendFiles* Arena::CreateMaybeMessage<::cpb::remote::RequestAppendFiles>(Arena*);
template<> ::cpb::remote::RequestChangeSong* Arena::CreateMaybeMessage<::cpb::remote::RequestChangeSong>(Arena*);
template<> ::cpb::remote::RequestClosePlaylist* Arena::CreateMaybeMessage<::cpb::remote::RequestClosePlaylist>(Arena*);
template<> ::cpb::remote::RequestConnect* Arena::CreateMaybeMessage<::cpb::remote::RequestConnect>(Arena*);
template<> ::cpb::remote::RequestDownloadSongs* Arena::CreateMaybeMessage<::cpb::remote::RequestDownloadSongs>(Arena*);
template<> ::cpb::remote::RequestGlobalSearch* Arena::CreateMaybeMessage<::cpb::remote::RequestGlobalSearch>(Arena*);
template<> ::cpb::remote::RequestInsertUrls* Arena::CreateMaybeMessage<::cpb::remote::RequestInsertUrls>(Arena*);
template<> ::cpb::remote::RequestListFiles* Arena::CreateMaybeMessage<::cpb::remote::RequestListFiles>(Arena*);
template<> ::cpb::remote::RequestOpenPlaylist* Arena::CreateMaybeMessage<::cpb::remote::RequestOpenPlaylist>(Arena*);
template<> ::cpb::remote::RequestPlaylistSongs* Arena::CreateMaybeMessage<::cpb::remote::RequestPlaylistSongs>(Arena*);
template<> ::cpb::remote::RequestPlaylists* Arena::CreateMaybeMessage<::cpb::remote::RequestPlaylists>(Arena*);
template<> ::cpb::remote::RequestRateSong* Arena::CreateMaybeMessage<::cpb::remote::RequestRateSong>(Arena*);
template<> ::cpb::remote::RequestRemoveSongs* Arena::CreateMaybeMessage<::cpb::remote::RequestRemoveSongs>(Arena*);
template<> ::cpb::remote::RequestSetTrackPosition* Arena::CreateMaybeMessage<::cpb::remote::RequestSetTrackPosition>(Arena*);
template<> ::cpb::remote::RequestSetVolume* Arena::CreateMaybeMessage<::cpb::remote::RequestSetVolume>(Arena*);
template<> ::cpb::remote::RequestUpdatePlaylist* Arena::CreateMaybeMessage<::cpb::remote::RequestUpdatePlaylist>(Arena*);
template<> ::cpb::remote::ResponseActiveChanged* Arena::CreateMaybeMessage<::cpb::remote::ResponseActiveChanged>(Arena*);
template<> ::cpb::remote::ResponseClementineInfo* Arena::CreateMaybeMessage<::cpb::remote::ResponseClementineInfo>(Arena*);
template<> ::cpb::remote::ResponseCurrentMetadata* Arena::CreateMaybeMessage<::cpb::remote::ResponseCurrentMetadata>(Arena*);
template<> ::cpb::remote::ResponseDisconnect* Arena::CreateMaybeMessage<::cpb::remote::ResponseDisconnect>(Arena*);
template<> ::cpb::remote::ResponseDownloadTotalSize* Arena::CreateMaybeMessage<::cpb::remote::ResponseDownloadTotalSize>(Arena*);
template<> ::cpb::remote::ResponseEngineStateChanged* Arena::CreateMaybeMessage<::cpb::remote::ResponseEngineStateChanged>(Arena*);
template<> ::cpb::remote::ResponseGlobalSearch* Arena::CreateMaybeMessage<::cpb::remote::ResponseGlobalSearch>(Arena*);
template<> ::cpb::remote::ResponseGlobalSearchStatus* Arena::CreateMaybeMessage<::cpb::remote::ResponseGlobalSearchStatus>(Arena*);
template<> ::cpb::remote::ResponseLibraryChunk* Arena::CreateMaybeMessage<::cpb::remote::ResponseLibraryChunk>(Arena*);
template<> ::cpb::remote::ResponseListFiles* Arena::CreateMaybeMessage<::cpb::remote::ResponseListFiles>(Arena*);
template<> ::cpb::remote::ResponseLyrics* Arena::CreateMaybeMessage<::cpb::remote::ResponseLyrics>(Arena*);
template<> ::cpb::remote::ResponsePlaylistSongs* Arena::CreateMaybeMessage<::cpb::remote::ResponsePlaylistSongs>(Arena*);
template<> ::cpb::remote::ResponsePlaylists* Arena::CreateMaybeMessage<::cpb::remote::ResponsePlaylists>(Arena*);
template<> ::cpb::remote::ResponseSavedRadios* Arena::CreateMaybeMessage<::cpb::remote::ResponseSavedRadios>(Arena*);
template<> ::cpb::remote::ResponseSongFileChunk* Arena::CreateMaybeMessage<::cpb::remote::ResponseSongFileChunk>(Arena*);
template<> ::cpb::remote::ResponseSongOffer* Arena::CreateMaybeMessage<::cpb::remote::ResponseSongOffer>(Arena*);
template<> ::cpb::remote::ResponseTranscoderStatus* Arena::CreateMaybeMessage<::cpb::remote::ResponseTranscoderStatus>(Arena*);
template<> ::cpb::remote::ResponseUpdateTrackPosition* Arena::CreateMaybeMessage<::cpb::remote::ResponseUpdateTrackPosition>(Arena*);
template<> ::cpb::remote::Shuffle* Arena::CreateMaybeMessage<::cpb::remote::Shuffle>(Arena*);
template<> ::cpb::remote::SongMetadata* Arena::CreateMaybeMessage<::cpb::remote::SongMetadata>(Arena*);
template<> ::cpb::remote::Stream* Arena::CreateMaybeMessage<::cpb::remote::Stream>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cpb {
namespace remote {

enum SongMetadata_Type : int {
  SongMetadata_Type_UNKNOWN = 0,
  SongMetadata_Type_ASF = 1,
  SongMetadata_Type_FLAC = 2,
  SongMetadata_Type_MP4 = 3,
  SongMetadata_Type_MPC = 4,
  SongMetadata_Type_MPEG = 5,
  SongMetadata_Type_OGGFLAC = 6,
  SongMetadata_Type_OGGSPEEX = 7,
  SongMetadata_Type_OGGVORBIS = 8,
  SongMetadata_Type_AIFF = 9,
  SongMetadata_Type_WAV = 10,
  SongMetadata_Type_TRUEAUDIO = 11,
  SongMetadata_Type_CDDA = 12,
  SongMetadata_Type_OGGOPUS = 13,
  SongMetadata_Type_WAVPACK = 14,
  SongMetadata_Type_SPC = 15,
  SongMetadata_Type_VGM = 16,
  SongMetadata_Type_APE = 17,
  SongMetadata_Type_DSF = 18,
  SongMetadata_Type_STREAM = 99
};
bool SongMetadata_Type_IsValid(int value);
constexpr SongMetadata_Type SongMetadata_Type_Type_MIN = SongMetadata_Type_UNKNOWN;
constexpr SongMetadata_Type SongMetadata_Type_Type_MAX = SongMetadata_Type_STREAM;
constexpr int SongMetadata_Type_Type_ARRAYSIZE = SongMetadata_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SongMetadata_Type_descriptor();
template<typename T>
inline const std::string& SongMetadata_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SongMetadata_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SongMetadata_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SongMetadata_Type_descriptor(), enum_t_value);
}
inline bool SongMetadata_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SongMetadata_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SongMetadata_Type>(
    SongMetadata_Type_descriptor(), name, value);
}
enum ResponseListFiles_Error : int {
  ResponseListFiles_Error_NONE = 0,
  ResponseListFiles_Error_ROOT_DIR_NOT_SET = 1,
  ResponseListFiles_Error_DIR_NOT_ACCESSIBLE = 2,
  ResponseListFiles_Error_DIR_NOT_EXIST = 3,
  ResponseListFiles_Error_UNKNOWN = 4
};
bool ResponseListFiles_Error_IsValid(int value);
constexpr ResponseListFiles_Error ResponseListFiles_Error_Error_MIN = ResponseListFiles_Error_NONE;
constexpr ResponseListFiles_Error ResponseListFiles_Error_Error_MAX = ResponseListFiles_Error_UNKNOWN;
constexpr int ResponseListFiles_Error_Error_ARRAYSIZE = ResponseListFiles_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseListFiles_Error_descriptor();
template<typename T>
inline const std::string& ResponseListFiles_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseListFiles_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseListFiles_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseListFiles_Error_descriptor(), enum_t_value);
}
inline bool ResponseListFiles_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseListFiles_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseListFiles_Error>(
    ResponseListFiles_Error_descriptor(), name, value);
}
enum MsgType : int {
  UNKNOWN = 0,
  CONNECT = 1,
  REQUEST_PLAYLISTS = 3,
  REQUEST_PLAYLIST_SONGS = 4,
  CHANGE_SONG = 5,
  SET_VOLUME = 6,
  SET_TRACK_POSITION = 7,
  INSERT_URLS = 8,
  REMOVE_SONGS = 9,
  OPEN_PLAYLIST = 10,
  CLOSE_PLAYLIST = 11,
  UPDATE_PLAYLIST = 60,
  GET_LYRICS = 14,
  DOWNLOAD_SONGS = 15,
  SONG_OFFER_RESPONSE = 16,
  LOVE = 12,
  BAN = 13,
  STOP_AFTER = 17,
  GET_LIBRARY = 18,
  RATE_SONG = 19,
  GLOBAL_SEARCH = 100,
  REQUEST_SAVED_RADIOS = 110,
  REQUEST_FILES = 200,
  APPEND_FILES = 201,
  DISCONNECT = 2,
  PLAY = 20,
  PLAYPAUSE = 21,
  PAUSE = 22,
  STOP = 23,
  NEXT = 24,
  PREVIOUS = 25,
  SHUFFLE_PLAYLIST = 26,
  REPEAT = 27,
  SHUFFLE = 28,
  INFO = 40,
  CURRENT_METAINFO = 41,
  PLAYLISTS = 42,
  PLAYLIST_SONGS = 43,
  ENGINE_STATE_CHANGED = 44,
  KEEP_ALIVE = 45,
  UPDATE_TRACK_POSITION = 46,
  ACTIVE_PLAYLIST_CHANGED = 47,
  FIRST_DATA_SENT_COMPLETE = 48,
  LYRICS = 49,
  SONG_FILE_CHUNK = 50,
  DOWNLOAD_QUEUE_EMPTY = 51,
  LIBRARY_CHUNK = 52,
  DOWNLOAD_TOTAL_SIZE = 53,
  GLOBAL_SEARCH_RESULT = 54,
  TRANSCODING_FILES = 55,
  GLOBAL_SEARCH_STATUS = 56,
  LIST_FILES = 202
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = UNKNOWN;
constexpr MsgType MsgType_MAX = LIST_FILES;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum EngineState : int {
  Empty = 0,
  Idle = 1,
  Playing = 2,
  Paused = 3
};
bool EngineState_IsValid(int value);
constexpr EngineState EngineState_MIN = Empty;
constexpr EngineState EngineState_MAX = Paused;
constexpr int EngineState_ARRAYSIZE = EngineState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EngineState_descriptor();
template<typename T>
inline const std::string& EngineState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EngineState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EngineState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EngineState_descriptor(), enum_t_value);
}
inline bool EngineState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EngineState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EngineState>(
    EngineState_descriptor(), name, value);
}
enum RepeatMode : int {
  Repeat_Off = 0,
  Repeat_Track = 1,
  Repeat_Album = 2,
  Repeat_Playlist = 3,
  Repeat_OneByOne = 4,
  Repeat_Intro = 5
};
bool RepeatMode_IsValid(int value);
constexpr RepeatMode RepeatMode_MIN = Repeat_Off;
constexpr RepeatMode RepeatMode_MAX = Repeat_Intro;
constexpr int RepeatMode_ARRAYSIZE = RepeatMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RepeatMode_descriptor();
template<typename T>
inline const std::string& RepeatMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RepeatMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RepeatMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RepeatMode_descriptor(), enum_t_value);
}
inline bool RepeatMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RepeatMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RepeatMode>(
    RepeatMode_descriptor(), name, value);
}
enum ShuffleMode : int {
  Shuffle_Off = 0,
  Shuffle_All = 1,
  Shuffle_InsideAlbum = 2,
  Shuffle_Albums = 3
};
bool ShuffleMode_IsValid(int value);
constexpr ShuffleMode ShuffleMode_MIN = Shuffle_Off;
constexpr ShuffleMode ShuffleMode_MAX = Shuffle_Albums;
constexpr int ShuffleMode_ARRAYSIZE = ShuffleMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShuffleMode_descriptor();
template<typename T>
inline const std::string& ShuffleMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShuffleMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShuffleMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShuffleMode_descriptor(), enum_t_value);
}
inline bool ShuffleMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShuffleMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShuffleMode>(
    ShuffleMode_descriptor(), name, value);
}
enum ReasonDisconnect : int {
  Server_Shutdown = 1,
  Wrong_Auth_Code = 2,
  Not_Authenticated = 3,
  Download_Forbidden = 4
};
bool ReasonDisconnect_IsValid(int value);
constexpr ReasonDisconnect ReasonDisconnect_MIN = Server_Shutdown;
constexpr ReasonDisconnect ReasonDisconnect_MAX = Download_Forbidden;
constexpr int ReasonDisconnect_ARRAYSIZE = ReasonDisconnect_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReasonDisconnect_descriptor();
template<typename T>
inline const std::string& ReasonDisconnect_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReasonDisconnect>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReasonDisconnect_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReasonDisconnect_descriptor(), enum_t_value);
}
inline bool ReasonDisconnect_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReasonDisconnect* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReasonDisconnect>(
    ReasonDisconnect_descriptor(), name, value);
}
enum DownloadItem : int {
  CurrentItem = 1,
  ItemAlbum = 2,
  APlaylist = 3,
  Urls = 4
};
bool DownloadItem_IsValid(int value);
constexpr DownloadItem DownloadItem_MIN = CurrentItem;
constexpr DownloadItem DownloadItem_MAX = Urls;
constexpr int DownloadItem_ARRAYSIZE = DownloadItem_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DownloadItem_descriptor();
template<typename T>
inline const std::string& DownloadItem_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DownloadItem>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DownloadItem_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DownloadItem_descriptor(), enum_t_value);
}
inline bool DownloadItem_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadItem* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DownloadItem>(
    DownloadItem_descriptor(), name, value);
}
enum GlobalSearchStatus : int {
  GlobalSearchStarted = 1,
  GlobalSearchFinished = 2
};
bool GlobalSearchStatus_IsValid(int value);
constexpr GlobalSearchStatus GlobalSearchStatus_MIN = GlobalSearchStarted;
constexpr GlobalSearchStatus GlobalSearchStatus_MAX = GlobalSearchFinished;
constexpr int GlobalSearchStatus_ARRAYSIZE = GlobalSearchStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlobalSearchStatus_descriptor();
template<typename T>
inline const std::string& GlobalSearchStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlobalSearchStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlobalSearchStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlobalSearchStatus_descriptor(), enum_t_value);
}
inline bool GlobalSearchStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlobalSearchStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlobalSearchStatus>(
    GlobalSearchStatus_descriptor(), name, value);
}
// ===================================================================

class SongMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.SongMetadata) */ {
 public:
  inline SongMetadata() : SongMetadata(nullptr) {}
  ~SongMetadata() override;
  explicit PROTOBUF_CONSTEXPR SongMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SongMetadata(const SongMetadata& from);
  SongMetadata(SongMetadata&& from) noexcept
    : SongMetadata() {
    *this = ::std::move(from);
  }

  inline SongMetadata& operator=(const SongMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SongMetadata& operator=(SongMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SongMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SongMetadata* internal_default_instance() {
    return reinterpret_cast<const SongMetadata*>(
               &_SongMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SongMetadata& a, SongMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SongMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SongMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SongMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SongMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SongMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SongMetadata& from) {
    SongMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.SongMetadata";
  }
  protected:
  explicit SongMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SongMetadata_Type Type;
  static constexpr Type UNKNOWN =
    SongMetadata_Type_UNKNOWN;
  static constexpr Type ASF =
    SongMetadata_Type_ASF;
  static constexpr Type FLAC =
    SongMetadata_Type_FLAC;
  static constexpr Type MP4 =
    SongMetadata_Type_MP4;
  static constexpr Type MPC =
    SongMetadata_Type_MPC;
  static constexpr Type MPEG =
    SongMetadata_Type_MPEG;
  static constexpr Type OGGFLAC =
    SongMetadata_Type_OGGFLAC;
  static constexpr Type OGGSPEEX =
    SongMetadata_Type_OGGSPEEX;
  static constexpr Type OGGVORBIS =
    SongMetadata_Type_OGGVORBIS;
  static constexpr Type AIFF =
    SongMetadata_Type_AIFF;
  static constexpr Type WAV =
    SongMetadata_Type_WAV;
  static constexpr Type TRUEAUDIO =
    SongMetadata_Type_TRUEAUDIO;
  static constexpr Type CDDA =
    SongMetadata_Type_CDDA;
  static constexpr Type OGGOPUS =
    SongMetadata_Type_OGGOPUS;
  static constexpr Type WAVPACK =
    SongMetadata_Type_WAVPACK;
  static constexpr Type SPC =
    SongMetadata_Type_SPC;
  static constexpr Type VGM =
    SongMetadata_Type_VGM;
  static constexpr Type APE =
    SongMetadata_Type_APE;
  static constexpr Type DSF =
    SongMetadata_Type_DSF;
  static constexpr Type STREAM =
    SongMetadata_Type_STREAM;
  static inline bool Type_IsValid(int value) {
    return SongMetadata_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SongMetadata_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SongMetadata_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SongMetadata_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return SongMetadata_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SongMetadata_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return SongMetadata_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 3,
    kAlbumFieldNumber = 4,
    kArtistFieldNumber = 5,
    kAlbumartistFieldNumber = 6,
    kPrettyYearFieldNumber = 9,
    kGenreFieldNumber = 10,
    kPrettyLengthFieldNumber = 12,
    kArtFieldNumber = 13,
    kFilenameFieldNumber = 16,
    kUrlFieldNumber = 19,
    kArtAutomaticFieldNumber = 20,
    kArtManualFieldNumber = 21,
    kIdFieldNumber = 1,
    kIndexFieldNumber = 2,
    kTrackFieldNumber = 7,
    kDiscFieldNumber = 8,
    kPlaycountFieldNumber = 11,
    kLengthFieldNumber = 14,
    kIsLocalFieldNumber = 15,
    kFileSizeFieldNumber = 17,
    kRatingFieldNumber = 18,
    kTypeFieldNumber = 22,
  };
  // optional string title = 3;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string album = 4;
  bool has_album() const;
  private:
  bool _internal_has_album() const;
  public:
  void clear_album();
  const std::string& album() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_album(ArgT0&& arg0, ArgT... args);
  std::string* mutable_album();
  PROTOBUF_NODISCARD std::string* release_album();
  void set_allocated_album(std::string* album);
  private:
  const std::string& _internal_album() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_album(const std::string& value);
  std::string* _internal_mutable_album();
  public:

  // optional string artist = 5;
  bool has_artist() const;
  private:
  bool _internal_has_artist() const;
  public:
  void clear_artist();
  const std::string& artist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artist();
  PROTOBUF_NODISCARD std::string* release_artist();
  void set_allocated_artist(std::string* artist);
  private:
  const std::string& _internal_artist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artist(const std::string& value);
  std::string* _internal_mutable_artist();
  public:

  // optional string albumartist = 6;
  bool has_albumartist() const;
  private:
  bool _internal_has_albumartist() const;
  public:
  void clear_albumartist();
  const std::string& albumartist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_albumartist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_albumartist();
  PROTOBUF_NODISCARD std::string* release_albumartist();
  void set_allocated_albumartist(std::string* albumartist);
  private:
  const std::string& _internal_albumartist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_albumartist(const std::string& value);
  std::string* _internal_mutable_albumartist();
  public:

  // optional string pretty_year = 9;
  bool has_pretty_year() const;
  private:
  bool _internal_has_pretty_year() const;
  public:
  void clear_pretty_year();
  const std::string& pretty_year() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pretty_year(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pretty_year();
  PROTOBUF_NODISCARD std::string* release_pretty_year();
  void set_allocated_pretty_year(std::string* pretty_year);
  private:
  const std::string& _internal_pretty_year() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pretty_year(const std::string& value);
  std::string* _internal_mutable_pretty_year();
  public:

  // optional string genre = 10;
  bool has_genre() const;
  private:
  bool _internal_has_genre() const;
  public:
  void clear_genre();
  const std::string& genre() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_genre(ArgT0&& arg0, ArgT... args);
  std::string* mutable_genre();
  PROTOBUF_NODISCARD std::string* release_genre();
  void set_allocated_genre(std::string* genre);
  private:
  const std::string& _internal_genre() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_genre(const std::string& value);
  std::string* _internal_mutable_genre();
  public:

  // optional string pretty_length = 12;
  bool has_pretty_length() const;
  private:
  bool _internal_has_pretty_length() const;
  public:
  void clear_pretty_length();
  const std::string& pretty_length() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pretty_length(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pretty_length();
  PROTOBUF_NODISCARD std::string* release_pretty_length();
  void set_allocated_pretty_length(std::string* pretty_length);
  private:
  const std::string& _internal_pretty_length() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pretty_length(const std::string& value);
  std::string* _internal_mutable_pretty_length();
  public:

  // optional bytes art = 13;
  bool has_art() const;
  private:
  bool _internal_has_art() const;
  public:
  void clear_art();
  const std::string& art() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_art(ArgT0&& arg0, ArgT... args);
  std::string* mutable_art();
  PROTOBUF_NODISCARD std::string* release_art();
  void set_allocated_art(std::string* art);
  private:
  const std::string& _internal_art() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_art(const std::string& value);
  std::string* _internal_mutable_art();
  public:

  // optional string filename = 16;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string url = 19;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string art_automatic = 20;
  bool has_art_automatic() const;
  private:
  bool _internal_has_art_automatic() const;
  public:
  void clear_art_automatic();
  const std::string& art_automatic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_art_automatic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_art_automatic();
  PROTOBUF_NODISCARD std::string* release_art_automatic();
  void set_allocated_art_automatic(std::string* art_automatic);
  private:
  const std::string& _internal_art_automatic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_art_automatic(const std::string& value);
  std::string* _internal_mutable_art_automatic();
  public:

  // optional string art_manual = 21;
  bool has_art_manual() const;
  private:
  bool _internal_has_art_manual() const;
  public:
  void clear_art_manual();
  const std::string& art_manual() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_art_manual(ArgT0&& arg0, ArgT... args);
  std::string* mutable_art_manual();
  PROTOBUF_NODISCARD std::string* release_art_manual();
  void set_allocated_art_manual(std::string* art_manual);
  private:
  const std::string& _internal_art_manual() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_art_manual(const std::string& value);
  std::string* _internal_mutable_art_manual();
  public:

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional int32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // optional int32 track = 7;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  int32_t track() const;
  void set_track(int32_t value);
  private:
  int32_t _internal_track() const;
  void _internal_set_track(int32_t value);
  public:

  // optional int32 disc = 8;
  bool has_disc() const;
  private:
  bool _internal_has_disc() const;
  public:
  void clear_disc();
  int32_t disc() const;
  void set_disc(int32_t value);
  private:
  int32_t _internal_disc() const;
  void _internal_set_disc(int32_t value);
  public:

  // optional int32 playcount = 11;
  bool has_playcount() const;
  private:
  bool _internal_has_playcount() const;
  public:
  void clear_playcount();
  int32_t playcount() const;
  void set_playcount(int32_t value);
  private:
  int32_t _internal_playcount() const;
  void _internal_set_playcount(int32_t value);
  public:

  // optional int32 length = 14;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // optional bool is_local = 15;
  bool has_is_local() const;
  private:
  bool _internal_has_is_local() const;
  public:
  void clear_is_local();
  bool is_local() const;
  void set_is_local(bool value);
  private:
  bool _internal_is_local() const;
  void _internal_set_is_local(bool value);
  public:

  // optional int32 file_size = 17;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  int32_t file_size() const;
  void set_file_size(int32_t value);
  private:
  int32_t _internal_file_size() const;
  void _internal_set_file_size(int32_t value);
  public:

  // optional float rating = 18;
  bool has_rating() const;
  private:
  bool _internal_has_rating() const;
  public:
  void clear_rating();
  float rating() const;
  void set_rating(float value);
  private:
  float _internal_rating() const;
  void _internal_set_rating(float value);
  public:

  // optional .cpb.remote.SongMetadata.Type type = 22;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::cpb::remote::SongMetadata_Type type() const;
  void set_type(::cpb::remote::SongMetadata_Type value);
  private:
  ::cpb::remote::SongMetadata_Type _internal_type() const;
  void _internal_set_type(::cpb::remote::SongMetadata_Type value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.SongMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr album_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr albumartist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pretty_year_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr genre_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pretty_length_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr art_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr art_automatic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr art_manual_;
    int32_t id_;
    int32_t index_;
    int32_t track_;
    int32_t disc_;
    int32_t playcount_;
    int32_t length_;
    bool is_local_;
    int32_t file_size_;
    float rating_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class Playlist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.Playlist) */ {
 public:
  inline Playlist() : Playlist(nullptr) {}
  ~Playlist() override;
  explicit PROTOBUF_CONSTEXPR Playlist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Playlist(const Playlist& from);
  Playlist(Playlist&& from) noexcept
    : Playlist() {
    *this = ::std::move(from);
  }

  inline Playlist& operator=(const Playlist& from) {
    CopyFrom(from);
    return *this;
  }
  inline Playlist& operator=(Playlist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Playlist& default_instance() {
    return *internal_default_instance();
  }
  static inline const Playlist* internal_default_instance() {
    return reinterpret_cast<const Playlist*>(
               &_Playlist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Playlist& a, Playlist& b) {
    a.Swap(&b);
  }
  inline void Swap(Playlist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Playlist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Playlist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Playlist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Playlist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Playlist& from) {
    Playlist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Playlist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.Playlist";
  }
  protected:
  explicit Playlist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kItemCountFieldNumber = 3,
    kActiveFieldNumber = 4,
    kClosedFieldNumber = 5,
    kFavoriteFieldNumber = 6,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional int32 item_count = 3;
  bool has_item_count() const;
  private:
  bool _internal_has_item_count() const;
  public:
  void clear_item_count();
  int32_t item_count() const;
  void set_item_count(int32_t value);
  private:
  int32_t _internal_item_count() const;
  void _internal_set_item_count(int32_t value);
  public:

  // optional bool active = 4;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional bool closed = 5;
  bool has_closed() const;
  private:
  bool _internal_has_closed() const;
  public:
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // optional bool favorite = 6;
  bool has_favorite() const;
  private:
  bool _internal_has_favorite() const;
  public:
  void clear_favorite();
  bool favorite() const;
  void set_favorite(bool value);
  private:
  bool _internal_favorite() const;
  void _internal_set_favorite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.Playlist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t id_;
    int32_t item_count_;
    bool active_;
    bool closed_;
    bool favorite_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestPlaylists final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestPlaylists) */ {
 public:
  inline RequestPlaylists() : RequestPlaylists(nullptr) {}
  ~RequestPlaylists() override;
  explicit PROTOBUF_CONSTEXPR RequestPlaylists(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPlaylists(const RequestPlaylists& from);
  RequestPlaylists(RequestPlaylists&& from) noexcept
    : RequestPlaylists() {
    *this = ::std::move(from);
  }

  inline RequestPlaylists& operator=(const RequestPlaylists& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPlaylists& operator=(RequestPlaylists&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPlaylists& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPlaylists* internal_default_instance() {
    return reinterpret_cast<const RequestPlaylists*>(
               &_RequestPlaylists_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestPlaylists& a, RequestPlaylists& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPlaylists* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPlaylists* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestPlaylists* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestPlaylists>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestPlaylists& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestPlaylists& from) {
    RequestPlaylists::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPlaylists* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestPlaylists";
  }
  protected:
  explicit RequestPlaylists(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeClosedFieldNumber = 1,
  };
  // optional bool include_closed = 1;
  bool has_include_closed() const;
  private:
  bool _internal_has_include_closed() const;
  public:
  void clear_include_closed();
  bool include_closed() const;
  void set_include_closed(bool value);
  private:
  bool _internal_include_closed() const;
  void _internal_set_include_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestPlaylists)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool include_closed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestPlaylistSongs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestPlaylistSongs) */ {
 public:
  inline RequestPlaylistSongs() : RequestPlaylistSongs(nullptr) {}
  ~RequestPlaylistSongs() override;
  explicit PROTOBUF_CONSTEXPR RequestPlaylistSongs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPlaylistSongs(const RequestPlaylistSongs& from);
  RequestPlaylistSongs(RequestPlaylistSongs&& from) noexcept
    : RequestPlaylistSongs() {
    *this = ::std::move(from);
  }

  inline RequestPlaylistSongs& operator=(const RequestPlaylistSongs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPlaylistSongs& operator=(RequestPlaylistSongs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPlaylistSongs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPlaylistSongs* internal_default_instance() {
    return reinterpret_cast<const RequestPlaylistSongs*>(
               &_RequestPlaylistSongs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestPlaylistSongs& a, RequestPlaylistSongs& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPlaylistSongs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPlaylistSongs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestPlaylistSongs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestPlaylistSongs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestPlaylistSongs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestPlaylistSongs& from) {
    RequestPlaylistSongs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPlaylistSongs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestPlaylistSongs";
  }
  protected:
  explicit RequestPlaylistSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestPlaylistSongs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestChangeSong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestChangeSong) */ {
 public:
  inline RequestChangeSong() : RequestChangeSong(nullptr) {}
  ~RequestChangeSong() override;
  explicit PROTOBUF_CONSTEXPR RequestChangeSong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestChangeSong(const RequestChangeSong& from);
  RequestChangeSong(RequestChangeSong&& from) noexcept
    : RequestChangeSong() {
    *this = ::std::move(from);
  }

  inline RequestChangeSong& operator=(const RequestChangeSong& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestChangeSong& operator=(RequestChangeSong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestChangeSong& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestChangeSong* internal_default_instance() {
    return reinterpret_cast<const RequestChangeSong*>(
               &_RequestChangeSong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestChangeSong& a, RequestChangeSong& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestChangeSong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestChangeSong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestChangeSong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestChangeSong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestChangeSong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestChangeSong& from) {
    RequestChangeSong::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestChangeSong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestChangeSong";
  }
  protected:
  explicit RequestChangeSong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistIdFieldNumber = 1,
    kSongIndexFieldNumber = 2,
  };
  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // optional int32 song_index = 2;
  bool has_song_index() const;
  private:
  bool _internal_has_song_index() const;
  public:
  void clear_song_index();
  int32_t song_index() const;
  void set_song_index(int32_t value);
  private:
  int32_t _internal_song_index() const;
  void _internal_set_song_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestChangeSong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t playlist_id_;
    int32_t song_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestSetVolume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestSetVolume) */ {
 public:
  inline RequestSetVolume() : RequestSetVolume(nullptr) {}
  ~RequestSetVolume() override;
  explicit PROTOBUF_CONSTEXPR RequestSetVolume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSetVolume(const RequestSetVolume& from);
  RequestSetVolume(RequestSetVolume&& from) noexcept
    : RequestSetVolume() {
    *this = ::std::move(from);
  }

  inline RequestSetVolume& operator=(const RequestSetVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSetVolume& operator=(RequestSetVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSetVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSetVolume* internal_default_instance() {
    return reinterpret_cast<const RequestSetVolume*>(
               &_RequestSetVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestSetVolume& a, RequestSetVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSetVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSetVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSetVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSetVolume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSetVolume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSetVolume& from) {
    RequestSetVolume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSetVolume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestSetVolume";
  }
  protected:
  explicit RequestSetVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
  };
  // optional int32 volume = 1;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  int32_t volume() const;
  void set_volume(int32_t value);
  private:
  int32_t _internal_volume() const;
  void _internal_set_volume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestSetVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t volume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class Repeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.Repeat) */ {
 public:
  inline Repeat() : Repeat(nullptr) {}
  ~Repeat() override;
  explicit PROTOBUF_CONSTEXPR Repeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Repeat(const Repeat& from);
  Repeat(Repeat&& from) noexcept
    : Repeat() {
    *this = ::std::move(from);
  }

  inline Repeat& operator=(const Repeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repeat& operator=(Repeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Repeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Repeat* internal_default_instance() {
    return reinterpret_cast<const Repeat*>(
               &_Repeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Repeat& a, Repeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Repeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Repeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Repeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Repeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Repeat& from) {
    Repeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.Repeat";
  }
  protected:
  explicit Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepeatModeFieldNumber = 1,
  };
  // optional .cpb.remote.RepeatMode repeat_mode = 1;
  bool has_repeat_mode() const;
  private:
  bool _internal_has_repeat_mode() const;
  public:
  void clear_repeat_mode();
  ::cpb::remote::RepeatMode repeat_mode() const;
  void set_repeat_mode(::cpb::remote::RepeatMode value);
  private:
  ::cpb::remote::RepeatMode _internal_repeat_mode() const;
  void _internal_set_repeat_mode(::cpb::remote::RepeatMode value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.Repeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int repeat_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class Shuffle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.Shuffle) */ {
 public:
  inline Shuffle() : Shuffle(nullptr) {}
  ~Shuffle() override;
  explicit PROTOBUF_CONSTEXPR Shuffle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shuffle(const Shuffle& from);
  Shuffle(Shuffle&& from) noexcept
    : Shuffle() {
    *this = ::std::move(from);
  }

  inline Shuffle& operator=(const Shuffle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shuffle& operator=(Shuffle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shuffle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shuffle* internal_default_instance() {
    return reinterpret_cast<const Shuffle*>(
               &_Shuffle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Shuffle& a, Shuffle& b) {
    a.Swap(&b);
  }
  inline void Swap(Shuffle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shuffle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shuffle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shuffle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shuffle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Shuffle& from) {
    Shuffle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shuffle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.Shuffle";
  }
  protected:
  explicit Shuffle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShuffleModeFieldNumber = 1,
  };
  // optional .cpb.remote.ShuffleMode shuffle_mode = 1;
  bool has_shuffle_mode() const;
  private:
  bool _internal_has_shuffle_mode() const;
  public:
  void clear_shuffle_mode();
  ::cpb::remote::ShuffleMode shuffle_mode() const;
  void set_shuffle_mode(::cpb::remote::ShuffleMode value);
  private:
  ::cpb::remote::ShuffleMode _internal_shuffle_mode() const;
  void _internal_set_shuffle_mode(::cpb::remote::ShuffleMode value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.Shuffle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int shuffle_mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseClementineInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseClementineInfo) */ {
 public:
  inline ResponseClementineInfo() : ResponseClementineInfo(nullptr) {}
  ~ResponseClementineInfo() override;
  explicit PROTOBUF_CONSTEXPR ResponseClementineInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseClementineInfo(const ResponseClementineInfo& from);
  ResponseClementineInfo(ResponseClementineInfo&& from) noexcept
    : ResponseClementineInfo() {
    *this = ::std::move(from);
  }

  inline ResponseClementineInfo& operator=(const ResponseClementineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseClementineInfo& operator=(ResponseClementineInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseClementineInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseClementineInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseClementineInfo*>(
               &_ResponseClementineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResponseClementineInfo& a, ResponseClementineInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseClementineInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseClementineInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseClementineInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseClementineInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseClementineInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseClementineInfo& from) {
    ResponseClementineInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseClementineInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseClementineInfo";
  }
  protected:
  explicit ResponseClementineInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesMusicExtensionsFieldNumber = 4,
    kVersionFieldNumber = 1,
    kStateFieldNumber = 2,
    kAllowDownloadsFieldNumber = 3,
  };
  // repeated string files_music_extensions = 4;
  int files_music_extensions_size() const;
  private:
  int _internal_files_music_extensions_size() const;
  public:
  void clear_files_music_extensions();
  const std::string& files_music_extensions(int index) const;
  std::string* mutable_files_music_extensions(int index);
  void set_files_music_extensions(int index, const std::string& value);
  void set_files_music_extensions(int index, std::string&& value);
  void set_files_music_extensions(int index, const char* value);
  void set_files_music_extensions(int index, const char* value, size_t size);
  std::string* add_files_music_extensions();
  void add_files_music_extensions(const std::string& value);
  void add_files_music_extensions(std::string&& value);
  void add_files_music_extensions(const char* value);
  void add_files_music_extensions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files_music_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files_music_extensions();
  private:
  const std::string& _internal_files_music_extensions(int index) const;
  std::string* _internal_add_files_music_extensions();
  public:

  // optional string version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional .cpb.remote.EngineState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::cpb::remote::EngineState state() const;
  void set_state(::cpb::remote::EngineState value);
  private:
  ::cpb::remote::EngineState _internal_state() const;
  void _internal_set_state(::cpb::remote::EngineState value);
  public:

  // optional bool allow_downloads = 3;
  bool has_allow_downloads() const;
  private:
  bool _internal_has_allow_downloads() const;
  public:
  void clear_allow_downloads();
  bool allow_downloads() const;
  void set_allow_downloads(bool value);
  private:
  bool _internal_allow_downloads() const;
  void _internal_set_allow_downloads(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseClementineInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_music_extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int state_;
    bool allow_downloads_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseCurrentMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseCurrentMetadata) */ {
 public:
  inline ResponseCurrentMetadata() : ResponseCurrentMetadata(nullptr) {}
  ~ResponseCurrentMetadata() override;
  explicit PROTOBUF_CONSTEXPR ResponseCurrentMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseCurrentMetadata(const ResponseCurrentMetadata& from);
  ResponseCurrentMetadata(ResponseCurrentMetadata&& from) noexcept
    : ResponseCurrentMetadata() {
    *this = ::std::move(from);
  }

  inline ResponseCurrentMetadata& operator=(const ResponseCurrentMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseCurrentMetadata& operator=(ResponseCurrentMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseCurrentMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseCurrentMetadata* internal_default_instance() {
    return reinterpret_cast<const ResponseCurrentMetadata*>(
               &_ResponseCurrentMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ResponseCurrentMetadata& a, ResponseCurrentMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseCurrentMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseCurrentMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseCurrentMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseCurrentMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseCurrentMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseCurrentMetadata& from) {
    ResponseCurrentMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCurrentMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseCurrentMetadata";
  }
  protected:
  explicit ResponseCurrentMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongMetadataFieldNumber = 1,
  };
  // optional .cpb.remote.SongMetadata song_metadata = 1;
  bool has_song_metadata() const;
  private:
  bool _internal_has_song_metadata() const;
  public:
  void clear_song_metadata();
  const ::cpb::remote::SongMetadata& song_metadata() const;
  PROTOBUF_NODISCARD ::cpb::remote::SongMetadata* release_song_metadata();
  ::cpb::remote::SongMetadata* mutable_song_metadata();
  void set_allocated_song_metadata(::cpb::remote::SongMetadata* song_metadata);
  private:
  const ::cpb::remote::SongMetadata& _internal_song_metadata() const;
  ::cpb::remote::SongMetadata* _internal_mutable_song_metadata();
  public:
  void unsafe_arena_set_allocated_song_metadata(
      ::cpb::remote::SongMetadata* song_metadata);
  ::cpb::remote::SongMetadata* unsafe_arena_release_song_metadata();

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseCurrentMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cpb::remote::SongMetadata* song_metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponsePlaylists final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponsePlaylists) */ {
 public:
  inline ResponsePlaylists() : ResponsePlaylists(nullptr) {}
  ~ResponsePlaylists() override;
  explicit PROTOBUF_CONSTEXPR ResponsePlaylists(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponsePlaylists(const ResponsePlaylists& from);
  ResponsePlaylists(ResponsePlaylists&& from) noexcept
    : ResponsePlaylists() {
    *this = ::std::move(from);
  }

  inline ResponsePlaylists& operator=(const ResponsePlaylists& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponsePlaylists& operator=(ResponsePlaylists&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponsePlaylists& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponsePlaylists* internal_default_instance() {
    return reinterpret_cast<const ResponsePlaylists*>(
               &_ResponsePlaylists_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResponsePlaylists& a, ResponsePlaylists& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponsePlaylists* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponsePlaylists* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponsePlaylists* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponsePlaylists>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponsePlaylists& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponsePlaylists& from) {
    ResponsePlaylists::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePlaylists* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponsePlaylists";
  }
  protected:
  explicit ResponsePlaylists(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistFieldNumber = 1,
    kIncludeClosedFieldNumber = 2,
  };
  // repeated .cpb.remote.Playlist playlist = 1;
  int playlist_size() const;
  private:
  int _internal_playlist_size() const;
  public:
  void clear_playlist();
  ::cpb::remote::Playlist* mutable_playlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Playlist >*
      mutable_playlist();
  private:
  const ::cpb::remote::Playlist& _internal_playlist(int index) const;
  ::cpb::remote::Playlist* _internal_add_playlist();
  public:
  const ::cpb::remote::Playlist& playlist(int index) const;
  ::cpb::remote::Playlist* add_playlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Playlist >&
      playlist() const;

  // optional bool include_closed = 2;
  bool has_include_closed() const;
  private:
  bool _internal_has_include_closed() const;
  public:
  void clear_include_closed();
  bool include_closed() const;
  void set_include_closed(bool value);
  private:
  bool _internal_include_closed() const;
  void _internal_set_include_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponsePlaylists)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Playlist > playlist_;
    bool include_closed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponsePlaylistSongs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponsePlaylistSongs) */ {
 public:
  inline ResponsePlaylistSongs() : ResponsePlaylistSongs(nullptr) {}
  ~ResponsePlaylistSongs() override;
  explicit PROTOBUF_CONSTEXPR ResponsePlaylistSongs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponsePlaylistSongs(const ResponsePlaylistSongs& from);
  ResponsePlaylistSongs(ResponsePlaylistSongs&& from) noexcept
    : ResponsePlaylistSongs() {
    *this = ::std::move(from);
  }

  inline ResponsePlaylistSongs& operator=(const ResponsePlaylistSongs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponsePlaylistSongs& operator=(ResponsePlaylistSongs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponsePlaylistSongs& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponsePlaylistSongs* internal_default_instance() {
    return reinterpret_cast<const ResponsePlaylistSongs*>(
               &_ResponsePlaylistSongs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResponsePlaylistSongs& a, ResponsePlaylistSongs& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponsePlaylistSongs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponsePlaylistSongs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponsePlaylistSongs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponsePlaylistSongs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponsePlaylistSongs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponsePlaylistSongs& from) {
    ResponsePlaylistSongs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePlaylistSongs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponsePlaylistSongs";
  }
  protected:
  explicit ResponsePlaylistSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongsFieldNumber = 2,
    kRequestedPlaylistFieldNumber = 1,
  };
  // repeated .cpb.remote.SongMetadata songs = 2;
  int songs_size() const;
  private:
  int _internal_songs_size() const;
  public:
  void clear_songs();
  ::cpb::remote::SongMetadata* mutable_songs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >*
      mutable_songs();
  private:
  const ::cpb::remote::SongMetadata& _internal_songs(int index) const;
  ::cpb::remote::SongMetadata* _internal_add_songs();
  public:
  const ::cpb::remote::SongMetadata& songs(int index) const;
  ::cpb::remote::SongMetadata* add_songs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >&
      songs() const;

  // optional .cpb.remote.Playlist requested_playlist = 1;
  bool has_requested_playlist() const;
  private:
  bool _internal_has_requested_playlist() const;
  public:
  void clear_requested_playlist();
  const ::cpb::remote::Playlist& requested_playlist() const;
  PROTOBUF_NODISCARD ::cpb::remote::Playlist* release_requested_playlist();
  ::cpb::remote::Playlist* mutable_requested_playlist();
  void set_allocated_requested_playlist(::cpb::remote::Playlist* requested_playlist);
  private:
  const ::cpb::remote::Playlist& _internal_requested_playlist() const;
  ::cpb::remote::Playlist* _internal_mutable_requested_playlist();
  public:
  void unsafe_arena_set_allocated_requested_playlist(
      ::cpb::remote::Playlist* requested_playlist);
  ::cpb::remote::Playlist* unsafe_arena_release_requested_playlist();

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponsePlaylistSongs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata > songs_;
    ::cpb::remote::Playlist* requested_playlist_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseEngineStateChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseEngineStateChanged) */ {
 public:
  inline ResponseEngineStateChanged() : ResponseEngineStateChanged(nullptr) {}
  ~ResponseEngineStateChanged() override;
  explicit PROTOBUF_CONSTEXPR ResponseEngineStateChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseEngineStateChanged(const ResponseEngineStateChanged& from);
  ResponseEngineStateChanged(ResponseEngineStateChanged&& from) noexcept
    : ResponseEngineStateChanged() {
    *this = ::std::move(from);
  }

  inline ResponseEngineStateChanged& operator=(const ResponseEngineStateChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEngineStateChanged& operator=(ResponseEngineStateChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEngineStateChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEngineStateChanged* internal_default_instance() {
    return reinterpret_cast<const ResponseEngineStateChanged*>(
               &_ResponseEngineStateChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResponseEngineStateChanged& a, ResponseEngineStateChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEngineStateChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEngineStateChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEngineStateChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEngineStateChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseEngineStateChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseEngineStateChanged& from) {
    ResponseEngineStateChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEngineStateChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseEngineStateChanged";
  }
  protected:
  explicit ResponseEngineStateChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // optional .cpb.remote.EngineState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::cpb::remote::EngineState state() const;
  void set_state(::cpb::remote::EngineState value);
  private:
  ::cpb::remote::EngineState _internal_state() const;
  void _internal_set_state(::cpb::remote::EngineState value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseEngineStateChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseUpdateTrackPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseUpdateTrackPosition) */ {
 public:
  inline ResponseUpdateTrackPosition() : ResponseUpdateTrackPosition(nullptr) {}
  ~ResponseUpdateTrackPosition() override;
  explicit PROTOBUF_CONSTEXPR ResponseUpdateTrackPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseUpdateTrackPosition(const ResponseUpdateTrackPosition& from);
  ResponseUpdateTrackPosition(ResponseUpdateTrackPosition&& from) noexcept
    : ResponseUpdateTrackPosition() {
    *this = ::std::move(from);
  }

  inline ResponseUpdateTrackPosition& operator=(const ResponseUpdateTrackPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseUpdateTrackPosition& operator=(ResponseUpdateTrackPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseUpdateTrackPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseUpdateTrackPosition* internal_default_instance() {
    return reinterpret_cast<const ResponseUpdateTrackPosition*>(
               &_ResponseUpdateTrackPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResponseUpdateTrackPosition& a, ResponseUpdateTrackPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseUpdateTrackPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseUpdateTrackPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseUpdateTrackPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseUpdateTrackPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseUpdateTrackPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseUpdateTrackPosition& from) {
    ResponseUpdateTrackPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseUpdateTrackPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseUpdateTrackPosition";
  }
  protected:
  explicit ResponseUpdateTrackPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // optional int32 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  int32_t position() const;
  void set_position(int32_t value);
  private:
  int32_t _internal_position() const;
  void _internal_set_position(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseUpdateTrackPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestConnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestConnect) */ {
 public:
  inline RequestConnect() : RequestConnect(nullptr) {}
  ~RequestConnect() override;
  explicit PROTOBUF_CONSTEXPR RequestConnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestConnect(const RequestConnect& from);
  RequestConnect(RequestConnect&& from) noexcept
    : RequestConnect() {
    *this = ::std::move(from);
  }

  inline RequestConnect& operator=(const RequestConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestConnect& operator=(RequestConnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestConnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestConnect* internal_default_instance() {
    return reinterpret_cast<const RequestConnect*>(
               &_RequestConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RequestConnect& a, RequestConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestConnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestConnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestConnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestConnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestConnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestConnect& from) {
    RequestConnect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestConnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestConnect";
  }
  protected:
  explicit RequestConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthCodeFieldNumber = 1,
    kSendPlaylistSongsFieldNumber = 2,
    kDownloaderFieldNumber = 3,
  };
  // optional int32 auth_code = 1;
  bool has_auth_code() const;
  private:
  bool _internal_has_auth_code() const;
  public:
  void clear_auth_code();
  int32_t auth_code() const;
  void set_auth_code(int32_t value);
  private:
  int32_t _internal_auth_code() const;
  void _internal_set_auth_code(int32_t value);
  public:

  // optional bool send_playlist_songs = 2;
  bool has_send_playlist_songs() const;
  private:
  bool _internal_has_send_playlist_songs() const;
  public:
  void clear_send_playlist_songs();
  bool send_playlist_songs() const;
  void set_send_playlist_songs(bool value);
  private:
  bool _internal_send_playlist_songs() const;
  void _internal_set_send_playlist_songs(bool value);
  public:

  // optional bool downloader = 3;
  bool has_downloader() const;
  private:
  bool _internal_has_downloader() const;
  public:
  void clear_downloader();
  bool downloader() const;
  void set_downloader(bool value);
  private:
  bool _internal_downloader() const;
  void _internal_set_downloader(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestConnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t auth_code_;
    bool send_playlist_songs_;
    bool downloader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseDisconnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseDisconnect) */ {
 public:
  inline ResponseDisconnect() : ResponseDisconnect(nullptr) {}
  ~ResponseDisconnect() override;
  explicit PROTOBUF_CONSTEXPR ResponseDisconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseDisconnect(const ResponseDisconnect& from);
  ResponseDisconnect(ResponseDisconnect&& from) noexcept
    : ResponseDisconnect() {
    *this = ::std::move(from);
  }

  inline ResponseDisconnect& operator=(const ResponseDisconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDisconnect& operator=(ResponseDisconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseDisconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseDisconnect* internal_default_instance() {
    return reinterpret_cast<const ResponseDisconnect*>(
               &_ResponseDisconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResponseDisconnect& a, ResponseDisconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDisconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseDisconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseDisconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseDisconnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseDisconnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseDisconnect& from) {
    ResponseDisconnect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDisconnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseDisconnect";
  }
  protected:
  explicit ResponseDisconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonDisconnectFieldNumber = 1,
  };
  // optional .cpb.remote.ReasonDisconnect reason_disconnect = 1;
  bool has_reason_disconnect() const;
  private:
  bool _internal_has_reason_disconnect() const;
  public:
  void clear_reason_disconnect();
  ::cpb::remote::ReasonDisconnect reason_disconnect() const;
  void set_reason_disconnect(::cpb::remote::ReasonDisconnect value);
  private:
  ::cpb::remote::ReasonDisconnect _internal_reason_disconnect() const;
  void _internal_set_reason_disconnect(::cpb::remote::ReasonDisconnect value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseDisconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int reason_disconnect_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseActiveChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseActiveChanged) */ {
 public:
  inline ResponseActiveChanged() : ResponseActiveChanged(nullptr) {}
  ~ResponseActiveChanged() override;
  explicit PROTOBUF_CONSTEXPR ResponseActiveChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseActiveChanged(const ResponseActiveChanged& from);
  ResponseActiveChanged(ResponseActiveChanged&& from) noexcept
    : ResponseActiveChanged() {
    *this = ::std::move(from);
  }

  inline ResponseActiveChanged& operator=(const ResponseActiveChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseActiveChanged& operator=(ResponseActiveChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseActiveChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseActiveChanged* internal_default_instance() {
    return reinterpret_cast<const ResponseActiveChanged*>(
               &_ResponseActiveChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ResponseActiveChanged& a, ResponseActiveChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseActiveChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseActiveChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseActiveChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseActiveChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseActiveChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseActiveChanged& from) {
    ResponseActiveChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseActiveChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseActiveChanged";
  }
  protected:
  explicit ResponseActiveChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseActiveChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestSetTrackPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestSetTrackPosition) */ {
 public:
  inline RequestSetTrackPosition() : RequestSetTrackPosition(nullptr) {}
  ~RequestSetTrackPosition() override;
  explicit PROTOBUF_CONSTEXPR RequestSetTrackPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSetTrackPosition(const RequestSetTrackPosition& from);
  RequestSetTrackPosition(RequestSetTrackPosition&& from) noexcept
    : RequestSetTrackPosition() {
    *this = ::std::move(from);
  }

  inline RequestSetTrackPosition& operator=(const RequestSetTrackPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSetTrackPosition& operator=(RequestSetTrackPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSetTrackPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSetTrackPosition* internal_default_instance() {
    return reinterpret_cast<const RequestSetTrackPosition*>(
               &_RequestSetTrackPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RequestSetTrackPosition& a, RequestSetTrackPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSetTrackPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSetTrackPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSetTrackPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSetTrackPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSetTrackPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSetTrackPosition& from) {
    RequestSetTrackPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSetTrackPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestSetTrackPosition";
  }
  protected:
  explicit RequestSetTrackPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // optional int32 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  int32_t position() const;
  void set_position(int32_t value);
  private:
  int32_t _internal_position() const;
  void _internal_set_position(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestSetTrackPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestInsertUrls final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestInsertUrls) */ {
 public:
  inline RequestInsertUrls() : RequestInsertUrls(nullptr) {}
  ~RequestInsertUrls() override;
  explicit PROTOBUF_CONSTEXPR RequestInsertUrls(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInsertUrls(const RequestInsertUrls& from);
  RequestInsertUrls(RequestInsertUrls&& from) noexcept
    : RequestInsertUrls() {
    *this = ::std::move(from);
  }

  inline RequestInsertUrls& operator=(const RequestInsertUrls& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInsertUrls& operator=(RequestInsertUrls&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInsertUrls& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInsertUrls* internal_default_instance() {
    return reinterpret_cast<const RequestInsertUrls*>(
               &_RequestInsertUrls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RequestInsertUrls& a, RequestInsertUrls& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInsertUrls* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInsertUrls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInsertUrls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInsertUrls>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInsertUrls& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestInsertUrls& from) {
    RequestInsertUrls::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInsertUrls* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestInsertUrls";
  }
  protected:
  explicit RequestInsertUrls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 2,
    kSongsFieldNumber = 6,
    kNewPlaylistNameFieldNumber = 7,
    kPlaylistIdFieldNumber = 1,
    kPlayNowFieldNumber = 4,
    kEnqueueFieldNumber = 5,
    kPositionFieldNumber = 3,
  };
  // repeated string urls = 2;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // repeated .cpb.remote.SongMetadata songs = 6;
  int songs_size() const;
  private:
  int _internal_songs_size() const;
  public:
  void clear_songs();
  ::cpb::remote::SongMetadata* mutable_songs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >*
      mutable_songs();
  private:
  const ::cpb::remote::SongMetadata& _internal_songs(int index) const;
  ::cpb::remote::SongMetadata* _internal_add_songs();
  public:
  const ::cpb::remote::SongMetadata& songs(int index) const;
  ::cpb::remote::SongMetadata* add_songs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >&
      songs() const;

  // optional string new_playlist_name = 7;
  bool has_new_playlist_name() const;
  private:
  bool _internal_has_new_playlist_name() const;
  public:
  void clear_new_playlist_name();
  const std::string& new_playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_playlist_name();
  PROTOBUF_NODISCARD std::string* release_new_playlist_name();
  void set_allocated_new_playlist_name(std::string* new_playlist_name);
  private:
  const std::string& _internal_new_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_playlist_name(const std::string& value);
  std::string* _internal_mutable_new_playlist_name();
  public:

  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // optional bool play_now = 4 [default = false];
  bool has_play_now() const;
  private:
  bool _internal_has_play_now() const;
  public:
  void clear_play_now();
  bool play_now() const;
  void set_play_now(bool value);
  private:
  bool _internal_play_now() const;
  void _internal_set_play_now(bool value);
  public:

  // optional bool enqueue = 5 [default = false];
  bool has_enqueue() const;
  private:
  bool _internal_has_enqueue() const;
  public:
  void clear_enqueue();
  bool enqueue() const;
  void set_enqueue(bool value);
  private:
  bool _internal_enqueue() const;
  void _internal_set_enqueue(bool value);
  public:

  // optional int32 position = 3 [default = -1];
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  int32_t position() const;
  void set_position(int32_t value);
  private:
  int32_t _internal_position() const;
  void _internal_set_position(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestInsertUrls)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata > songs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_playlist_name_;
    int32_t playlist_id_;
    bool play_now_;
    bool enqueue_;
    int32_t position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestRemoveSongs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestRemoveSongs) */ {
 public:
  inline RequestRemoveSongs() : RequestRemoveSongs(nullptr) {}
  ~RequestRemoveSongs() override;
  explicit PROTOBUF_CONSTEXPR RequestRemoveSongs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestRemoveSongs(const RequestRemoveSongs& from);
  RequestRemoveSongs(RequestRemoveSongs&& from) noexcept
    : RequestRemoveSongs() {
    *this = ::std::move(from);
  }

  inline RequestRemoveSongs& operator=(const RequestRemoveSongs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRemoveSongs& operator=(RequestRemoveSongs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestRemoveSongs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestRemoveSongs* internal_default_instance() {
    return reinterpret_cast<const RequestRemoveSongs*>(
               &_RequestRemoveSongs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RequestRemoveSongs& a, RequestRemoveSongs& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRemoveSongs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestRemoveSongs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestRemoveSongs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestRemoveSongs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestRemoveSongs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestRemoveSongs& from) {
    RequestRemoveSongs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRemoveSongs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestRemoveSongs";
  }
  protected:
  explicit RequestRemoveSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongsFieldNumber = 2,
    kPlaylistIdFieldNumber = 1,
  };
  // repeated int32 songs = 2;
  int songs_size() const;
  private:
  int _internal_songs_size() const;
  public:
  void clear_songs();
  private:
  int32_t _internal_songs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_songs() const;
  void _internal_add_songs(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_songs();
  public:
  int32_t songs(int index) const;
  void set_songs(int index, int32_t value);
  void add_songs(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      songs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_songs();

  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestRemoveSongs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > songs_;
    int32_t playlist_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestOpenPlaylist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestOpenPlaylist) */ {
 public:
  inline RequestOpenPlaylist() : RequestOpenPlaylist(nullptr) {}
  ~RequestOpenPlaylist() override;
  explicit PROTOBUF_CONSTEXPR RequestOpenPlaylist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestOpenPlaylist(const RequestOpenPlaylist& from);
  RequestOpenPlaylist(RequestOpenPlaylist&& from) noexcept
    : RequestOpenPlaylist() {
    *this = ::std::move(from);
  }

  inline RequestOpenPlaylist& operator=(const RequestOpenPlaylist& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestOpenPlaylist& operator=(RequestOpenPlaylist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestOpenPlaylist& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestOpenPlaylist* internal_default_instance() {
    return reinterpret_cast<const RequestOpenPlaylist*>(
               &_RequestOpenPlaylist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RequestOpenPlaylist& a, RequestOpenPlaylist& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestOpenPlaylist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestOpenPlaylist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestOpenPlaylist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestOpenPlaylist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestOpenPlaylist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestOpenPlaylist& from) {
    RequestOpenPlaylist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestOpenPlaylist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestOpenPlaylist";
  }
  protected:
  explicit RequestOpenPlaylist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistIdFieldNumber = 1,
  };
  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestOpenPlaylist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t playlist_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestClosePlaylist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestClosePlaylist) */ {
 public:
  inline RequestClosePlaylist() : RequestClosePlaylist(nullptr) {}
  ~RequestClosePlaylist() override;
  explicit PROTOBUF_CONSTEXPR RequestClosePlaylist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestClosePlaylist(const RequestClosePlaylist& from);
  RequestClosePlaylist(RequestClosePlaylist&& from) noexcept
    : RequestClosePlaylist() {
    *this = ::std::move(from);
  }

  inline RequestClosePlaylist& operator=(const RequestClosePlaylist& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestClosePlaylist& operator=(RequestClosePlaylist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestClosePlaylist& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestClosePlaylist* internal_default_instance() {
    return reinterpret_cast<const RequestClosePlaylist*>(
               &_RequestClosePlaylist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RequestClosePlaylist& a, RequestClosePlaylist& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestClosePlaylist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestClosePlaylist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestClosePlaylist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestClosePlaylist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestClosePlaylist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestClosePlaylist& from) {
    RequestClosePlaylist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestClosePlaylist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestClosePlaylist";
  }
  protected:
  explicit RequestClosePlaylist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistIdFieldNumber = 1,
  };
  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestClosePlaylist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t playlist_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestUpdatePlaylist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestUpdatePlaylist) */ {
 public:
  inline RequestUpdatePlaylist() : RequestUpdatePlaylist(nullptr) {}
  ~RequestUpdatePlaylist() override;
  explicit PROTOBUF_CONSTEXPR RequestUpdatePlaylist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestUpdatePlaylist(const RequestUpdatePlaylist& from);
  RequestUpdatePlaylist(RequestUpdatePlaylist&& from) noexcept
    : RequestUpdatePlaylist() {
    *this = ::std::move(from);
  }

  inline RequestUpdatePlaylist& operator=(const RequestUpdatePlaylist& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestUpdatePlaylist& operator=(RequestUpdatePlaylist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestUpdatePlaylist& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestUpdatePlaylist* internal_default_instance() {
    return reinterpret_cast<const RequestUpdatePlaylist*>(
               &_RequestUpdatePlaylist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RequestUpdatePlaylist& a, RequestUpdatePlaylist& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestUpdatePlaylist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestUpdatePlaylist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestUpdatePlaylist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestUpdatePlaylist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestUpdatePlaylist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestUpdatePlaylist& from) {
    RequestUpdatePlaylist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestUpdatePlaylist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestUpdatePlaylist";
  }
  protected:
  explicit RequestUpdatePlaylist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPlaylistNameFieldNumber = 2,
    kPlaylistIdFieldNumber = 1,
    kFavoriteFieldNumber = 3,
    kCreateNewPlaylistFieldNumber = 4,
    kClearPlaylistFieldNumber = 5,
  };
  // optional string new_playlist_name = 2;
  bool has_new_playlist_name() const;
  private:
  bool _internal_has_new_playlist_name() const;
  public:
  void clear_new_playlist_name();
  const std::string& new_playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_playlist_name();
  PROTOBUF_NODISCARD std::string* release_new_playlist_name();
  void set_allocated_new_playlist_name(std::string* new_playlist_name);
  private:
  const std::string& _internal_new_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_playlist_name(const std::string& value);
  std::string* _internal_mutable_new_playlist_name();
  public:

  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // optional bool favorite = 3;
  bool has_favorite() const;
  private:
  bool _internal_has_favorite() const;
  public:
  void clear_favorite();
  bool favorite() const;
  void set_favorite(bool value);
  private:
  bool _internal_favorite() const;
  void _internal_set_favorite(bool value);
  public:

  // optional bool create_new_playlist = 4;
  bool has_create_new_playlist() const;
  private:
  bool _internal_has_create_new_playlist() const;
  public:
  void clear_create_new_playlist();
  bool create_new_playlist() const;
  void set_create_new_playlist(bool value);
  private:
  bool _internal_create_new_playlist() const;
  void _internal_set_create_new_playlist(bool value);
  public:

  // optional bool clear_playlist = 5;
  bool has_clear_playlist() const;
  private:
  bool _internal_has_clear_playlist() const;
  public:
  void clear_clear_playlist();
  bool clear_playlist() const;
  void set_clear_playlist(bool value);
  private:
  bool _internal_clear_playlist() const;
  void _internal_set_clear_playlist(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestUpdatePlaylist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_playlist_name_;
    int32_t playlist_id_;
    bool favorite_;
    bool create_new_playlist_;
    bool clear_playlist_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseLyrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseLyrics) */ {
 public:
  inline ResponseLyrics() : ResponseLyrics(nullptr) {}
  ~ResponseLyrics() override;
  explicit PROTOBUF_CONSTEXPR ResponseLyrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseLyrics(const ResponseLyrics& from);
  ResponseLyrics(ResponseLyrics&& from) noexcept
    : ResponseLyrics() {
    *this = ::std::move(from);
  }

  inline ResponseLyrics& operator=(const ResponseLyrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLyrics& operator=(ResponseLyrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseLyrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseLyrics* internal_default_instance() {
    return reinterpret_cast<const ResponseLyrics*>(
               &_ResponseLyrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ResponseLyrics& a, ResponseLyrics& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLyrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseLyrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseLyrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseLyrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseLyrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseLyrics& from) {
    ResponseLyrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLyrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseLyrics";
  }
  protected:
  explicit ResponseLyrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLyricsFieldNumber = 1,
  };
  // repeated .cpb.remote.Lyric lyrics = 1;
  int lyrics_size() const;
  private:
  int _internal_lyrics_size() const;
  public:
  void clear_lyrics();
  ::cpb::remote::Lyric* mutable_lyrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Lyric >*
      mutable_lyrics();
  private:
  const ::cpb::remote::Lyric& _internal_lyrics(int index) const;
  ::cpb::remote::Lyric* _internal_add_lyrics();
  public:
  const ::cpb::remote::Lyric& lyrics(int index) const;
  ::cpb::remote::Lyric* add_lyrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Lyric >&
      lyrics() const;

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseLyrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Lyric > lyrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class Lyric final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.Lyric) */ {
 public:
  inline Lyric() : Lyric(nullptr) {}
  ~Lyric() override;
  explicit PROTOBUF_CONSTEXPR Lyric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lyric(const Lyric& from);
  Lyric(Lyric&& from) noexcept
    : Lyric() {
    *this = ::std::move(from);
  }

  inline Lyric& operator=(const Lyric& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lyric& operator=(Lyric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lyric& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lyric* internal_default_instance() {
    return reinterpret_cast<const Lyric*>(
               &_Lyric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Lyric& a, Lyric& b) {
    a.Swap(&b);
  }
  inline void Swap(Lyric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lyric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lyric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lyric>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Lyric& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Lyric& from) {
    Lyric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lyric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.Lyric";
  }
  protected:
  explicit Lyric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kContentFieldNumber = 3,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.Lyric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestDownloadSongs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestDownloadSongs) */ {
 public:
  inline RequestDownloadSongs() : RequestDownloadSongs(nullptr) {}
  ~RequestDownloadSongs() override;
  explicit PROTOBUF_CONSTEXPR RequestDownloadSongs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestDownloadSongs(const RequestDownloadSongs& from);
  RequestDownloadSongs(RequestDownloadSongs&& from) noexcept
    : RequestDownloadSongs() {
    *this = ::std::move(from);
  }

  inline RequestDownloadSongs& operator=(const RequestDownloadSongs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestDownloadSongs& operator=(RequestDownloadSongs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestDownloadSongs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestDownloadSongs* internal_default_instance() {
    return reinterpret_cast<const RequestDownloadSongs*>(
               &_RequestDownloadSongs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RequestDownloadSongs& a, RequestDownloadSongs& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestDownloadSongs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestDownloadSongs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestDownloadSongs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestDownloadSongs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestDownloadSongs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestDownloadSongs& from) {
    RequestDownloadSongs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDownloadSongs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestDownloadSongs";
  }
  protected:
  explicit RequestDownloadSongs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 3,
    kSongsIdsFieldNumber = 4,
    kRelativePathFieldNumber = 5,
    kPlaylistIdFieldNumber = 2,
    kDownloadItemFieldNumber = 1,
  };
  // repeated string urls = 3;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // repeated int32 songs_ids = 4;
  int songs_ids_size() const;
  private:
  int _internal_songs_ids_size() const;
  public:
  void clear_songs_ids();
  private:
  int32_t _internal_songs_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_songs_ids() const;
  void _internal_add_songs_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_songs_ids();
  public:
  int32_t songs_ids(int index) const;
  void set_songs_ids(int index, int32_t value);
  void add_songs_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      songs_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_songs_ids();

  // optional string relative_path = 5;
  bool has_relative_path() const;
  private:
  bool _internal_has_relative_path() const;
  public:
  void clear_relative_path();
  const std::string& relative_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relative_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relative_path();
  PROTOBUF_NODISCARD std::string* release_relative_path();
  void set_allocated_relative_path(std::string* relative_path);
  private:
  const std::string& _internal_relative_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relative_path(const std::string& value);
  std::string* _internal_mutable_relative_path();
  public:

  // optional int32 playlist_id = 2;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // optional .cpb.remote.DownloadItem download_item = 1;
  bool has_download_item() const;
  private:
  bool _internal_has_download_item() const;
  public:
  void clear_download_item();
  ::cpb::remote::DownloadItem download_item() const;
  void set_download_item(::cpb::remote::DownloadItem value);
  private:
  ::cpb::remote::DownloadItem _internal_download_item() const;
  void _internal_set_download_item(::cpb::remote::DownloadItem value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestDownloadSongs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > songs_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relative_path_;
    int32_t playlist_id_;
    int download_item_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseSongFileChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseSongFileChunk) */ {
 public:
  inline ResponseSongFileChunk() : ResponseSongFileChunk(nullptr) {}
  ~ResponseSongFileChunk() override;
  explicit PROTOBUF_CONSTEXPR ResponseSongFileChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseSongFileChunk(const ResponseSongFileChunk& from);
  ResponseSongFileChunk(ResponseSongFileChunk&& from) noexcept
    : ResponseSongFileChunk() {
    *this = ::std::move(from);
  }

  inline ResponseSongFileChunk& operator=(const ResponseSongFileChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseSongFileChunk& operator=(ResponseSongFileChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseSongFileChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseSongFileChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseSongFileChunk*>(
               &_ResponseSongFileChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResponseSongFileChunk& a, ResponseSongFileChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseSongFileChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseSongFileChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseSongFileChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseSongFileChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseSongFileChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseSongFileChunk& from) {
    ResponseSongFileChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSongFileChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseSongFileChunk";
  }
  protected:
  explicit ResponseSongFileChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 7,
    kFileHashFieldNumber = 9,
    kSongMetadataFieldNumber = 6,
    kChunkNumberFieldNumber = 1,
    kChunkCountFieldNumber = 2,
    kFileNumberFieldNumber = 3,
    kFileCountFieldNumber = 4,
    kSizeFieldNumber = 8,
  };
  // optional bytes data = 7;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes file_hash = 9;
  bool has_file_hash() const;
  private:
  bool _internal_has_file_hash() const;
  public:
  void clear_file_hash();
  const std::string& file_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_hash();
  PROTOBUF_NODISCARD std::string* release_file_hash();
  void set_allocated_file_hash(std::string* file_hash);
  private:
  const std::string& _internal_file_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_hash(const std::string& value);
  std::string* _internal_mutable_file_hash();
  public:

  // optional .cpb.remote.SongMetadata song_metadata = 6;
  bool has_song_metadata() const;
  private:
  bool _internal_has_song_metadata() const;
  public:
  void clear_song_metadata();
  const ::cpb::remote::SongMetadata& song_metadata() const;
  PROTOBUF_NODISCARD ::cpb::remote::SongMetadata* release_song_metadata();
  ::cpb::remote::SongMetadata* mutable_song_metadata();
  void set_allocated_song_metadata(::cpb::remote::SongMetadata* song_metadata);
  private:
  const ::cpb::remote::SongMetadata& _internal_song_metadata() const;
  ::cpb::remote::SongMetadata* _internal_mutable_song_metadata();
  public:
  void unsafe_arena_set_allocated_song_metadata(
      ::cpb::remote::SongMetadata* song_metadata);
  ::cpb::remote::SongMetadata* unsafe_arena_release_song_metadata();

  // optional int32 chunk_number = 1;
  bool has_chunk_number() const;
  private:
  bool _internal_has_chunk_number() const;
  public:
  void clear_chunk_number();
  int32_t chunk_number() const;
  void set_chunk_number(int32_t value);
  private:
  int32_t _internal_chunk_number() const;
  void _internal_set_chunk_number(int32_t value);
  public:

  // optional int32 chunk_count = 2;
  bool has_chunk_count() const;
  private:
  bool _internal_has_chunk_count() const;
  public:
  void clear_chunk_count();
  int32_t chunk_count() const;
  void set_chunk_count(int32_t value);
  private:
  int32_t _internal_chunk_count() const;
  void _internal_set_chunk_count(int32_t value);
  public:

  // optional int32 file_number = 3;
  bool has_file_number() const;
  private:
  bool _internal_has_file_number() const;
  public:
  void clear_file_number();
  int32_t file_number() const;
  void set_file_number(int32_t value);
  private:
  int32_t _internal_file_number() const;
  void _internal_set_file_number(int32_t value);
  public:

  // optional int32 file_count = 4;
  bool has_file_count() const;
  private:
  bool _internal_has_file_count() const;
  public:
  void clear_file_count();
  int32_t file_count() const;
  void set_file_count(int32_t value);
  private:
  int32_t _internal_file_count() const;
  void _internal_set_file_count(int32_t value);
  public:

  // optional int32 size = 8;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseSongFileChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_hash_;
    ::cpb::remote::SongMetadata* song_metadata_;
    int32_t chunk_number_;
    int32_t chunk_count_;
    int32_t file_number_;
    int32_t file_count_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseLibraryChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseLibraryChunk) */ {
 public:
  inline ResponseLibraryChunk() : ResponseLibraryChunk(nullptr) {}
  ~ResponseLibraryChunk() override;
  explicit PROTOBUF_CONSTEXPR ResponseLibraryChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseLibraryChunk(const ResponseLibraryChunk& from);
  ResponseLibraryChunk(ResponseLibraryChunk&& from) noexcept
    : ResponseLibraryChunk() {
    *this = ::std::move(from);
  }

  inline ResponseLibraryChunk& operator=(const ResponseLibraryChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLibraryChunk& operator=(ResponseLibraryChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseLibraryChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseLibraryChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseLibraryChunk*>(
               &_ResponseLibraryChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ResponseLibraryChunk& a, ResponseLibraryChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLibraryChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseLibraryChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseLibraryChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseLibraryChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseLibraryChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseLibraryChunk& from) {
    ResponseLibraryChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLibraryChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseLibraryChunk";
  }
  protected:
  explicit ResponseLibraryChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kFileHashFieldNumber = 5,
    kChunkNumberFieldNumber = 1,
    kChunkCountFieldNumber = 2,
    kSizeFieldNumber = 4,
  };
  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes file_hash = 5;
  bool has_file_hash() const;
  private:
  bool _internal_has_file_hash() const;
  public:
  void clear_file_hash();
  const std::string& file_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_hash();
  PROTOBUF_NODISCARD std::string* release_file_hash();
  void set_allocated_file_hash(std::string* file_hash);
  private:
  const std::string& _internal_file_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_hash(const std::string& value);
  std::string* _internal_mutable_file_hash();
  public:

  // optional int32 chunk_number = 1;
  bool has_chunk_number() const;
  private:
  bool _internal_has_chunk_number() const;
  public:
  void clear_chunk_number();
  int32_t chunk_number() const;
  void set_chunk_number(int32_t value);
  private:
  int32_t _internal_chunk_number() const;
  void _internal_set_chunk_number(int32_t value);
  public:

  // optional int32 chunk_count = 2;
  bool has_chunk_count() const;
  private:
  bool _internal_has_chunk_count() const;
  public:
  void clear_chunk_count();
  int32_t chunk_count() const;
  void set_chunk_count(int32_t value);
  private:
  int32_t _internal_chunk_count() const;
  void _internal_set_chunk_count(int32_t value);
  public:

  // optional int32 size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseLibraryChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_hash_;
    int32_t chunk_number_;
    int32_t chunk_count_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseSongOffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseSongOffer) */ {
 public:
  inline ResponseSongOffer() : ResponseSongOffer(nullptr) {}
  ~ResponseSongOffer() override;
  explicit PROTOBUF_CONSTEXPR ResponseSongOffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseSongOffer(const ResponseSongOffer& from);
  ResponseSongOffer(ResponseSongOffer&& from) noexcept
    : ResponseSongOffer() {
    *this = ::std::move(from);
  }

  inline ResponseSongOffer& operator=(const ResponseSongOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseSongOffer& operator=(ResponseSongOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseSongOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseSongOffer* internal_default_instance() {
    return reinterpret_cast<const ResponseSongOffer*>(
               &_ResponseSongOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ResponseSongOffer& a, ResponseSongOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseSongOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseSongOffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseSongOffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseSongOffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseSongOffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseSongOffer& from) {
    ResponseSongOffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSongOffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseSongOffer";
  }
  protected:
  explicit ResponseSongOffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptedFieldNumber = 1,
  };
  // optional bool accepted = 1;
  bool has_accepted() const;
  private:
  bool _internal_has_accepted() const;
  public:
  void clear_accepted();
  bool accepted() const;
  void set_accepted(bool value);
  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseSongOffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool accepted_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestRateSong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestRateSong) */ {
 public:
  inline RequestRateSong() : RequestRateSong(nullptr) {}
  ~RequestRateSong() override;
  explicit PROTOBUF_CONSTEXPR RequestRateSong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestRateSong(const RequestRateSong& from);
  RequestRateSong(RequestRateSong&& from) noexcept
    : RequestRateSong() {
    *this = ::std::move(from);
  }

  inline RequestRateSong& operator=(const RequestRateSong& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRateSong& operator=(RequestRateSong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestRateSong& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestRateSong* internal_default_instance() {
    return reinterpret_cast<const RequestRateSong*>(
               &_RequestRateSong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RequestRateSong& a, RequestRateSong& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRateSong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestRateSong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestRateSong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestRateSong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestRateSong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestRateSong& from) {
    RequestRateSong::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRateSong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestRateSong";
  }
  protected:
  explicit RequestRateSong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRatingFieldNumber = 1,
  };
  // optional float rating = 1;
  bool has_rating() const;
  private:
  bool _internal_has_rating() const;
  public:
  void clear_rating();
  float rating() const;
  void set_rating(float value);
  private:
  float _internal_rating() const;
  void _internal_set_rating(float value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestRateSong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float rating_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseDownloadTotalSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseDownloadTotalSize) */ {
 public:
  inline ResponseDownloadTotalSize() : ResponseDownloadTotalSize(nullptr) {}
  ~ResponseDownloadTotalSize() override;
  explicit PROTOBUF_CONSTEXPR ResponseDownloadTotalSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseDownloadTotalSize(const ResponseDownloadTotalSize& from);
  ResponseDownloadTotalSize(ResponseDownloadTotalSize&& from) noexcept
    : ResponseDownloadTotalSize() {
    *this = ::std::move(from);
  }

  inline ResponseDownloadTotalSize& operator=(const ResponseDownloadTotalSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDownloadTotalSize& operator=(ResponseDownloadTotalSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseDownloadTotalSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseDownloadTotalSize* internal_default_instance() {
    return reinterpret_cast<const ResponseDownloadTotalSize*>(
               &_ResponseDownloadTotalSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResponseDownloadTotalSize& a, ResponseDownloadTotalSize& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDownloadTotalSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseDownloadTotalSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseDownloadTotalSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseDownloadTotalSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseDownloadTotalSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseDownloadTotalSize& from) {
    ResponseDownloadTotalSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDownloadTotalSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseDownloadTotalSize";
  }
  protected:
  explicit ResponseDownloadTotalSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalSizeFieldNumber = 1,
    kFileCountFieldNumber = 2,
  };
  // optional int32 total_size = 1;
  bool has_total_size() const;
  private:
  bool _internal_has_total_size() const;
  public:
  void clear_total_size();
  int32_t total_size() const;
  void set_total_size(int32_t value);
  private:
  int32_t _internal_total_size() const;
  void _internal_set_total_size(int32_t value);
  public:

  // optional int32 file_count = 2;
  bool has_file_count() const;
  private:
  bool _internal_has_file_count() const;
  public:
  void clear_file_count();
  int32_t file_count() const;
  void set_file_count(int32_t value);
  private:
  int32_t _internal_file_count() const;
  void _internal_set_file_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseDownloadTotalSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t total_size_;
    int32_t file_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestGlobalSearch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestGlobalSearch) */ {
 public:
  inline RequestGlobalSearch() : RequestGlobalSearch(nullptr) {}
  ~RequestGlobalSearch() override;
  explicit PROTOBUF_CONSTEXPR RequestGlobalSearch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestGlobalSearch(const RequestGlobalSearch& from);
  RequestGlobalSearch(RequestGlobalSearch&& from) noexcept
    : RequestGlobalSearch() {
    *this = ::std::move(from);
  }

  inline RequestGlobalSearch& operator=(const RequestGlobalSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestGlobalSearch& operator=(RequestGlobalSearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestGlobalSearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestGlobalSearch* internal_default_instance() {
    return reinterpret_cast<const RequestGlobalSearch*>(
               &_RequestGlobalSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RequestGlobalSearch& a, RequestGlobalSearch& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestGlobalSearch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestGlobalSearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestGlobalSearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestGlobalSearch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestGlobalSearch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestGlobalSearch& from) {
    RequestGlobalSearch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestGlobalSearch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestGlobalSearch";
  }
  protected:
  explicit RequestGlobalSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
  };
  // optional string query = 1;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestGlobalSearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseGlobalSearch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseGlobalSearch) */ {
 public:
  inline ResponseGlobalSearch() : ResponseGlobalSearch(nullptr) {}
  ~ResponseGlobalSearch() override;
  explicit PROTOBUF_CONSTEXPR ResponseGlobalSearch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseGlobalSearch(const ResponseGlobalSearch& from);
  ResponseGlobalSearch(ResponseGlobalSearch&& from) noexcept
    : ResponseGlobalSearch() {
    *this = ::std::move(from);
  }

  inline ResponseGlobalSearch& operator=(const ResponseGlobalSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseGlobalSearch& operator=(ResponseGlobalSearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseGlobalSearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseGlobalSearch* internal_default_instance() {
    return reinterpret_cast<const ResponseGlobalSearch*>(
               &_ResponseGlobalSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ResponseGlobalSearch& a, ResponseGlobalSearch& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseGlobalSearch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseGlobalSearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseGlobalSearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseGlobalSearch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseGlobalSearch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseGlobalSearch& from) {
    ResponseGlobalSearch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseGlobalSearch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseGlobalSearch";
  }
  protected:
  explicit ResponseGlobalSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSongMetadataFieldNumber = 4,
    kQueryFieldNumber = 2,
    kSearchProviderFieldNumber = 3,
    kSearchProviderIconFieldNumber = 5,
    kIdFieldNumber = 1,
  };
  // repeated .cpb.remote.SongMetadata song_metadata = 4;
  int song_metadata_size() const;
  private:
  int _internal_song_metadata_size() const;
  public:
  void clear_song_metadata();
  ::cpb::remote::SongMetadata* mutable_song_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >*
      mutable_song_metadata();
  private:
  const ::cpb::remote::SongMetadata& _internal_song_metadata(int index) const;
  ::cpb::remote::SongMetadata* _internal_add_song_metadata();
  public:
  const ::cpb::remote::SongMetadata& song_metadata(int index) const;
  ::cpb::remote::SongMetadata* add_song_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >&
      song_metadata() const;

  // optional string query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // optional string search_provider = 3;
  bool has_search_provider() const;
  private:
  bool _internal_has_search_provider() const;
  public:
  void clear_search_provider();
  const std::string& search_provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_provider();
  PROTOBUF_NODISCARD std::string* release_search_provider();
  void set_allocated_search_provider(std::string* search_provider);
  private:
  const std::string& _internal_search_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_provider(const std::string& value);
  std::string* _internal_mutable_search_provider();
  public:

  // optional bytes search_provider_icon = 5;
  bool has_search_provider_icon() const;
  private:
  bool _internal_has_search_provider_icon() const;
  public:
  void clear_search_provider_icon();
  const std::string& search_provider_icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_provider_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_provider_icon();
  PROTOBUF_NODISCARD std::string* release_search_provider_icon();
  void set_allocated_search_provider_icon(std::string* search_provider_icon);
  private:
  const std::string& _internal_search_provider_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_provider_icon(const std::string& value);
  std::string* _internal_mutable_search_provider_icon();
  public:

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseGlobalSearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata > song_metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_provider_icon_;
    int32_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseTranscoderStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseTranscoderStatus) */ {
 public:
  inline ResponseTranscoderStatus() : ResponseTranscoderStatus(nullptr) {}
  ~ResponseTranscoderStatus() override;
  explicit PROTOBUF_CONSTEXPR ResponseTranscoderStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseTranscoderStatus(const ResponseTranscoderStatus& from);
  ResponseTranscoderStatus(ResponseTranscoderStatus&& from) noexcept
    : ResponseTranscoderStatus() {
    *this = ::std::move(from);
  }

  inline ResponseTranscoderStatus& operator=(const ResponseTranscoderStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseTranscoderStatus& operator=(ResponseTranscoderStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseTranscoderStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseTranscoderStatus* internal_default_instance() {
    return reinterpret_cast<const ResponseTranscoderStatus*>(
               &_ResponseTranscoderStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ResponseTranscoderStatus& a, ResponseTranscoderStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseTranscoderStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseTranscoderStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseTranscoderStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseTranscoderStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseTranscoderStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseTranscoderStatus& from) {
    ResponseTranscoderStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseTranscoderStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseTranscoderStatus";
  }
  protected:
  explicit ResponseTranscoderStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessedFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // optional int32 processed = 1;
  bool has_processed() const;
  private:
  bool _internal_has_processed() const;
  public:
  void clear_processed();
  int32_t processed() const;
  void set_processed(int32_t value);
  private:
  int32_t _internal_processed() const;
  void _internal_set_processed(int32_t value);
  public:

  // optional int32 total = 2;
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  int32_t total() const;
  void set_total(int32_t value);
  private:
  int32_t _internal_total() const;
  void _internal_set_total(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseTranscoderStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t processed_;
    int32_t total_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseGlobalSearchStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseGlobalSearchStatus) */ {
 public:
  inline ResponseGlobalSearchStatus() : ResponseGlobalSearchStatus(nullptr) {}
  ~ResponseGlobalSearchStatus() override;
  explicit PROTOBUF_CONSTEXPR ResponseGlobalSearchStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseGlobalSearchStatus(const ResponseGlobalSearchStatus& from);
  ResponseGlobalSearchStatus(ResponseGlobalSearchStatus&& from) noexcept
    : ResponseGlobalSearchStatus() {
    *this = ::std::move(from);
  }

  inline ResponseGlobalSearchStatus& operator=(const ResponseGlobalSearchStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseGlobalSearchStatus& operator=(ResponseGlobalSearchStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseGlobalSearchStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseGlobalSearchStatus* internal_default_instance() {
    return reinterpret_cast<const ResponseGlobalSearchStatus*>(
               &_ResponseGlobalSearchStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ResponseGlobalSearchStatus& a, ResponseGlobalSearchStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseGlobalSearchStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseGlobalSearchStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseGlobalSearchStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseGlobalSearchStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseGlobalSearchStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseGlobalSearchStatus& from) {
    ResponseGlobalSearchStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseGlobalSearchStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseGlobalSearchStatus";
  }
  protected:
  explicit ResponseGlobalSearchStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 2,
    kIdFieldNumber = 1,
    kStatusFieldNumber = 3,
  };
  // optional string query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional .cpb.remote.GlobalSearchStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::cpb::remote::GlobalSearchStatus status() const;
  void set_status(::cpb::remote::GlobalSearchStatus value);
  private:
  ::cpb::remote::GlobalSearchStatus _internal_status() const;
  void _internal_set_status(::cpb::remote::GlobalSearchStatus value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseGlobalSearchStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    int32_t id_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestListFiles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestListFiles) */ {
 public:
  inline RequestListFiles() : RequestListFiles(nullptr) {}
  ~RequestListFiles() override;
  explicit PROTOBUF_CONSTEXPR RequestListFiles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestListFiles(const RequestListFiles& from);
  RequestListFiles(RequestListFiles&& from) noexcept
    : RequestListFiles() {
    *this = ::std::move(from);
  }

  inline RequestListFiles& operator=(const RequestListFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestListFiles& operator=(RequestListFiles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestListFiles& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestListFiles* internal_default_instance() {
    return reinterpret_cast<const RequestListFiles*>(
               &_RequestListFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RequestListFiles& a, RequestListFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestListFiles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestListFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestListFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestListFiles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestListFiles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestListFiles& from) {
    RequestListFiles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestListFiles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestListFiles";
  }
  protected:
  explicit RequestListFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativePathFieldNumber = 1,
  };
  // optional string relative_path = 1;
  bool has_relative_path() const;
  private:
  bool _internal_has_relative_path() const;
  public:
  void clear_relative_path();
  const std::string& relative_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relative_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relative_path();
  PROTOBUF_NODISCARD std::string* release_relative_path();
  void set_allocated_relative_path(std::string* relative_path);
  private:
  const std::string& _internal_relative_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relative_path(const std::string& value);
  std::string* _internal_mutable_relative_path();
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestListFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relative_path_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class FileMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.FileMetadata) */ {
 public:
  inline FileMetadata() : FileMetadata(nullptr) {}
  ~FileMetadata() override;
  explicit PROTOBUF_CONSTEXPR FileMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileMetadata(const FileMetadata& from);
  FileMetadata(FileMetadata&& from) noexcept
    : FileMetadata() {
    *this = ::std::move(from);
  }

  inline FileMetadata& operator=(const FileMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMetadata& operator=(FileMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMetadata* internal_default_instance() {
    return reinterpret_cast<const FileMetadata*>(
               &_FileMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(FileMetadata& a, FileMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileMetadata& from) {
    FileMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.FileMetadata";
  }
  protected:
  explicit FileMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kIsDirFieldNumber = 2,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional bool is_dir = 2;
  bool has_is_dir() const;
  private:
  bool _internal_has_is_dir() const;
  public:
  void clear_is_dir();
  bool is_dir() const;
  void set_is_dir(bool value);
  private:
  bool _internal_is_dir() const;
  void _internal_set_is_dir(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.FileMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    bool is_dir_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseListFiles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseListFiles) */ {
 public:
  inline ResponseListFiles() : ResponseListFiles(nullptr) {}
  ~ResponseListFiles() override;
  explicit PROTOBUF_CONSTEXPR ResponseListFiles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseListFiles(const ResponseListFiles& from);
  ResponseListFiles(ResponseListFiles&& from) noexcept
    : ResponseListFiles() {
    *this = ::std::move(from);
  }

  inline ResponseListFiles& operator=(const ResponseListFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseListFiles& operator=(ResponseListFiles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseListFiles& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseListFiles* internal_default_instance() {
    return reinterpret_cast<const ResponseListFiles*>(
               &_ResponseListFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ResponseListFiles& a, ResponseListFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseListFiles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseListFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseListFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseListFiles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseListFiles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseListFiles& from) {
    ResponseListFiles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseListFiles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseListFiles";
  }
  protected:
  explicit ResponseListFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseListFiles_Error Error;
  static constexpr Error NONE =
    ResponseListFiles_Error_NONE;
  static constexpr Error ROOT_DIR_NOT_SET =
    ResponseListFiles_Error_ROOT_DIR_NOT_SET;
  static constexpr Error DIR_NOT_ACCESSIBLE =
    ResponseListFiles_Error_DIR_NOT_ACCESSIBLE;
  static constexpr Error DIR_NOT_EXIST =
    ResponseListFiles_Error_DIR_NOT_EXIST;
  static constexpr Error UNKNOWN =
    ResponseListFiles_Error_UNKNOWN;
  static inline bool Error_IsValid(int value) {
    return ResponseListFiles_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseListFiles_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseListFiles_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseListFiles_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseListFiles_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseListFiles_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return ResponseListFiles_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kRelativePathFieldNumber = 1,
    kErrorFieldNumber = 3,
  };
  // repeated .cpb.remote.FileMetadata files = 2;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::cpb::remote::FileMetadata* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::FileMetadata >*
      mutable_files();
  private:
  const ::cpb::remote::FileMetadata& _internal_files(int index) const;
  ::cpb::remote::FileMetadata* _internal_add_files();
  public:
  const ::cpb::remote::FileMetadata& files(int index) const;
  ::cpb::remote::FileMetadata* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::FileMetadata >&
      files() const;

  // optional string relative_path = 1;
  bool has_relative_path() const;
  private:
  bool _internal_has_relative_path() const;
  public:
  void clear_relative_path();
  const std::string& relative_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relative_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relative_path();
  PROTOBUF_NODISCARD std::string* release_relative_path();
  void set_allocated_relative_path(std::string* relative_path);
  private:
  const std::string& _internal_relative_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relative_path(const std::string& value);
  std::string* _internal_mutable_relative_path();
  public:

  // optional .cpb.remote.ResponseListFiles.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::cpb::remote::ResponseListFiles_Error error() const;
  void set_error(::cpb::remote::ResponseListFiles_Error value);
  private:
  ::cpb::remote::ResponseListFiles_Error _internal_error() const;
  void _internal_set_error(::cpb::remote::ResponseListFiles_Error value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseListFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::FileMetadata > files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relative_path_;
    int error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class RequestAppendFiles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.RequestAppendFiles) */ {
 public:
  inline RequestAppendFiles() : RequestAppendFiles(nullptr) {}
  ~RequestAppendFiles() override;
  explicit PROTOBUF_CONSTEXPR RequestAppendFiles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestAppendFiles(const RequestAppendFiles& from);
  RequestAppendFiles(RequestAppendFiles&& from) noexcept
    : RequestAppendFiles() {
    *this = ::std::move(from);
  }

  inline RequestAppendFiles& operator=(const RequestAppendFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAppendFiles& operator=(RequestAppendFiles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestAppendFiles& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestAppendFiles* internal_default_instance() {
    return reinterpret_cast<const RequestAppendFiles*>(
               &_RequestAppendFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(RequestAppendFiles& a, RequestAppendFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAppendFiles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestAppendFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestAppendFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestAppendFiles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestAppendFiles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestAppendFiles& from) {
    RequestAppendFiles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAppendFiles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.RequestAppendFiles";
  }
  protected:
  explicit RequestAppendFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 4,
    kNewPlaylistNameFieldNumber = 2,
    kRelativePathFieldNumber = 3,
    kPlaylistIdFieldNumber = 1,
    kPlayNowFieldNumber = 5,
    kClearFirstFieldNumber = 6,
  };
  // repeated string files = 4;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  const std::string& files(int index) const;
  std::string* mutable_files(int index);
  void set_files(int index, const std::string& value);
  void set_files(int index, std::string&& value);
  void set_files(int index, const char* value);
  void set_files(int index, const char* value, size_t size);
  std::string* add_files();
  void add_files(const std::string& value);
  void add_files(std::string&& value);
  void add_files(const char* value);
  void add_files(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_files();
  private:
  const std::string& _internal_files(int index) const;
  std::string* _internal_add_files();
  public:

  // optional string new_playlist_name = 2;
  bool has_new_playlist_name() const;
  private:
  bool _internal_has_new_playlist_name() const;
  public:
  void clear_new_playlist_name();
  const std::string& new_playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_playlist_name();
  PROTOBUF_NODISCARD std::string* release_new_playlist_name();
  void set_allocated_new_playlist_name(std::string* new_playlist_name);
  private:
  const std::string& _internal_new_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_playlist_name(const std::string& value);
  std::string* _internal_mutable_new_playlist_name();
  public:

  // optional string relative_path = 3;
  bool has_relative_path() const;
  private:
  bool _internal_has_relative_path() const;
  public:
  void clear_relative_path();
  const std::string& relative_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relative_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relative_path();
  PROTOBUF_NODISCARD std::string* release_relative_path();
  void set_allocated_relative_path(std::string* relative_path);
  private:
  const std::string& _internal_relative_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relative_path(const std::string& value);
  std::string* _internal_mutable_relative_path();
  public:

  // optional int32 playlist_id = 1;
  bool has_playlist_id() const;
  private:
  bool _internal_has_playlist_id() const;
  public:
  void clear_playlist_id();
  int32_t playlist_id() const;
  void set_playlist_id(int32_t value);
  private:
  int32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(int32_t value);
  public:

  // optional bool play_now = 5;
  bool has_play_now() const;
  private:
  bool _internal_has_play_now() const;
  public:
  void clear_play_now();
  bool play_now() const;
  void set_play_now(bool value);
  private:
  bool _internal_play_now() const;
  void _internal_set_play_now(bool value);
  public:

  // optional bool clear_first = 6;
  bool has_clear_first() const;
  private:
  bool _internal_has_clear_first() const;
  public:
  void clear_clear_first();
  bool clear_first() const;
  void set_clear_first(bool value);
  private:
  bool _internal_clear_first() const;
  void _internal_set_clear_first(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.RequestAppendFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> files_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_playlist_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relative_path_;
    int32_t playlist_id_;
    bool play_now_;
    bool clear_first_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class Stream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {}
  ~Stream() override;
  explicit PROTOBUF_CONSTEXPR Stream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stream& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stream& from) {
    Stream::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kUrlLogoFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string url_logo = 3;
  bool has_url_logo() const;
  private:
  bool _internal_has_url_logo() const;
  public:
  void clear_url_logo();
  const std::string& url_logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_logo();
  PROTOBUF_NODISCARD std::string* release_url_logo();
  void set_allocated_url_logo(std::string* url_logo);
  private:
  const std::string& _internal_url_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_logo(const std::string& value);
  std::string* _internal_mutable_url_logo();
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_logo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class ResponseSavedRadios final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.ResponseSavedRadios) */ {
 public:
  inline ResponseSavedRadios() : ResponseSavedRadios(nullptr) {}
  ~ResponseSavedRadios() override;
  explicit PROTOBUF_CONSTEXPR ResponseSavedRadios(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseSavedRadios(const ResponseSavedRadios& from);
  ResponseSavedRadios(ResponseSavedRadios&& from) noexcept
    : ResponseSavedRadios() {
    *this = ::std::move(from);
  }

  inline ResponseSavedRadios& operator=(const ResponseSavedRadios& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseSavedRadios& operator=(ResponseSavedRadios&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseSavedRadios& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseSavedRadios* internal_default_instance() {
    return reinterpret_cast<const ResponseSavedRadios*>(
               &_ResponseSavedRadios_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ResponseSavedRadios& a, ResponseSavedRadios& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseSavedRadios* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseSavedRadios* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseSavedRadios* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseSavedRadios>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseSavedRadios& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseSavedRadios& from) {
    ResponseSavedRadios::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSavedRadios* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.ResponseSavedRadios";
  }
  protected:
  explicit ResponseSavedRadios(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 1,
  };
  // repeated .cpb.remote.Stream streams = 1;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::cpb::remote::Stream* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Stream >*
      mutable_streams();
  private:
  const ::cpb::remote::Stream& _internal_streams(int index) const;
  ::cpb::remote::Stream* _internal_add_streams();
  public:
  const ::cpb::remote::Stream& streams(int index) const;
  ::cpb::remote::Stream* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Stream >&
      streams() const;

  // @@protoc_insertion_point(class_scope:cpb.remote.ResponseSavedRadios)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Stream > streams_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cpb.remote.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cpb.remote.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestPlaylistSongsFieldNumber = 10,
    kRequestChangeSongFieldNumber = 11,
    kRequestSetVolumeFieldNumber = 12,
    kRepeatFieldNumber = 13,
    kShuffleFieldNumber = 14,
    kResponseClementineInfoFieldNumber = 15,
    kResponseCurrentMetadataFieldNumber = 16,
    kResponsePlaylistsFieldNumber = 17,
    kResponsePlaylistSongsFieldNumber = 18,
    kResponseEngineStateChangedFieldNumber = 19,
    kResponseUpdateTrackPositionFieldNumber = 20,
    kRequestConnectFieldNumber = 21,
    kResponseDisconnectFieldNumber = 22,
    kRequestSetTrackPositionFieldNumber = 23,
    kResponseActiveChangedFieldNumber = 24,
    kRequestInsertUrlsFieldNumber = 25,
    kRequestRemoveSongsFieldNumber = 26,
    kRequestPlaylistsFieldNumber = 27,
    kRequestOpenPlaylistFieldNumber = 28,
    kRequestClosePlaylistFieldNumber = 29,
    kResponseLyricsFieldNumber = 30,
    kRequestDownloadSongsFieldNumber = 31,
    kResponseSongFileChunkFieldNumber = 32,
    kResponseSongOfferFieldNumber = 33,
    kResponseLibraryChunkFieldNumber = 34,
    kRequestRateSongFieldNumber = 35,
    kResponseDownloadTotalSizeFieldNumber = 36,
    kRequestGlobalSearchFieldNumber = 37,
    kResponseGlobalSearchFieldNumber = 38,
    kResponseTranscoderStatusFieldNumber = 39,
    kResponseGlobalSearchStatusFieldNumber = 40,
    kRequestListFilesFieldNumber = 50,
    kRequestAppendFilesFieldNumber = 51,
    kResponseListFilesFieldNumber = 52,
    kRequestUpdatePlaylistFieldNumber = 53,
    kResponseSavedRadiosFieldNumber = 54,
    kTypeFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // optional .cpb.remote.RequestPlaylistSongs request_playlist_songs = 10;
  bool has_request_playlist_songs() const;
  private:
  bool _internal_has_request_playlist_songs() const;
  public:
  void clear_request_playlist_songs();
  const ::cpb::remote::RequestPlaylistSongs& request_playlist_songs() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestPlaylistSongs* release_request_playlist_songs();
  ::cpb::remote::RequestPlaylistSongs* mutable_request_playlist_songs();
  void set_allocated_request_playlist_songs(::cpb::remote::RequestPlaylistSongs* request_playlist_songs);
  private:
  const ::cpb::remote::RequestPlaylistSongs& _internal_request_playlist_songs() const;
  ::cpb::remote::RequestPlaylistSongs* _internal_mutable_request_playlist_songs();
  public:
  void unsafe_arena_set_allocated_request_playlist_songs(
      ::cpb::remote::RequestPlaylistSongs* request_playlist_songs);
  ::cpb::remote::RequestPlaylistSongs* unsafe_arena_release_request_playlist_songs();

  // optional .cpb.remote.RequestChangeSong request_change_song = 11;
  bool has_request_change_song() const;
  private:
  bool _internal_has_request_change_song() const;
  public:
  void clear_request_change_song();
  const ::cpb::remote::RequestChangeSong& request_change_song() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestChangeSong* release_request_change_song();
  ::cpb::remote::RequestChangeSong* mutable_request_change_song();
  void set_allocated_request_change_song(::cpb::remote::RequestChangeSong* request_change_song);
  private:
  const ::cpb::remote::RequestChangeSong& _internal_request_change_song() const;
  ::cpb::remote::RequestChangeSong* _internal_mutable_request_change_song();
  public:
  void unsafe_arena_set_allocated_request_change_song(
      ::cpb::remote::RequestChangeSong* request_change_song);
  ::cpb::remote::RequestChangeSong* unsafe_arena_release_request_change_song();

  // optional .cpb.remote.RequestSetVolume request_set_volume = 12;
  bool has_request_set_volume() const;
  private:
  bool _internal_has_request_set_volume() const;
  public:
  void clear_request_set_volume();
  const ::cpb::remote::RequestSetVolume& request_set_volume() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestSetVolume* release_request_set_volume();
  ::cpb::remote::RequestSetVolume* mutable_request_set_volume();
  void set_allocated_request_set_volume(::cpb::remote::RequestSetVolume* request_set_volume);
  private:
  const ::cpb::remote::RequestSetVolume& _internal_request_set_volume() const;
  ::cpb::remote::RequestSetVolume* _internal_mutable_request_set_volume();
  public:
  void unsafe_arena_set_allocated_request_set_volume(
      ::cpb::remote::RequestSetVolume* request_set_volume);
  ::cpb::remote::RequestSetVolume* unsafe_arena_release_request_set_volume();

  // optional .cpb.remote.Repeat repeat = 13;
  bool has_repeat() const;
  private:
  bool _internal_has_repeat() const;
  public:
  void clear_repeat();
  const ::cpb::remote::Repeat& repeat() const;
  PROTOBUF_NODISCARD ::cpb::remote::Repeat* release_repeat();
  ::cpb::remote::Repeat* mutable_repeat();
  void set_allocated_repeat(::cpb::remote::Repeat* repeat);
  private:
  const ::cpb::remote::Repeat& _internal_repeat() const;
  ::cpb::remote::Repeat* _internal_mutable_repeat();
  public:
  void unsafe_arena_set_allocated_repeat(
      ::cpb::remote::Repeat* repeat);
  ::cpb::remote::Repeat* unsafe_arena_release_repeat();

  // optional .cpb.remote.Shuffle shuffle = 14;
  bool has_shuffle() const;
  private:
  bool _internal_has_shuffle() const;
  public:
  void clear_shuffle();
  const ::cpb::remote::Shuffle& shuffle() const;
  PROTOBUF_NODISCARD ::cpb::remote::Shuffle* release_shuffle();
  ::cpb::remote::Shuffle* mutable_shuffle();
  void set_allocated_shuffle(::cpb::remote::Shuffle* shuffle);
  private:
  const ::cpb::remote::Shuffle& _internal_shuffle() const;
  ::cpb::remote::Shuffle* _internal_mutable_shuffle();
  public:
  void unsafe_arena_set_allocated_shuffle(
      ::cpb::remote::Shuffle* shuffle);
  ::cpb::remote::Shuffle* unsafe_arena_release_shuffle();

  // optional .cpb.remote.ResponseClementineInfo response_clementine_info = 15;
  bool has_response_clementine_info() const;
  private:
  bool _internal_has_response_clementine_info() const;
  public:
  void clear_response_clementine_info();
  const ::cpb::remote::ResponseClementineInfo& response_clementine_info() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseClementineInfo* release_response_clementine_info();
  ::cpb::remote::ResponseClementineInfo* mutable_response_clementine_info();
  void set_allocated_response_clementine_info(::cpb::remote::ResponseClementineInfo* response_clementine_info);
  private:
  const ::cpb::remote::ResponseClementineInfo& _internal_response_clementine_info() const;
  ::cpb::remote::ResponseClementineInfo* _internal_mutable_response_clementine_info();
  public:
  void unsafe_arena_set_allocated_response_clementine_info(
      ::cpb::remote::ResponseClementineInfo* response_clementine_info);
  ::cpb::remote::ResponseClementineInfo* unsafe_arena_release_response_clementine_info();

  // optional .cpb.remote.ResponseCurrentMetadata response_current_metadata = 16;
  bool has_response_current_metadata() const;
  private:
  bool _internal_has_response_current_metadata() const;
  public:
  void clear_response_current_metadata();
  const ::cpb::remote::ResponseCurrentMetadata& response_current_metadata() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseCurrentMetadata* release_response_current_metadata();
  ::cpb::remote::ResponseCurrentMetadata* mutable_response_current_metadata();
  void set_allocated_response_current_metadata(::cpb::remote::ResponseCurrentMetadata* response_current_metadata);
  private:
  const ::cpb::remote::ResponseCurrentMetadata& _internal_response_current_metadata() const;
  ::cpb::remote::ResponseCurrentMetadata* _internal_mutable_response_current_metadata();
  public:
  void unsafe_arena_set_allocated_response_current_metadata(
      ::cpb::remote::ResponseCurrentMetadata* response_current_metadata);
  ::cpb::remote::ResponseCurrentMetadata* unsafe_arena_release_response_current_metadata();

  // optional .cpb.remote.ResponsePlaylists response_playlists = 17;
  bool has_response_playlists() const;
  private:
  bool _internal_has_response_playlists() const;
  public:
  void clear_response_playlists();
  const ::cpb::remote::ResponsePlaylists& response_playlists() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponsePlaylists* release_response_playlists();
  ::cpb::remote::ResponsePlaylists* mutable_response_playlists();
  void set_allocated_response_playlists(::cpb::remote::ResponsePlaylists* response_playlists);
  private:
  const ::cpb::remote::ResponsePlaylists& _internal_response_playlists() const;
  ::cpb::remote::ResponsePlaylists* _internal_mutable_response_playlists();
  public:
  void unsafe_arena_set_allocated_response_playlists(
      ::cpb::remote::ResponsePlaylists* response_playlists);
  ::cpb::remote::ResponsePlaylists* unsafe_arena_release_response_playlists();

  // optional .cpb.remote.ResponsePlaylistSongs response_playlist_songs = 18;
  bool has_response_playlist_songs() const;
  private:
  bool _internal_has_response_playlist_songs() const;
  public:
  void clear_response_playlist_songs();
  const ::cpb::remote::ResponsePlaylistSongs& response_playlist_songs() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponsePlaylistSongs* release_response_playlist_songs();
  ::cpb::remote::ResponsePlaylistSongs* mutable_response_playlist_songs();
  void set_allocated_response_playlist_songs(::cpb::remote::ResponsePlaylistSongs* response_playlist_songs);
  private:
  const ::cpb::remote::ResponsePlaylistSongs& _internal_response_playlist_songs() const;
  ::cpb::remote::ResponsePlaylistSongs* _internal_mutable_response_playlist_songs();
  public:
  void unsafe_arena_set_allocated_response_playlist_songs(
      ::cpb::remote::ResponsePlaylistSongs* response_playlist_songs);
  ::cpb::remote::ResponsePlaylistSongs* unsafe_arena_release_response_playlist_songs();

  // optional .cpb.remote.ResponseEngineStateChanged response_engine_state_changed = 19;
  bool has_response_engine_state_changed() const;
  private:
  bool _internal_has_response_engine_state_changed() const;
  public:
  void clear_response_engine_state_changed();
  const ::cpb::remote::ResponseEngineStateChanged& response_engine_state_changed() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseEngineStateChanged* release_response_engine_state_changed();
  ::cpb::remote::ResponseEngineStateChanged* mutable_response_engine_state_changed();
  void set_allocated_response_engine_state_changed(::cpb::remote::ResponseEngineStateChanged* response_engine_state_changed);
  private:
  const ::cpb::remote::ResponseEngineStateChanged& _internal_response_engine_state_changed() const;
  ::cpb::remote::ResponseEngineStateChanged* _internal_mutable_response_engine_state_changed();
  public:
  void unsafe_arena_set_allocated_response_engine_state_changed(
      ::cpb::remote::ResponseEngineStateChanged* response_engine_state_changed);
  ::cpb::remote::ResponseEngineStateChanged* unsafe_arena_release_response_engine_state_changed();

  // optional .cpb.remote.ResponseUpdateTrackPosition response_update_track_position = 20;
  bool has_response_update_track_position() const;
  private:
  bool _internal_has_response_update_track_position() const;
  public:
  void clear_response_update_track_position();
  const ::cpb::remote::ResponseUpdateTrackPosition& response_update_track_position() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseUpdateTrackPosition* release_response_update_track_position();
  ::cpb::remote::ResponseUpdateTrackPosition* mutable_response_update_track_position();
  void set_allocated_response_update_track_position(::cpb::remote::ResponseUpdateTrackPosition* response_update_track_position);
  private:
  const ::cpb::remote::ResponseUpdateTrackPosition& _internal_response_update_track_position() const;
  ::cpb::remote::ResponseUpdateTrackPosition* _internal_mutable_response_update_track_position();
  public:
  void unsafe_arena_set_allocated_response_update_track_position(
      ::cpb::remote::ResponseUpdateTrackPosition* response_update_track_position);
  ::cpb::remote::ResponseUpdateTrackPosition* unsafe_arena_release_response_update_track_position();

  // optional .cpb.remote.RequestConnect request_connect = 21;
  bool has_request_connect() const;
  private:
  bool _internal_has_request_connect() const;
  public:
  void clear_request_connect();
  const ::cpb::remote::RequestConnect& request_connect() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestConnect* release_request_connect();
  ::cpb::remote::RequestConnect* mutable_request_connect();
  void set_allocated_request_connect(::cpb::remote::RequestConnect* request_connect);
  private:
  const ::cpb::remote::RequestConnect& _internal_request_connect() const;
  ::cpb::remote::RequestConnect* _internal_mutable_request_connect();
  public:
  void unsafe_arena_set_allocated_request_connect(
      ::cpb::remote::RequestConnect* request_connect);
  ::cpb::remote::RequestConnect* unsafe_arena_release_request_connect();

  // optional .cpb.remote.ResponseDisconnect response_disconnect = 22;
  bool has_response_disconnect() const;
  private:
  bool _internal_has_response_disconnect() const;
  public:
  void clear_response_disconnect();
  const ::cpb::remote::ResponseDisconnect& response_disconnect() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseDisconnect* release_response_disconnect();
  ::cpb::remote::ResponseDisconnect* mutable_response_disconnect();
  void set_allocated_response_disconnect(::cpb::remote::ResponseDisconnect* response_disconnect);
  private:
  const ::cpb::remote::ResponseDisconnect& _internal_response_disconnect() const;
  ::cpb::remote::ResponseDisconnect* _internal_mutable_response_disconnect();
  public:
  void unsafe_arena_set_allocated_response_disconnect(
      ::cpb::remote::ResponseDisconnect* response_disconnect);
  ::cpb::remote::ResponseDisconnect* unsafe_arena_release_response_disconnect();

  // optional .cpb.remote.RequestSetTrackPosition request_set_track_position = 23;
  bool has_request_set_track_position() const;
  private:
  bool _internal_has_request_set_track_position() const;
  public:
  void clear_request_set_track_position();
  const ::cpb::remote::RequestSetTrackPosition& request_set_track_position() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestSetTrackPosition* release_request_set_track_position();
  ::cpb::remote::RequestSetTrackPosition* mutable_request_set_track_position();
  void set_allocated_request_set_track_position(::cpb::remote::RequestSetTrackPosition* request_set_track_position);
  private:
  const ::cpb::remote::RequestSetTrackPosition& _internal_request_set_track_position() const;
  ::cpb::remote::RequestSetTrackPosition* _internal_mutable_request_set_track_position();
  public:
  void unsafe_arena_set_allocated_request_set_track_position(
      ::cpb::remote::RequestSetTrackPosition* request_set_track_position);
  ::cpb::remote::RequestSetTrackPosition* unsafe_arena_release_request_set_track_position();

  // optional .cpb.remote.ResponseActiveChanged response_active_changed = 24;
  bool has_response_active_changed() const;
  private:
  bool _internal_has_response_active_changed() const;
  public:
  void clear_response_active_changed();
  const ::cpb::remote::ResponseActiveChanged& response_active_changed() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseActiveChanged* release_response_active_changed();
  ::cpb::remote::ResponseActiveChanged* mutable_response_active_changed();
  void set_allocated_response_active_changed(::cpb::remote::ResponseActiveChanged* response_active_changed);
  private:
  const ::cpb::remote::ResponseActiveChanged& _internal_response_active_changed() const;
  ::cpb::remote::ResponseActiveChanged* _internal_mutable_response_active_changed();
  public:
  void unsafe_arena_set_allocated_response_active_changed(
      ::cpb::remote::ResponseActiveChanged* response_active_changed);
  ::cpb::remote::ResponseActiveChanged* unsafe_arena_release_response_active_changed();

  // optional .cpb.remote.RequestInsertUrls request_insert_urls = 25;
  bool has_request_insert_urls() const;
  private:
  bool _internal_has_request_insert_urls() const;
  public:
  void clear_request_insert_urls();
  const ::cpb::remote::RequestInsertUrls& request_insert_urls() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestInsertUrls* release_request_insert_urls();
  ::cpb::remote::RequestInsertUrls* mutable_request_insert_urls();
  void set_allocated_request_insert_urls(::cpb::remote::RequestInsertUrls* request_insert_urls);
  private:
  const ::cpb::remote::RequestInsertUrls& _internal_request_insert_urls() const;
  ::cpb::remote::RequestInsertUrls* _internal_mutable_request_insert_urls();
  public:
  void unsafe_arena_set_allocated_request_insert_urls(
      ::cpb::remote::RequestInsertUrls* request_insert_urls);
  ::cpb::remote::RequestInsertUrls* unsafe_arena_release_request_insert_urls();

  // optional .cpb.remote.RequestRemoveSongs request_remove_songs = 26;
  bool has_request_remove_songs() const;
  private:
  bool _internal_has_request_remove_songs() const;
  public:
  void clear_request_remove_songs();
  const ::cpb::remote::RequestRemoveSongs& request_remove_songs() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestRemoveSongs* release_request_remove_songs();
  ::cpb::remote::RequestRemoveSongs* mutable_request_remove_songs();
  void set_allocated_request_remove_songs(::cpb::remote::RequestRemoveSongs* request_remove_songs);
  private:
  const ::cpb::remote::RequestRemoveSongs& _internal_request_remove_songs() const;
  ::cpb::remote::RequestRemoveSongs* _internal_mutable_request_remove_songs();
  public:
  void unsafe_arena_set_allocated_request_remove_songs(
      ::cpb::remote::RequestRemoveSongs* request_remove_songs);
  ::cpb::remote::RequestRemoveSongs* unsafe_arena_release_request_remove_songs();

  // optional .cpb.remote.RequestPlaylists request_playlists = 27;
  bool has_request_playlists() const;
  private:
  bool _internal_has_request_playlists() const;
  public:
  void clear_request_playlists();
  const ::cpb::remote::RequestPlaylists& request_playlists() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestPlaylists* release_request_playlists();
  ::cpb::remote::RequestPlaylists* mutable_request_playlists();
  void set_allocated_request_playlists(::cpb::remote::RequestPlaylists* request_playlists);
  private:
  const ::cpb::remote::RequestPlaylists& _internal_request_playlists() const;
  ::cpb::remote::RequestPlaylists* _internal_mutable_request_playlists();
  public:
  void unsafe_arena_set_allocated_request_playlists(
      ::cpb::remote::RequestPlaylists* request_playlists);
  ::cpb::remote::RequestPlaylists* unsafe_arena_release_request_playlists();

  // optional .cpb.remote.RequestOpenPlaylist request_open_playlist = 28;
  bool has_request_open_playlist() const;
  private:
  bool _internal_has_request_open_playlist() const;
  public:
  void clear_request_open_playlist();
  const ::cpb::remote::RequestOpenPlaylist& request_open_playlist() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestOpenPlaylist* release_request_open_playlist();
  ::cpb::remote::RequestOpenPlaylist* mutable_request_open_playlist();
  void set_allocated_request_open_playlist(::cpb::remote::RequestOpenPlaylist* request_open_playlist);
  private:
  const ::cpb::remote::RequestOpenPlaylist& _internal_request_open_playlist() const;
  ::cpb::remote::RequestOpenPlaylist* _internal_mutable_request_open_playlist();
  public:
  void unsafe_arena_set_allocated_request_open_playlist(
      ::cpb::remote::RequestOpenPlaylist* request_open_playlist);
  ::cpb::remote::RequestOpenPlaylist* unsafe_arena_release_request_open_playlist();

  // optional .cpb.remote.RequestClosePlaylist request_close_playlist = 29;
  bool has_request_close_playlist() const;
  private:
  bool _internal_has_request_close_playlist() const;
  public:
  void clear_request_close_playlist();
  const ::cpb::remote::RequestClosePlaylist& request_close_playlist() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestClosePlaylist* release_request_close_playlist();
  ::cpb::remote::RequestClosePlaylist* mutable_request_close_playlist();
  void set_allocated_request_close_playlist(::cpb::remote::RequestClosePlaylist* request_close_playlist);
  private:
  const ::cpb::remote::RequestClosePlaylist& _internal_request_close_playlist() const;
  ::cpb::remote::RequestClosePlaylist* _internal_mutable_request_close_playlist();
  public:
  void unsafe_arena_set_allocated_request_close_playlist(
      ::cpb::remote::RequestClosePlaylist* request_close_playlist);
  ::cpb::remote::RequestClosePlaylist* unsafe_arena_release_request_close_playlist();

  // optional .cpb.remote.ResponseLyrics response_lyrics = 30;
  bool has_response_lyrics() const;
  private:
  bool _internal_has_response_lyrics() const;
  public:
  void clear_response_lyrics();
  const ::cpb::remote::ResponseLyrics& response_lyrics() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseLyrics* release_response_lyrics();
  ::cpb::remote::ResponseLyrics* mutable_response_lyrics();
  void set_allocated_response_lyrics(::cpb::remote::ResponseLyrics* response_lyrics);
  private:
  const ::cpb::remote::ResponseLyrics& _internal_response_lyrics() const;
  ::cpb::remote::ResponseLyrics* _internal_mutable_response_lyrics();
  public:
  void unsafe_arena_set_allocated_response_lyrics(
      ::cpb::remote::ResponseLyrics* response_lyrics);
  ::cpb::remote::ResponseLyrics* unsafe_arena_release_response_lyrics();

  // optional .cpb.remote.RequestDownloadSongs request_download_songs = 31;
  bool has_request_download_songs() const;
  private:
  bool _internal_has_request_download_songs() const;
  public:
  void clear_request_download_songs();
  const ::cpb::remote::RequestDownloadSongs& request_download_songs() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestDownloadSongs* release_request_download_songs();
  ::cpb::remote::RequestDownloadSongs* mutable_request_download_songs();
  void set_allocated_request_download_songs(::cpb::remote::RequestDownloadSongs* request_download_songs);
  private:
  const ::cpb::remote::RequestDownloadSongs& _internal_request_download_songs() const;
  ::cpb::remote::RequestDownloadSongs* _internal_mutable_request_download_songs();
  public:
  void unsafe_arena_set_allocated_request_download_songs(
      ::cpb::remote::RequestDownloadSongs* request_download_songs);
  ::cpb::remote::RequestDownloadSongs* unsafe_arena_release_request_download_songs();

  // optional .cpb.remote.ResponseSongFileChunk response_song_file_chunk = 32;
  bool has_response_song_file_chunk() const;
  private:
  bool _internal_has_response_song_file_chunk() const;
  public:
  void clear_response_song_file_chunk();
  const ::cpb::remote::ResponseSongFileChunk& response_song_file_chunk() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseSongFileChunk* release_response_song_file_chunk();
  ::cpb::remote::ResponseSongFileChunk* mutable_response_song_file_chunk();
  void set_allocated_response_song_file_chunk(::cpb::remote::ResponseSongFileChunk* response_song_file_chunk);
  private:
  const ::cpb::remote::ResponseSongFileChunk& _internal_response_song_file_chunk() const;
  ::cpb::remote::ResponseSongFileChunk* _internal_mutable_response_song_file_chunk();
  public:
  void unsafe_arena_set_allocated_response_song_file_chunk(
      ::cpb::remote::ResponseSongFileChunk* response_song_file_chunk);
  ::cpb::remote::ResponseSongFileChunk* unsafe_arena_release_response_song_file_chunk();

  // optional .cpb.remote.ResponseSongOffer response_song_offer = 33;
  bool has_response_song_offer() const;
  private:
  bool _internal_has_response_song_offer() const;
  public:
  void clear_response_song_offer();
  const ::cpb::remote::ResponseSongOffer& response_song_offer() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseSongOffer* release_response_song_offer();
  ::cpb::remote::ResponseSongOffer* mutable_response_song_offer();
  void set_allocated_response_song_offer(::cpb::remote::ResponseSongOffer* response_song_offer);
  private:
  const ::cpb::remote::ResponseSongOffer& _internal_response_song_offer() const;
  ::cpb::remote::ResponseSongOffer* _internal_mutable_response_song_offer();
  public:
  void unsafe_arena_set_allocated_response_song_offer(
      ::cpb::remote::ResponseSongOffer* response_song_offer);
  ::cpb::remote::ResponseSongOffer* unsafe_arena_release_response_song_offer();

  // optional .cpb.remote.ResponseLibraryChunk response_library_chunk = 34;
  bool has_response_library_chunk() const;
  private:
  bool _internal_has_response_library_chunk() const;
  public:
  void clear_response_library_chunk();
  const ::cpb::remote::ResponseLibraryChunk& response_library_chunk() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseLibraryChunk* release_response_library_chunk();
  ::cpb::remote::ResponseLibraryChunk* mutable_response_library_chunk();
  void set_allocated_response_library_chunk(::cpb::remote::ResponseLibraryChunk* response_library_chunk);
  private:
  const ::cpb::remote::ResponseLibraryChunk& _internal_response_library_chunk() const;
  ::cpb::remote::ResponseLibraryChunk* _internal_mutable_response_library_chunk();
  public:
  void unsafe_arena_set_allocated_response_library_chunk(
      ::cpb::remote::ResponseLibraryChunk* response_library_chunk);
  ::cpb::remote::ResponseLibraryChunk* unsafe_arena_release_response_library_chunk();

  // optional .cpb.remote.RequestRateSong request_rate_song = 35;
  bool has_request_rate_song() const;
  private:
  bool _internal_has_request_rate_song() const;
  public:
  void clear_request_rate_song();
  const ::cpb::remote::RequestRateSong& request_rate_song() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestRateSong* release_request_rate_song();
  ::cpb::remote::RequestRateSong* mutable_request_rate_song();
  void set_allocated_request_rate_song(::cpb::remote::RequestRateSong* request_rate_song);
  private:
  const ::cpb::remote::RequestRateSong& _internal_request_rate_song() const;
  ::cpb::remote::RequestRateSong* _internal_mutable_request_rate_song();
  public:
  void unsafe_arena_set_allocated_request_rate_song(
      ::cpb::remote::RequestRateSong* request_rate_song);
  ::cpb::remote::RequestRateSong* unsafe_arena_release_request_rate_song();

  // optional .cpb.remote.ResponseDownloadTotalSize response_download_total_size = 36;
  bool has_response_download_total_size() const;
  private:
  bool _internal_has_response_download_total_size() const;
  public:
  void clear_response_download_total_size();
  const ::cpb::remote::ResponseDownloadTotalSize& response_download_total_size() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseDownloadTotalSize* release_response_download_total_size();
  ::cpb::remote::ResponseDownloadTotalSize* mutable_response_download_total_size();
  void set_allocated_response_download_total_size(::cpb::remote::ResponseDownloadTotalSize* response_download_total_size);
  private:
  const ::cpb::remote::ResponseDownloadTotalSize& _internal_response_download_total_size() const;
  ::cpb::remote::ResponseDownloadTotalSize* _internal_mutable_response_download_total_size();
  public:
  void unsafe_arena_set_allocated_response_download_total_size(
      ::cpb::remote::ResponseDownloadTotalSize* response_download_total_size);
  ::cpb::remote::ResponseDownloadTotalSize* unsafe_arena_release_response_download_total_size();

  // optional .cpb.remote.RequestGlobalSearch request_global_search = 37;
  bool has_request_global_search() const;
  private:
  bool _internal_has_request_global_search() const;
  public:
  void clear_request_global_search();
  const ::cpb::remote::RequestGlobalSearch& request_global_search() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestGlobalSearch* release_request_global_search();
  ::cpb::remote::RequestGlobalSearch* mutable_request_global_search();
  void set_allocated_request_global_search(::cpb::remote::RequestGlobalSearch* request_global_search);
  private:
  const ::cpb::remote::RequestGlobalSearch& _internal_request_global_search() const;
  ::cpb::remote::RequestGlobalSearch* _internal_mutable_request_global_search();
  public:
  void unsafe_arena_set_allocated_request_global_search(
      ::cpb::remote::RequestGlobalSearch* request_global_search);
  ::cpb::remote::RequestGlobalSearch* unsafe_arena_release_request_global_search();

  // optional .cpb.remote.ResponseGlobalSearch response_global_search = 38;
  bool has_response_global_search() const;
  private:
  bool _internal_has_response_global_search() const;
  public:
  void clear_response_global_search();
  const ::cpb::remote::ResponseGlobalSearch& response_global_search() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseGlobalSearch* release_response_global_search();
  ::cpb::remote::ResponseGlobalSearch* mutable_response_global_search();
  void set_allocated_response_global_search(::cpb::remote::ResponseGlobalSearch* response_global_search);
  private:
  const ::cpb::remote::ResponseGlobalSearch& _internal_response_global_search() const;
  ::cpb::remote::ResponseGlobalSearch* _internal_mutable_response_global_search();
  public:
  void unsafe_arena_set_allocated_response_global_search(
      ::cpb::remote::ResponseGlobalSearch* response_global_search);
  ::cpb::remote::ResponseGlobalSearch* unsafe_arena_release_response_global_search();

  // optional .cpb.remote.ResponseTranscoderStatus response_transcoder_status = 39;
  bool has_response_transcoder_status() const;
  private:
  bool _internal_has_response_transcoder_status() const;
  public:
  void clear_response_transcoder_status();
  const ::cpb::remote::ResponseTranscoderStatus& response_transcoder_status() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseTranscoderStatus* release_response_transcoder_status();
  ::cpb::remote::ResponseTranscoderStatus* mutable_response_transcoder_status();
  void set_allocated_response_transcoder_status(::cpb::remote::ResponseTranscoderStatus* response_transcoder_status);
  private:
  const ::cpb::remote::ResponseTranscoderStatus& _internal_response_transcoder_status() const;
  ::cpb::remote::ResponseTranscoderStatus* _internal_mutable_response_transcoder_status();
  public:
  void unsafe_arena_set_allocated_response_transcoder_status(
      ::cpb::remote::ResponseTranscoderStatus* response_transcoder_status);
  ::cpb::remote::ResponseTranscoderStatus* unsafe_arena_release_response_transcoder_status();

  // optional .cpb.remote.ResponseGlobalSearchStatus response_global_search_status = 40;
  bool has_response_global_search_status() const;
  private:
  bool _internal_has_response_global_search_status() const;
  public:
  void clear_response_global_search_status();
  const ::cpb::remote::ResponseGlobalSearchStatus& response_global_search_status() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseGlobalSearchStatus* release_response_global_search_status();
  ::cpb::remote::ResponseGlobalSearchStatus* mutable_response_global_search_status();
  void set_allocated_response_global_search_status(::cpb::remote::ResponseGlobalSearchStatus* response_global_search_status);
  private:
  const ::cpb::remote::ResponseGlobalSearchStatus& _internal_response_global_search_status() const;
  ::cpb::remote::ResponseGlobalSearchStatus* _internal_mutable_response_global_search_status();
  public:
  void unsafe_arena_set_allocated_response_global_search_status(
      ::cpb::remote::ResponseGlobalSearchStatus* response_global_search_status);
  ::cpb::remote::ResponseGlobalSearchStatus* unsafe_arena_release_response_global_search_status();

  // optional .cpb.remote.RequestListFiles request_list_files = 50;
  bool has_request_list_files() const;
  private:
  bool _internal_has_request_list_files() const;
  public:
  void clear_request_list_files();
  const ::cpb::remote::RequestListFiles& request_list_files() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestListFiles* release_request_list_files();
  ::cpb::remote::RequestListFiles* mutable_request_list_files();
  void set_allocated_request_list_files(::cpb::remote::RequestListFiles* request_list_files);
  private:
  const ::cpb::remote::RequestListFiles& _internal_request_list_files() const;
  ::cpb::remote::RequestListFiles* _internal_mutable_request_list_files();
  public:
  void unsafe_arena_set_allocated_request_list_files(
      ::cpb::remote::RequestListFiles* request_list_files);
  ::cpb::remote::RequestListFiles* unsafe_arena_release_request_list_files();

  // optional .cpb.remote.RequestAppendFiles request_append_files = 51;
  bool has_request_append_files() const;
  private:
  bool _internal_has_request_append_files() const;
  public:
  void clear_request_append_files();
  const ::cpb::remote::RequestAppendFiles& request_append_files() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestAppendFiles* release_request_append_files();
  ::cpb::remote::RequestAppendFiles* mutable_request_append_files();
  void set_allocated_request_append_files(::cpb::remote::RequestAppendFiles* request_append_files);
  private:
  const ::cpb::remote::RequestAppendFiles& _internal_request_append_files() const;
  ::cpb::remote::RequestAppendFiles* _internal_mutable_request_append_files();
  public:
  void unsafe_arena_set_allocated_request_append_files(
      ::cpb::remote::RequestAppendFiles* request_append_files);
  ::cpb::remote::RequestAppendFiles* unsafe_arena_release_request_append_files();

  // optional .cpb.remote.ResponseListFiles response_list_files = 52;
  bool has_response_list_files() const;
  private:
  bool _internal_has_response_list_files() const;
  public:
  void clear_response_list_files();
  const ::cpb::remote::ResponseListFiles& response_list_files() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseListFiles* release_response_list_files();
  ::cpb::remote::ResponseListFiles* mutable_response_list_files();
  void set_allocated_response_list_files(::cpb::remote::ResponseListFiles* response_list_files);
  private:
  const ::cpb::remote::ResponseListFiles& _internal_response_list_files() const;
  ::cpb::remote::ResponseListFiles* _internal_mutable_response_list_files();
  public:
  void unsafe_arena_set_allocated_response_list_files(
      ::cpb::remote::ResponseListFiles* response_list_files);
  ::cpb::remote::ResponseListFiles* unsafe_arena_release_response_list_files();

  // optional .cpb.remote.RequestUpdatePlaylist request_update_playlist = 53;
  bool has_request_update_playlist() const;
  private:
  bool _internal_has_request_update_playlist() const;
  public:
  void clear_request_update_playlist();
  const ::cpb::remote::RequestUpdatePlaylist& request_update_playlist() const;
  PROTOBUF_NODISCARD ::cpb::remote::RequestUpdatePlaylist* release_request_update_playlist();
  ::cpb::remote::RequestUpdatePlaylist* mutable_request_update_playlist();
  void set_allocated_request_update_playlist(::cpb::remote::RequestUpdatePlaylist* request_update_playlist);
  private:
  const ::cpb::remote::RequestUpdatePlaylist& _internal_request_update_playlist() const;
  ::cpb::remote::RequestUpdatePlaylist* _internal_mutable_request_update_playlist();
  public:
  void unsafe_arena_set_allocated_request_update_playlist(
      ::cpb::remote::RequestUpdatePlaylist* request_update_playlist);
  ::cpb::remote::RequestUpdatePlaylist* unsafe_arena_release_request_update_playlist();

  // optional .cpb.remote.ResponseSavedRadios response_saved_radios = 54;
  bool has_response_saved_radios() const;
  private:
  bool _internal_has_response_saved_radios() const;
  public:
  void clear_response_saved_radios();
  const ::cpb::remote::ResponseSavedRadios& response_saved_radios() const;
  PROTOBUF_NODISCARD ::cpb::remote::ResponseSavedRadios* release_response_saved_radios();
  ::cpb::remote::ResponseSavedRadios* mutable_response_saved_radios();
  void set_allocated_response_saved_radios(::cpb::remote::ResponseSavedRadios* response_saved_radios);
  private:
  const ::cpb::remote::ResponseSavedRadios& _internal_response_saved_radios() const;
  ::cpb::remote::ResponseSavedRadios* _internal_mutable_response_saved_radios();
  public:
  void unsafe_arena_set_allocated_response_saved_radios(
      ::cpb::remote::ResponseSavedRadios* response_saved_radios);
  ::cpb::remote::ResponseSavedRadios* unsafe_arena_release_response_saved_radios();

  // optional .cpb.remote.MsgType type = 2 [default = UNKNOWN];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::cpb::remote::MsgType type() const;
  void set_type(::cpb::remote::MsgType value);
  private:
  ::cpb::remote::MsgType _internal_type() const;
  void _internal_set_type(::cpb::remote::MsgType value);
  public:

  // optional int32 version = 1 [default = 21];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cpb.remote.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cpb::remote::RequestPlaylistSongs* request_playlist_songs_;
    ::cpb::remote::RequestChangeSong* request_change_song_;
    ::cpb::remote::RequestSetVolume* request_set_volume_;
    ::cpb::remote::Repeat* repeat_;
    ::cpb::remote::Shuffle* shuffle_;
    ::cpb::remote::ResponseClementineInfo* response_clementine_info_;
    ::cpb::remote::ResponseCurrentMetadata* response_current_metadata_;
    ::cpb::remote::ResponsePlaylists* response_playlists_;
    ::cpb::remote::ResponsePlaylistSongs* response_playlist_songs_;
    ::cpb::remote::ResponseEngineStateChanged* response_engine_state_changed_;
    ::cpb::remote::ResponseUpdateTrackPosition* response_update_track_position_;
    ::cpb::remote::RequestConnect* request_connect_;
    ::cpb::remote::ResponseDisconnect* response_disconnect_;
    ::cpb::remote::RequestSetTrackPosition* request_set_track_position_;
    ::cpb::remote::ResponseActiveChanged* response_active_changed_;
    ::cpb::remote::RequestInsertUrls* request_insert_urls_;
    ::cpb::remote::RequestRemoveSongs* request_remove_songs_;
    ::cpb::remote::RequestPlaylists* request_playlists_;
    ::cpb::remote::RequestOpenPlaylist* request_open_playlist_;
    ::cpb::remote::RequestClosePlaylist* request_close_playlist_;
    ::cpb::remote::ResponseLyrics* response_lyrics_;
    ::cpb::remote::RequestDownloadSongs* request_download_songs_;
    ::cpb::remote::ResponseSongFileChunk* response_song_file_chunk_;
    ::cpb::remote::ResponseSongOffer* response_song_offer_;
    ::cpb::remote::ResponseLibraryChunk* response_library_chunk_;
    ::cpb::remote::RequestRateSong* request_rate_song_;
    ::cpb::remote::ResponseDownloadTotalSize* response_download_total_size_;
    ::cpb::remote::RequestGlobalSearch* request_global_search_;
    ::cpb::remote::ResponseGlobalSearch* response_global_search_;
    ::cpb::remote::ResponseTranscoderStatus* response_transcoder_status_;
    ::cpb::remote::ResponseGlobalSearchStatus* response_global_search_status_;
    ::cpb::remote::RequestListFiles* request_list_files_;
    ::cpb::remote::RequestAppendFiles* request_append_files_;
    ::cpb::remote::ResponseListFiles* response_list_files_;
    ::cpb::remote::RequestUpdatePlaylist* request_update_playlist_;
    ::cpb::remote::ResponseSavedRadios* response_saved_radios_;
    int type_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remotecontrolmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SongMetadata

// optional int32 id = 1;
inline bool SongMetadata::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SongMetadata::has_id() const {
  return _internal_has_id();
}
inline void SongMetadata::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t SongMetadata::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SongMetadata::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.id)
  return _internal_id();
}
inline void SongMetadata::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.id_ = value;
}
inline void SongMetadata::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.id)
}

// optional int32 index = 2;
inline bool SongMetadata::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SongMetadata::has_index() const {
  return _internal_has_index();
}
inline void SongMetadata::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t SongMetadata::_internal_index() const {
  return _impl_.index_;
}
inline int32_t SongMetadata::index() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.index)
  return _internal_index();
}
inline void SongMetadata::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.index_ = value;
}
inline void SongMetadata::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.index)
}

// optional string title = 3;
inline bool SongMetadata::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SongMetadata::has_title() const {
  return _internal_has_title();
}
inline void SongMetadata::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SongMetadata::title() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.title)
}
inline std::string* SongMetadata::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.title)
  return _s;
}
inline const std::string& SongMetadata::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SongMetadata::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_title() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.title)
}

// optional string album = 4;
inline bool SongMetadata::_internal_has_album() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SongMetadata::has_album() const {
  return _internal_has_album();
}
inline void SongMetadata::clear_album() {
  _impl_.album_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SongMetadata::album() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.album)
  return _internal_album();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_album(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.album_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.album)
}
inline std::string* SongMetadata::mutable_album() {
  std::string* _s = _internal_mutable_album();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.album)
  return _s;
}
inline const std::string& SongMetadata::_internal_album() const {
  return _impl_.album_.Get();
}
inline void SongMetadata::_internal_set_album(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.album_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_album() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.album_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_album() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.album)
  if (!_internal_has_album()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.album_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.album_.IsDefault()) {
    _impl_.album_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_album(std::string* album) {
  if (album != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.album_.SetAllocated(album, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.album_.IsDefault()) {
    _impl_.album_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.album)
}

// optional string artist = 5;
inline bool SongMetadata::_internal_has_artist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SongMetadata::has_artist() const {
  return _internal_has_artist();
}
inline void SongMetadata::clear_artist() {
  _impl_.artist_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SongMetadata::artist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.artist)
  return _internal_artist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_artist(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.artist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.artist)
}
inline std::string* SongMetadata::mutable_artist() {
  std::string* _s = _internal_mutable_artist();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.artist)
  return _s;
}
inline const std::string& SongMetadata::_internal_artist() const {
  return _impl_.artist_.Get();
}
inline void SongMetadata::_internal_set_artist(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.artist_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_artist() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.artist_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_artist() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.artist)
  if (!_internal_has_artist()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.artist_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.artist_.IsDefault()) {
    _impl_.artist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_artist(std::string* artist) {
  if (artist != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.artist_.SetAllocated(artist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.artist_.IsDefault()) {
    _impl_.artist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.artist)
}

// optional string albumartist = 6;
inline bool SongMetadata::_internal_has_albumartist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SongMetadata::has_albumartist() const {
  return _internal_has_albumartist();
}
inline void SongMetadata::clear_albumartist() {
  _impl_.albumartist_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SongMetadata::albumartist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.albumartist)
  return _internal_albumartist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_albumartist(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.albumartist_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.albumartist)
}
inline std::string* SongMetadata::mutable_albumartist() {
  std::string* _s = _internal_mutable_albumartist();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.albumartist)
  return _s;
}
inline const std::string& SongMetadata::_internal_albumartist() const {
  return _impl_.albumartist_.Get();
}
inline void SongMetadata::_internal_set_albumartist(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.albumartist_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_albumartist() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.albumartist_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_albumartist() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.albumartist)
  if (!_internal_has_albumartist()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.albumartist_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumartist_.IsDefault()) {
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_albumartist(std::string* albumartist) {
  if (albumartist != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.albumartist_.SetAllocated(albumartist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumartist_.IsDefault()) {
    _impl_.albumartist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.albumartist)
}

// optional int32 track = 7;
inline bool SongMetadata::_internal_has_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool SongMetadata::has_track() const {
  return _internal_has_track();
}
inline void SongMetadata::clear_track() {
  _impl_.track_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t SongMetadata::_internal_track() const {
  return _impl_.track_;
}
inline int32_t SongMetadata::track() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.track)
  return _internal_track();
}
inline void SongMetadata::_internal_set_track(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.track_ = value;
}
inline void SongMetadata::set_track(int32_t value) {
  _internal_set_track(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.track)
}

// optional int32 disc = 8;
inline bool SongMetadata::_internal_has_disc() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool SongMetadata::has_disc() const {
  return _internal_has_disc();
}
inline void SongMetadata::clear_disc() {
  _impl_.disc_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t SongMetadata::_internal_disc() const {
  return _impl_.disc_;
}
inline int32_t SongMetadata::disc() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.disc)
  return _internal_disc();
}
inline void SongMetadata::_internal_set_disc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.disc_ = value;
}
inline void SongMetadata::set_disc(int32_t value) {
  _internal_set_disc(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.disc)
}

// optional string pretty_year = 9;
inline bool SongMetadata::_internal_has_pretty_year() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SongMetadata::has_pretty_year() const {
  return _internal_has_pretty_year();
}
inline void SongMetadata::clear_pretty_year() {
  _impl_.pretty_year_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SongMetadata::pretty_year() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.pretty_year)
  return _internal_pretty_year();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_pretty_year(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.pretty_year_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.pretty_year)
}
inline std::string* SongMetadata::mutable_pretty_year() {
  std::string* _s = _internal_mutable_pretty_year();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.pretty_year)
  return _s;
}
inline const std::string& SongMetadata::_internal_pretty_year() const {
  return _impl_.pretty_year_.Get();
}
inline void SongMetadata::_internal_set_pretty_year(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pretty_year_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_pretty_year() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pretty_year_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_pretty_year() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.pretty_year)
  if (!_internal_has_pretty_year()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.pretty_year_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pretty_year_.IsDefault()) {
    _impl_.pretty_year_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_pretty_year(std::string* pretty_year) {
  if (pretty_year != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pretty_year_.SetAllocated(pretty_year, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pretty_year_.IsDefault()) {
    _impl_.pretty_year_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.pretty_year)
}

// optional string genre = 10;
inline bool SongMetadata::_internal_has_genre() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SongMetadata::has_genre() const {
  return _internal_has_genre();
}
inline void SongMetadata::clear_genre() {
  _impl_.genre_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SongMetadata::genre() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.genre)
  return _internal_genre();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_genre(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.genre_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.genre)
}
inline std::string* SongMetadata::mutable_genre() {
  std::string* _s = _internal_mutable_genre();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.genre)
  return _s;
}
inline const std::string& SongMetadata::_internal_genre() const {
  return _impl_.genre_.Get();
}
inline void SongMetadata::_internal_set_genre(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.genre_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_genre() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.genre_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_genre() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.genre)
  if (!_internal_has_genre()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.genre_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.genre_.IsDefault()) {
    _impl_.genre_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_genre(std::string* genre) {
  if (genre != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.genre_.SetAllocated(genre, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.genre_.IsDefault()) {
    _impl_.genre_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.genre)
}

// optional int32 playcount = 11;
inline bool SongMetadata::_internal_has_playcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool SongMetadata::has_playcount() const {
  return _internal_has_playcount();
}
inline void SongMetadata::clear_playcount() {
  _impl_.playcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int32_t SongMetadata::_internal_playcount() const {
  return _impl_.playcount_;
}
inline int32_t SongMetadata::playcount() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.playcount)
  return _internal_playcount();
}
inline void SongMetadata::_internal_set_playcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.playcount_ = value;
}
inline void SongMetadata::set_playcount(int32_t value) {
  _internal_set_playcount(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.playcount)
}

// optional string pretty_length = 12;
inline bool SongMetadata::_internal_has_pretty_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SongMetadata::has_pretty_length() const {
  return _internal_has_pretty_length();
}
inline void SongMetadata::clear_pretty_length() {
  _impl_.pretty_length_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SongMetadata::pretty_length() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.pretty_length)
  return _internal_pretty_length();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_pretty_length(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.pretty_length_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.pretty_length)
}
inline std::string* SongMetadata::mutable_pretty_length() {
  std::string* _s = _internal_mutable_pretty_length();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.pretty_length)
  return _s;
}
inline const std::string& SongMetadata::_internal_pretty_length() const {
  return _impl_.pretty_length_.Get();
}
inline void SongMetadata::_internal_set_pretty_length(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.pretty_length_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_pretty_length() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.pretty_length_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_pretty_length() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.pretty_length)
  if (!_internal_has_pretty_length()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.pretty_length_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pretty_length_.IsDefault()) {
    _impl_.pretty_length_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_pretty_length(std::string* pretty_length) {
  if (pretty_length != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.pretty_length_.SetAllocated(pretty_length, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pretty_length_.IsDefault()) {
    _impl_.pretty_length_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.pretty_length)
}

// optional bytes art = 13;
inline bool SongMetadata::_internal_has_art() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SongMetadata::has_art() const {
  return _internal_has_art();
}
inline void SongMetadata::clear_art() {
  _impl_.art_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SongMetadata::art() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.art)
  return _internal_art();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_art(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.art_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.art)
}
inline std::string* SongMetadata::mutable_art() {
  std::string* _s = _internal_mutable_art();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.art)
  return _s;
}
inline const std::string& SongMetadata::_internal_art() const {
  return _impl_.art_.Get();
}
inline void SongMetadata::_internal_set_art(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.art_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_art() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.art_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_art() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.art)
  if (!_internal_has_art()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.art_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_.IsDefault()) {
    _impl_.art_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_art(std::string* art) {
  if (art != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.art_.SetAllocated(art, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_.IsDefault()) {
    _impl_.art_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.art)
}

// optional int32 length = 14;
inline bool SongMetadata::_internal_has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool SongMetadata::has_length() const {
  return _internal_has_length();
}
inline void SongMetadata::clear_length() {
  _impl_.length_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int32_t SongMetadata::_internal_length() const {
  return _impl_.length_;
}
inline int32_t SongMetadata::length() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.length)
  return _internal_length();
}
inline void SongMetadata::_internal_set_length(int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.length_ = value;
}
inline void SongMetadata::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.length)
}

// optional bool is_local = 15;
inline bool SongMetadata::_internal_has_is_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool SongMetadata::has_is_local() const {
  return _internal_has_is_local();
}
inline void SongMetadata::clear_is_local() {
  _impl_.is_local_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool SongMetadata::_internal_is_local() const {
  return _impl_.is_local_;
}
inline bool SongMetadata::is_local() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.is_local)
  return _internal_is_local();
}
inline void SongMetadata::_internal_set_is_local(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.is_local_ = value;
}
inline void SongMetadata::set_is_local(bool value) {
  _internal_set_is_local(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.is_local)
}

// optional string filename = 16;
inline bool SongMetadata::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SongMetadata::has_filename() const {
  return _internal_has_filename();
}
inline void SongMetadata::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& SongMetadata::filename() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.filename)
}
inline std::string* SongMetadata::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.filename)
  return _s;
}
inline const std::string& SongMetadata::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void SongMetadata::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.filename)
}

// optional int32 file_size = 17;
inline bool SongMetadata::_internal_has_file_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool SongMetadata::has_file_size() const {
  return _internal_has_file_size();
}
inline void SongMetadata::clear_file_size() {
  _impl_.file_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t SongMetadata::_internal_file_size() const {
  return _impl_.file_size_;
}
inline int32_t SongMetadata::file_size() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.file_size)
  return _internal_file_size();
}
inline void SongMetadata::_internal_set_file_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.file_size_ = value;
}
inline void SongMetadata::set_file_size(int32_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.file_size)
}

// optional float rating = 18;
inline bool SongMetadata::_internal_has_rating() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool SongMetadata::has_rating() const {
  return _internal_has_rating();
}
inline void SongMetadata::clear_rating() {
  _impl_.rating_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline float SongMetadata::_internal_rating() const {
  return _impl_.rating_;
}
inline float SongMetadata::rating() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.rating)
  return _internal_rating();
}
inline void SongMetadata::_internal_set_rating(float value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.rating_ = value;
}
inline void SongMetadata::set_rating(float value) {
  _internal_set_rating(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.rating)
}

// optional string url = 19;
inline bool SongMetadata::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SongMetadata::has_url() const {
  return _internal_has_url();
}
inline void SongMetadata::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& SongMetadata::url() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.url)
}
inline std::string* SongMetadata::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.url)
  return _s;
}
inline const std::string& SongMetadata::_internal_url() const {
  return _impl_.url_.Get();
}
inline void SongMetadata::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_url() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.url)
}

// optional string art_automatic = 20;
inline bool SongMetadata::_internal_has_art_automatic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SongMetadata::has_art_automatic() const {
  return _internal_has_art_automatic();
}
inline void SongMetadata::clear_art_automatic() {
  _impl_.art_automatic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& SongMetadata::art_automatic() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.art_automatic)
  return _internal_art_automatic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_art_automatic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.art_automatic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.art_automatic)
}
inline std::string* SongMetadata::mutable_art_automatic() {
  std::string* _s = _internal_mutable_art_automatic();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.art_automatic)
  return _s;
}
inline const std::string& SongMetadata::_internal_art_automatic() const {
  return _impl_.art_automatic_.Get();
}
inline void SongMetadata::_internal_set_art_automatic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.art_automatic_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_art_automatic() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.art_automatic_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_art_automatic() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.art_automatic)
  if (!_internal_has_art_automatic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.art_automatic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_automatic_.IsDefault()) {
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_art_automatic(std::string* art_automatic) {
  if (art_automatic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.art_automatic_.SetAllocated(art_automatic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_automatic_.IsDefault()) {
    _impl_.art_automatic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.art_automatic)
}

// optional string art_manual = 21;
inline bool SongMetadata::_internal_has_art_manual() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SongMetadata::has_art_manual() const {
  return _internal_has_art_manual();
}
inline void SongMetadata::clear_art_manual() {
  _impl_.art_manual_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& SongMetadata::art_manual() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.art_manual)
  return _internal_art_manual();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongMetadata::set_art_manual(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.art_manual_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.art_manual)
}
inline std::string* SongMetadata::mutable_art_manual() {
  std::string* _s = _internal_mutable_art_manual();
  // @@protoc_insertion_point(field_mutable:cpb.remote.SongMetadata.art_manual)
  return _s;
}
inline const std::string& SongMetadata::_internal_art_manual() const {
  return _impl_.art_manual_.Get();
}
inline void SongMetadata::_internal_set_art_manual(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.art_manual_.Set(value, GetArenaForAllocation());
}
inline std::string* SongMetadata::_internal_mutable_art_manual() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.art_manual_.Mutable(GetArenaForAllocation());
}
inline std::string* SongMetadata::release_art_manual() {
  // @@protoc_insertion_point(field_release:cpb.remote.SongMetadata.art_manual)
  if (!_internal_has_art_manual()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.art_manual_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_manual_.IsDefault()) {
    _impl_.art_manual_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongMetadata::set_allocated_art_manual(std::string* art_manual) {
  if (art_manual != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.art_manual_.SetAllocated(art_manual, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.art_manual_.IsDefault()) {
    _impl_.art_manual_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.SongMetadata.art_manual)
}

// optional .cpb.remote.SongMetadata.Type type = 22;
inline bool SongMetadata::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool SongMetadata::has_type() const {
  return _internal_has_type();
}
inline void SongMetadata::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::cpb::remote::SongMetadata_Type SongMetadata::_internal_type() const {
  return static_cast< ::cpb::remote::SongMetadata_Type >(_impl_.type_);
}
inline ::cpb::remote::SongMetadata_Type SongMetadata::type() const {
  // @@protoc_insertion_point(field_get:cpb.remote.SongMetadata.type)
  return _internal_type();
}
inline void SongMetadata::_internal_set_type(::cpb::remote::SongMetadata_Type value) {
  assert(::cpb::remote::SongMetadata_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.type_ = value;
}
inline void SongMetadata::set_type(::cpb::remote::SongMetadata_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cpb.remote.SongMetadata.type)
}

// -------------------------------------------------------------------

// Playlist

// optional int32 id = 1;
inline bool Playlist::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Playlist::has_id() const {
  return _internal_has_id();
}
inline void Playlist::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Playlist::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Playlist::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Playlist.id)
  return _internal_id();
}
inline void Playlist::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void Playlist::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Playlist.id)
}

// optional string name = 2;
inline bool Playlist::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Playlist::has_name() const {
  return _internal_has_name();
}
inline void Playlist::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Playlist::name() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Playlist.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Playlist::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Playlist.name)
}
inline std::string* Playlist::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Playlist.name)
  return _s;
}
inline const std::string& Playlist::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Playlist::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Playlist::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Playlist::release_name() {
  // @@protoc_insertion_point(field_release:cpb.remote.Playlist.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Playlist::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Playlist.name)
}

// optional int32 item_count = 3;
inline bool Playlist::_internal_has_item_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Playlist::has_item_count() const {
  return _internal_has_item_count();
}
inline void Playlist::clear_item_count() {
  _impl_.item_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Playlist::_internal_item_count() const {
  return _impl_.item_count_;
}
inline int32_t Playlist::item_count() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Playlist.item_count)
  return _internal_item_count();
}
inline void Playlist::_internal_set_item_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.item_count_ = value;
}
inline void Playlist::set_item_count(int32_t value) {
  _internal_set_item_count(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Playlist.item_count)
}

// optional bool active = 4;
inline bool Playlist::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Playlist::has_active() const {
  return _internal_has_active();
}
inline void Playlist::clear_active() {
  _impl_.active_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Playlist::_internal_active() const {
  return _impl_.active_;
}
inline bool Playlist::active() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Playlist.active)
  return _internal_active();
}
inline void Playlist::_internal_set_active(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.active_ = value;
}
inline void Playlist::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Playlist.active)
}

// optional bool closed = 5;
inline bool Playlist::_internal_has_closed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Playlist::has_closed() const {
  return _internal_has_closed();
}
inline void Playlist::clear_closed() {
  _impl_.closed_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Playlist::_internal_closed() const {
  return _impl_.closed_;
}
inline bool Playlist::closed() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Playlist.closed)
  return _internal_closed();
}
inline void Playlist::_internal_set_closed(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.closed_ = value;
}
inline void Playlist::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Playlist.closed)
}

// optional bool favorite = 6;
inline bool Playlist::_internal_has_favorite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Playlist::has_favorite() const {
  return _internal_has_favorite();
}
inline void Playlist::clear_favorite() {
  _impl_.favorite_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Playlist::_internal_favorite() const {
  return _impl_.favorite_;
}
inline bool Playlist::favorite() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Playlist.favorite)
  return _internal_favorite();
}
inline void Playlist::_internal_set_favorite(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.favorite_ = value;
}
inline void Playlist::set_favorite(bool value) {
  _internal_set_favorite(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Playlist.favorite)
}

// -------------------------------------------------------------------

// RequestPlaylists

// optional bool include_closed = 1;
inline bool RequestPlaylists::_internal_has_include_closed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestPlaylists::has_include_closed() const {
  return _internal_has_include_closed();
}
inline void RequestPlaylists::clear_include_closed() {
  _impl_.include_closed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RequestPlaylists::_internal_include_closed() const {
  return _impl_.include_closed_;
}
inline bool RequestPlaylists::include_closed() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestPlaylists.include_closed)
  return _internal_include_closed();
}
inline void RequestPlaylists::_internal_set_include_closed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.include_closed_ = value;
}
inline void RequestPlaylists::set_include_closed(bool value) {
  _internal_set_include_closed(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestPlaylists.include_closed)
}

// -------------------------------------------------------------------

// RequestPlaylistSongs

// optional int32 id = 1;
inline bool RequestPlaylistSongs::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestPlaylistSongs::has_id() const {
  return _internal_has_id();
}
inline void RequestPlaylistSongs::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestPlaylistSongs::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RequestPlaylistSongs::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestPlaylistSongs.id)
  return _internal_id();
}
inline void RequestPlaylistSongs::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void RequestPlaylistSongs::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestPlaylistSongs.id)
}

// -------------------------------------------------------------------

// RequestChangeSong

// optional int32 playlist_id = 1;
inline bool RequestChangeSong::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestChangeSong::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestChangeSong::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestChangeSong::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestChangeSong::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestChangeSong.playlist_id)
  return _internal_playlist_id();
}
inline void RequestChangeSong::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playlist_id_ = value;
}
inline void RequestChangeSong::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestChangeSong.playlist_id)
}

// optional int32 song_index = 2;
inline bool RequestChangeSong::_internal_has_song_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestChangeSong::has_song_index() const {
  return _internal_has_song_index();
}
inline void RequestChangeSong::clear_song_index() {
  _impl_.song_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RequestChangeSong::_internal_song_index() const {
  return _impl_.song_index_;
}
inline int32_t RequestChangeSong::song_index() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestChangeSong.song_index)
  return _internal_song_index();
}
inline void RequestChangeSong::_internal_set_song_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.song_index_ = value;
}
inline void RequestChangeSong::set_song_index(int32_t value) {
  _internal_set_song_index(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestChangeSong.song_index)
}

// -------------------------------------------------------------------

// RequestSetVolume

// optional int32 volume = 1;
inline bool RequestSetVolume::_internal_has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestSetVolume::has_volume() const {
  return _internal_has_volume();
}
inline void RequestSetVolume::clear_volume() {
  _impl_.volume_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestSetVolume::_internal_volume() const {
  return _impl_.volume_;
}
inline int32_t RequestSetVolume::volume() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestSetVolume.volume)
  return _internal_volume();
}
inline void RequestSetVolume::_internal_set_volume(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.volume_ = value;
}
inline void RequestSetVolume::set_volume(int32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestSetVolume.volume)
}

// -------------------------------------------------------------------

// Repeat

// optional .cpb.remote.RepeatMode repeat_mode = 1;
inline bool Repeat::_internal_has_repeat_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Repeat::has_repeat_mode() const {
  return _internal_has_repeat_mode();
}
inline void Repeat::clear_repeat_mode() {
  _impl_.repeat_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::cpb::remote::RepeatMode Repeat::_internal_repeat_mode() const {
  return static_cast< ::cpb::remote::RepeatMode >(_impl_.repeat_mode_);
}
inline ::cpb::remote::RepeatMode Repeat::repeat_mode() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Repeat.repeat_mode)
  return _internal_repeat_mode();
}
inline void Repeat::_internal_set_repeat_mode(::cpb::remote::RepeatMode value) {
  assert(::cpb::remote::RepeatMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.repeat_mode_ = value;
}
inline void Repeat::set_repeat_mode(::cpb::remote::RepeatMode value) {
  _internal_set_repeat_mode(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Repeat.repeat_mode)
}

// -------------------------------------------------------------------

// Shuffle

// optional .cpb.remote.ShuffleMode shuffle_mode = 1;
inline bool Shuffle::_internal_has_shuffle_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Shuffle::has_shuffle_mode() const {
  return _internal_has_shuffle_mode();
}
inline void Shuffle::clear_shuffle_mode() {
  _impl_.shuffle_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::cpb::remote::ShuffleMode Shuffle::_internal_shuffle_mode() const {
  return static_cast< ::cpb::remote::ShuffleMode >(_impl_.shuffle_mode_);
}
inline ::cpb::remote::ShuffleMode Shuffle::shuffle_mode() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Shuffle.shuffle_mode)
  return _internal_shuffle_mode();
}
inline void Shuffle::_internal_set_shuffle_mode(::cpb::remote::ShuffleMode value) {
  assert(::cpb::remote::ShuffleMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shuffle_mode_ = value;
}
inline void Shuffle::set_shuffle_mode(::cpb::remote::ShuffleMode value) {
  _internal_set_shuffle_mode(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Shuffle.shuffle_mode)
}

// -------------------------------------------------------------------

// ResponseClementineInfo

// optional string version = 1;
inline bool ResponseClementineInfo::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseClementineInfo::has_version() const {
  return _internal_has_version();
}
inline void ResponseClementineInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseClementineInfo::version() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseClementineInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseClementineInfo::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseClementineInfo.version)
}
inline std::string* ResponseClementineInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseClementineInfo.version)
  return _s;
}
inline const std::string& ResponseClementineInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ResponseClementineInfo::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseClementineInfo::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseClementineInfo::release_version() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseClementineInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseClementineInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseClementineInfo.version)
}

// optional .cpb.remote.EngineState state = 2;
inline bool ResponseClementineInfo::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseClementineInfo::has_state() const {
  return _internal_has_state();
}
inline void ResponseClementineInfo::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::cpb::remote::EngineState ResponseClementineInfo::_internal_state() const {
  return static_cast< ::cpb::remote::EngineState >(_impl_.state_);
}
inline ::cpb::remote::EngineState ResponseClementineInfo::state() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseClementineInfo.state)
  return _internal_state();
}
inline void ResponseClementineInfo::_internal_set_state(::cpb::remote::EngineState value) {
  assert(::cpb::remote::EngineState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_ = value;
}
inline void ResponseClementineInfo::set_state(::cpb::remote::EngineState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseClementineInfo.state)
}

// optional bool allow_downloads = 3;
inline bool ResponseClementineInfo::_internal_has_allow_downloads() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseClementineInfo::has_allow_downloads() const {
  return _internal_has_allow_downloads();
}
inline void ResponseClementineInfo::clear_allow_downloads() {
  _impl_.allow_downloads_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ResponseClementineInfo::_internal_allow_downloads() const {
  return _impl_.allow_downloads_;
}
inline bool ResponseClementineInfo::allow_downloads() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseClementineInfo.allow_downloads)
  return _internal_allow_downloads();
}
inline void ResponseClementineInfo::_internal_set_allow_downloads(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.allow_downloads_ = value;
}
inline void ResponseClementineInfo::set_allow_downloads(bool value) {
  _internal_set_allow_downloads(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseClementineInfo.allow_downloads)
}

// repeated string files_music_extensions = 4;
inline int ResponseClementineInfo::_internal_files_music_extensions_size() const {
  return _impl_.files_music_extensions_.size();
}
inline int ResponseClementineInfo::files_music_extensions_size() const {
  return _internal_files_music_extensions_size();
}
inline void ResponseClementineInfo::clear_files_music_extensions() {
  _impl_.files_music_extensions_.Clear();
}
inline std::string* ResponseClementineInfo::add_files_music_extensions() {
  std::string* _s = _internal_add_files_music_extensions();
  // @@protoc_insertion_point(field_add_mutable:cpb.remote.ResponseClementineInfo.files_music_extensions)
  return _s;
}
inline const std::string& ResponseClementineInfo::_internal_files_music_extensions(int index) const {
  return _impl_.files_music_extensions_.Get(index);
}
inline const std::string& ResponseClementineInfo::files_music_extensions(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseClementineInfo.files_music_extensions)
  return _internal_files_music_extensions(index);
}
inline std::string* ResponseClementineInfo::mutable_files_music_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseClementineInfo.files_music_extensions)
  return _impl_.files_music_extensions_.Mutable(index);
}
inline void ResponseClementineInfo::set_files_music_extensions(int index, const std::string& value) {
  _impl_.files_music_extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline void ResponseClementineInfo::set_files_music_extensions(int index, std::string&& value) {
  _impl_.files_music_extensions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline void ResponseClementineInfo::set_files_music_extensions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_music_extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline void ResponseClementineInfo::set_files_music_extensions(int index, const char* value, size_t size) {
  _impl_.files_music_extensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline std::string* ResponseClementineInfo::_internal_add_files_music_extensions() {
  return _impl_.files_music_extensions_.Add();
}
inline void ResponseClementineInfo::add_files_music_extensions(const std::string& value) {
  _impl_.files_music_extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline void ResponseClementineInfo::add_files_music_extensions(std::string&& value) {
  _impl_.files_music_extensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline void ResponseClementineInfo::add_files_music_extensions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_music_extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline void ResponseClementineInfo::add_files_music_extensions(const char* value, size_t size) {
  _impl_.files_music_extensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cpb.remote.ResponseClementineInfo.files_music_extensions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseClementineInfo::files_music_extensions() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponseClementineInfo.files_music_extensions)
  return _impl_.files_music_extensions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponseClementineInfo::mutable_files_music_extensions() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponseClementineInfo.files_music_extensions)
  return &_impl_.files_music_extensions_;
}

// -------------------------------------------------------------------

// ResponseCurrentMetadata

// optional .cpb.remote.SongMetadata song_metadata = 1;
inline bool ResponseCurrentMetadata::_internal_has_song_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.song_metadata_ != nullptr);
  return value;
}
inline bool ResponseCurrentMetadata::has_song_metadata() const {
  return _internal_has_song_metadata();
}
inline void ResponseCurrentMetadata::clear_song_metadata() {
  if (_impl_.song_metadata_ != nullptr) _impl_.song_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cpb::remote::SongMetadata& ResponseCurrentMetadata::_internal_song_metadata() const {
  const ::cpb::remote::SongMetadata* p = _impl_.song_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::SongMetadata&>(
      ::cpb::remote::_SongMetadata_default_instance_);
}
inline const ::cpb::remote::SongMetadata& ResponseCurrentMetadata::song_metadata() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseCurrentMetadata.song_metadata)
  return _internal_song_metadata();
}
inline void ResponseCurrentMetadata::unsafe_arena_set_allocated_song_metadata(
    ::cpb::remote::SongMetadata* song_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.song_metadata_);
  }
  _impl_.song_metadata_ = song_metadata;
  if (song_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.ResponseCurrentMetadata.song_metadata)
}
inline ::cpb::remote::SongMetadata* ResponseCurrentMetadata::release_song_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::remote::SongMetadata* temp = _impl_.song_metadata_;
  _impl_.song_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::SongMetadata* ResponseCurrentMetadata::unsafe_arena_release_song_metadata() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseCurrentMetadata.song_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::remote::SongMetadata* temp = _impl_.song_metadata_;
  _impl_.song_metadata_ = nullptr;
  return temp;
}
inline ::cpb::remote::SongMetadata* ResponseCurrentMetadata::_internal_mutable_song_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.song_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::SongMetadata>(GetArenaForAllocation());
    _impl_.song_metadata_ = p;
  }
  return _impl_.song_metadata_;
}
inline ::cpb::remote::SongMetadata* ResponseCurrentMetadata::mutable_song_metadata() {
  ::cpb::remote::SongMetadata* _msg = _internal_mutable_song_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseCurrentMetadata.song_metadata)
  return _msg;
}
inline void ResponseCurrentMetadata::set_allocated_song_metadata(::cpb::remote::SongMetadata* song_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.song_metadata_;
  }
  if (song_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(song_metadata);
    if (message_arena != submessage_arena) {
      song_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, song_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.song_metadata_ = song_metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseCurrentMetadata.song_metadata)
}

// -------------------------------------------------------------------

// ResponsePlaylists

// repeated .cpb.remote.Playlist playlist = 1;
inline int ResponsePlaylists::_internal_playlist_size() const {
  return _impl_.playlist_.size();
}
inline int ResponsePlaylists::playlist_size() const {
  return _internal_playlist_size();
}
inline void ResponsePlaylists::clear_playlist() {
  _impl_.playlist_.Clear();
}
inline ::cpb::remote::Playlist* ResponsePlaylists::mutable_playlist(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponsePlaylists.playlist)
  return _impl_.playlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Playlist >*
ResponsePlaylists::mutable_playlist() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponsePlaylists.playlist)
  return &_impl_.playlist_;
}
inline const ::cpb::remote::Playlist& ResponsePlaylists::_internal_playlist(int index) const {
  return _impl_.playlist_.Get(index);
}
inline const ::cpb::remote::Playlist& ResponsePlaylists::playlist(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponsePlaylists.playlist)
  return _internal_playlist(index);
}
inline ::cpb::remote::Playlist* ResponsePlaylists::_internal_add_playlist() {
  return _impl_.playlist_.Add();
}
inline ::cpb::remote::Playlist* ResponsePlaylists::add_playlist() {
  ::cpb::remote::Playlist* _add = _internal_add_playlist();
  // @@protoc_insertion_point(field_add:cpb.remote.ResponsePlaylists.playlist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Playlist >&
ResponsePlaylists::playlist() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponsePlaylists.playlist)
  return _impl_.playlist_;
}

// optional bool include_closed = 2;
inline bool ResponsePlaylists::_internal_has_include_closed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponsePlaylists::has_include_closed() const {
  return _internal_has_include_closed();
}
inline void ResponsePlaylists::clear_include_closed() {
  _impl_.include_closed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ResponsePlaylists::_internal_include_closed() const {
  return _impl_.include_closed_;
}
inline bool ResponsePlaylists::include_closed() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponsePlaylists.include_closed)
  return _internal_include_closed();
}
inline void ResponsePlaylists::_internal_set_include_closed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.include_closed_ = value;
}
inline void ResponsePlaylists::set_include_closed(bool value) {
  _internal_set_include_closed(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponsePlaylists.include_closed)
}

// -------------------------------------------------------------------

// ResponsePlaylistSongs

// optional .cpb.remote.Playlist requested_playlist = 1;
inline bool ResponsePlaylistSongs::_internal_has_requested_playlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requested_playlist_ != nullptr);
  return value;
}
inline bool ResponsePlaylistSongs::has_requested_playlist() const {
  return _internal_has_requested_playlist();
}
inline void ResponsePlaylistSongs::clear_requested_playlist() {
  if (_impl_.requested_playlist_ != nullptr) _impl_.requested_playlist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cpb::remote::Playlist& ResponsePlaylistSongs::_internal_requested_playlist() const {
  const ::cpb::remote::Playlist* p = _impl_.requested_playlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::Playlist&>(
      ::cpb::remote::_Playlist_default_instance_);
}
inline const ::cpb::remote::Playlist& ResponsePlaylistSongs::requested_playlist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponsePlaylistSongs.requested_playlist)
  return _internal_requested_playlist();
}
inline void ResponsePlaylistSongs::unsafe_arena_set_allocated_requested_playlist(
    ::cpb::remote::Playlist* requested_playlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requested_playlist_);
  }
  _impl_.requested_playlist_ = requested_playlist;
  if (requested_playlist) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.ResponsePlaylistSongs.requested_playlist)
}
inline ::cpb::remote::Playlist* ResponsePlaylistSongs::release_requested_playlist() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::remote::Playlist* temp = _impl_.requested_playlist_;
  _impl_.requested_playlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::Playlist* ResponsePlaylistSongs::unsafe_arena_release_requested_playlist() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponsePlaylistSongs.requested_playlist)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::remote::Playlist* temp = _impl_.requested_playlist_;
  _impl_.requested_playlist_ = nullptr;
  return temp;
}
inline ::cpb::remote::Playlist* ResponsePlaylistSongs::_internal_mutable_requested_playlist() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.requested_playlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::Playlist>(GetArenaForAllocation());
    _impl_.requested_playlist_ = p;
  }
  return _impl_.requested_playlist_;
}
inline ::cpb::remote::Playlist* ResponsePlaylistSongs::mutable_requested_playlist() {
  ::cpb::remote::Playlist* _msg = _internal_mutable_requested_playlist();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponsePlaylistSongs.requested_playlist)
  return _msg;
}
inline void ResponsePlaylistSongs::set_allocated_requested_playlist(::cpb::remote::Playlist* requested_playlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requested_playlist_;
  }
  if (requested_playlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requested_playlist);
    if (message_arena != submessage_arena) {
      requested_playlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requested_playlist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requested_playlist_ = requested_playlist;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponsePlaylistSongs.requested_playlist)
}

// repeated .cpb.remote.SongMetadata songs = 2;
inline int ResponsePlaylistSongs::_internal_songs_size() const {
  return _impl_.songs_.size();
}
inline int ResponsePlaylistSongs::songs_size() const {
  return _internal_songs_size();
}
inline void ResponsePlaylistSongs::clear_songs() {
  _impl_.songs_.Clear();
}
inline ::cpb::remote::SongMetadata* ResponsePlaylistSongs::mutable_songs(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponsePlaylistSongs.songs)
  return _impl_.songs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >*
ResponsePlaylistSongs::mutable_songs() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponsePlaylistSongs.songs)
  return &_impl_.songs_;
}
inline const ::cpb::remote::SongMetadata& ResponsePlaylistSongs::_internal_songs(int index) const {
  return _impl_.songs_.Get(index);
}
inline const ::cpb::remote::SongMetadata& ResponsePlaylistSongs::songs(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponsePlaylistSongs.songs)
  return _internal_songs(index);
}
inline ::cpb::remote::SongMetadata* ResponsePlaylistSongs::_internal_add_songs() {
  return _impl_.songs_.Add();
}
inline ::cpb::remote::SongMetadata* ResponsePlaylistSongs::add_songs() {
  ::cpb::remote::SongMetadata* _add = _internal_add_songs();
  // @@protoc_insertion_point(field_add:cpb.remote.ResponsePlaylistSongs.songs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >&
ResponsePlaylistSongs::songs() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponsePlaylistSongs.songs)
  return _impl_.songs_;
}

// -------------------------------------------------------------------

// ResponseEngineStateChanged

// optional .cpb.remote.EngineState state = 1;
inline bool ResponseEngineStateChanged::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseEngineStateChanged::has_state() const {
  return _internal_has_state();
}
inline void ResponseEngineStateChanged::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::cpb::remote::EngineState ResponseEngineStateChanged::_internal_state() const {
  return static_cast< ::cpb::remote::EngineState >(_impl_.state_);
}
inline ::cpb::remote::EngineState ResponseEngineStateChanged::state() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseEngineStateChanged.state)
  return _internal_state();
}
inline void ResponseEngineStateChanged::_internal_set_state(::cpb::remote::EngineState value) {
  assert(::cpb::remote::EngineState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}
inline void ResponseEngineStateChanged::set_state(::cpb::remote::EngineState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseEngineStateChanged.state)
}

// -------------------------------------------------------------------

// ResponseUpdateTrackPosition

// optional int32 position = 1;
inline bool ResponseUpdateTrackPosition::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseUpdateTrackPosition::has_position() const {
  return _internal_has_position();
}
inline void ResponseUpdateTrackPosition::clear_position() {
  _impl_.position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResponseUpdateTrackPosition::_internal_position() const {
  return _impl_.position_;
}
inline int32_t ResponseUpdateTrackPosition::position() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseUpdateTrackPosition.position)
  return _internal_position();
}
inline void ResponseUpdateTrackPosition::_internal_set_position(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.position_ = value;
}
inline void ResponseUpdateTrackPosition::set_position(int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseUpdateTrackPosition.position)
}

// -------------------------------------------------------------------

// RequestConnect

// optional int32 auth_code = 1;
inline bool RequestConnect::_internal_has_auth_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestConnect::has_auth_code() const {
  return _internal_has_auth_code();
}
inline void RequestConnect::clear_auth_code() {
  _impl_.auth_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestConnect::_internal_auth_code() const {
  return _impl_.auth_code_;
}
inline int32_t RequestConnect::auth_code() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestConnect.auth_code)
  return _internal_auth_code();
}
inline void RequestConnect::_internal_set_auth_code(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_code_ = value;
}
inline void RequestConnect::set_auth_code(int32_t value) {
  _internal_set_auth_code(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestConnect.auth_code)
}

// optional bool send_playlist_songs = 2;
inline bool RequestConnect::_internal_has_send_playlist_songs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestConnect::has_send_playlist_songs() const {
  return _internal_has_send_playlist_songs();
}
inline void RequestConnect::clear_send_playlist_songs() {
  _impl_.send_playlist_songs_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RequestConnect::_internal_send_playlist_songs() const {
  return _impl_.send_playlist_songs_;
}
inline bool RequestConnect::send_playlist_songs() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestConnect.send_playlist_songs)
  return _internal_send_playlist_songs();
}
inline void RequestConnect::_internal_set_send_playlist_songs(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.send_playlist_songs_ = value;
}
inline void RequestConnect::set_send_playlist_songs(bool value) {
  _internal_set_send_playlist_songs(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestConnect.send_playlist_songs)
}

// optional bool downloader = 3;
inline bool RequestConnect::_internal_has_downloader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestConnect::has_downloader() const {
  return _internal_has_downloader();
}
inline void RequestConnect::clear_downloader() {
  _impl_.downloader_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RequestConnect::_internal_downloader() const {
  return _impl_.downloader_;
}
inline bool RequestConnect::downloader() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestConnect.downloader)
  return _internal_downloader();
}
inline void RequestConnect::_internal_set_downloader(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.downloader_ = value;
}
inline void RequestConnect::set_downloader(bool value) {
  _internal_set_downloader(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestConnect.downloader)
}

// -------------------------------------------------------------------

// ResponseDisconnect

// optional .cpb.remote.ReasonDisconnect reason_disconnect = 1;
inline bool ResponseDisconnect::_internal_has_reason_disconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseDisconnect::has_reason_disconnect() const {
  return _internal_has_reason_disconnect();
}
inline void ResponseDisconnect::clear_reason_disconnect() {
  _impl_.reason_disconnect_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::cpb::remote::ReasonDisconnect ResponseDisconnect::_internal_reason_disconnect() const {
  return static_cast< ::cpb::remote::ReasonDisconnect >(_impl_.reason_disconnect_);
}
inline ::cpb::remote::ReasonDisconnect ResponseDisconnect::reason_disconnect() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseDisconnect.reason_disconnect)
  return _internal_reason_disconnect();
}
inline void ResponseDisconnect::_internal_set_reason_disconnect(::cpb::remote::ReasonDisconnect value) {
  assert(::cpb::remote::ReasonDisconnect_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_disconnect_ = value;
}
inline void ResponseDisconnect::set_reason_disconnect(::cpb::remote::ReasonDisconnect value) {
  _internal_set_reason_disconnect(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseDisconnect.reason_disconnect)
}

// -------------------------------------------------------------------

// ResponseActiveChanged

// optional int32 id = 1;
inline bool ResponseActiveChanged::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseActiveChanged::has_id() const {
  return _internal_has_id();
}
inline void ResponseActiveChanged::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResponseActiveChanged::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ResponseActiveChanged::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseActiveChanged.id)
  return _internal_id();
}
inline void ResponseActiveChanged::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void ResponseActiveChanged::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseActiveChanged.id)
}

// -------------------------------------------------------------------

// RequestSetTrackPosition

// optional int32 position = 1;
inline bool RequestSetTrackPosition::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestSetTrackPosition::has_position() const {
  return _internal_has_position();
}
inline void RequestSetTrackPosition::clear_position() {
  _impl_.position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestSetTrackPosition::_internal_position() const {
  return _impl_.position_;
}
inline int32_t RequestSetTrackPosition::position() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestSetTrackPosition.position)
  return _internal_position();
}
inline void RequestSetTrackPosition::_internal_set_position(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.position_ = value;
}
inline void RequestSetTrackPosition::set_position(int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestSetTrackPosition.position)
}

// -------------------------------------------------------------------

// RequestInsertUrls

// optional int32 playlist_id = 1;
inline bool RequestInsertUrls::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestInsertUrls::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestInsertUrls::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RequestInsertUrls::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestInsertUrls::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.playlist_id)
  return _internal_playlist_id();
}
inline void RequestInsertUrls::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_id_ = value;
}
inline void RequestInsertUrls::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.playlist_id)
}

// repeated string urls = 2;
inline int RequestInsertUrls::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int RequestInsertUrls::urls_size() const {
  return _internal_urls_size();
}
inline void RequestInsertUrls::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* RequestInsertUrls::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:cpb.remote.RequestInsertUrls.urls)
  return _s;
}
inline const std::string& RequestInsertUrls::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& RequestInsertUrls::urls(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.urls)
  return _internal_urls(index);
}
inline std::string* RequestInsertUrls::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestInsertUrls.urls)
  return _impl_.urls_.Mutable(index);
}
inline void RequestInsertUrls::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.urls)
}
inline void RequestInsertUrls::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.urls)
}
inline void RequestInsertUrls::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cpb.remote.RequestInsertUrls.urls)
}
inline void RequestInsertUrls::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cpb.remote.RequestInsertUrls.urls)
}
inline std::string* RequestInsertUrls::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void RequestInsertUrls::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cpb.remote.RequestInsertUrls.urls)
}
inline void RequestInsertUrls::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cpb.remote.RequestInsertUrls.urls)
}
inline void RequestInsertUrls::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cpb.remote.RequestInsertUrls.urls)
}
inline void RequestInsertUrls::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cpb.remote.RequestInsertUrls.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestInsertUrls::urls() const {
  // @@protoc_insertion_point(field_list:cpb.remote.RequestInsertUrls.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestInsertUrls::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.RequestInsertUrls.urls)
  return &_impl_.urls_;
}

// optional int32 position = 3 [default = -1];
inline bool RequestInsertUrls::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestInsertUrls::has_position() const {
  return _internal_has_position();
}
inline void RequestInsertUrls::clear_position() {
  _impl_.position_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t RequestInsertUrls::_internal_position() const {
  return _impl_.position_;
}
inline int32_t RequestInsertUrls::position() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.position)
  return _internal_position();
}
inline void RequestInsertUrls::_internal_set_position(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.position_ = value;
}
inline void RequestInsertUrls::set_position(int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.position)
}

// optional bool play_now = 4 [default = false];
inline bool RequestInsertUrls::_internal_has_play_now() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestInsertUrls::has_play_now() const {
  return _internal_has_play_now();
}
inline void RequestInsertUrls::clear_play_now() {
  _impl_.play_now_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RequestInsertUrls::_internal_play_now() const {
  return _impl_.play_now_;
}
inline bool RequestInsertUrls::play_now() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.play_now)
  return _internal_play_now();
}
inline void RequestInsertUrls::_internal_set_play_now(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.play_now_ = value;
}
inline void RequestInsertUrls::set_play_now(bool value) {
  _internal_set_play_now(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.play_now)
}

// optional bool enqueue = 5 [default = false];
inline bool RequestInsertUrls::_internal_has_enqueue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RequestInsertUrls::has_enqueue() const {
  return _internal_has_enqueue();
}
inline void RequestInsertUrls::clear_enqueue() {
  _impl_.enqueue_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RequestInsertUrls::_internal_enqueue() const {
  return _impl_.enqueue_;
}
inline bool RequestInsertUrls::enqueue() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.enqueue)
  return _internal_enqueue();
}
inline void RequestInsertUrls::_internal_set_enqueue(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.enqueue_ = value;
}
inline void RequestInsertUrls::set_enqueue(bool value) {
  _internal_set_enqueue(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.enqueue)
}

// repeated .cpb.remote.SongMetadata songs = 6;
inline int RequestInsertUrls::_internal_songs_size() const {
  return _impl_.songs_.size();
}
inline int RequestInsertUrls::songs_size() const {
  return _internal_songs_size();
}
inline void RequestInsertUrls::clear_songs() {
  _impl_.songs_.Clear();
}
inline ::cpb::remote::SongMetadata* RequestInsertUrls::mutable_songs(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestInsertUrls.songs)
  return _impl_.songs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >*
RequestInsertUrls::mutable_songs() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.RequestInsertUrls.songs)
  return &_impl_.songs_;
}
inline const ::cpb::remote::SongMetadata& RequestInsertUrls::_internal_songs(int index) const {
  return _impl_.songs_.Get(index);
}
inline const ::cpb::remote::SongMetadata& RequestInsertUrls::songs(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.songs)
  return _internal_songs(index);
}
inline ::cpb::remote::SongMetadata* RequestInsertUrls::_internal_add_songs() {
  return _impl_.songs_.Add();
}
inline ::cpb::remote::SongMetadata* RequestInsertUrls::add_songs() {
  ::cpb::remote::SongMetadata* _add = _internal_add_songs();
  // @@protoc_insertion_point(field_add:cpb.remote.RequestInsertUrls.songs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >&
RequestInsertUrls::songs() const {
  // @@protoc_insertion_point(field_list:cpb.remote.RequestInsertUrls.songs)
  return _impl_.songs_;
}

// optional string new_playlist_name = 7;
inline bool RequestInsertUrls::_internal_has_new_playlist_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestInsertUrls::has_new_playlist_name() const {
  return _internal_has_new_playlist_name();
}
inline void RequestInsertUrls::clear_new_playlist_name() {
  _impl_.new_playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestInsertUrls::new_playlist_name() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestInsertUrls.new_playlist_name)
  return _internal_new_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestInsertUrls::set_new_playlist_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestInsertUrls.new_playlist_name)
}
inline std::string* RequestInsertUrls::mutable_new_playlist_name() {
  std::string* _s = _internal_mutable_new_playlist_name();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestInsertUrls.new_playlist_name)
  return _s;
}
inline const std::string& RequestInsertUrls::_internal_new_playlist_name() const {
  return _impl_.new_playlist_name_.Get();
}
inline void RequestInsertUrls::_internal_set_new_playlist_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestInsertUrls::_internal_mutable_new_playlist_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestInsertUrls::release_new_playlist_name() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestInsertUrls.new_playlist_name)
  if (!_internal_has_new_playlist_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_playlist_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_playlist_name_.IsDefault()) {
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestInsertUrls::set_allocated_new_playlist_name(std::string* new_playlist_name) {
  if (new_playlist_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_playlist_name_.SetAllocated(new_playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_playlist_name_.IsDefault()) {
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestInsertUrls.new_playlist_name)
}

// -------------------------------------------------------------------

// RequestRemoveSongs

// optional int32 playlist_id = 1;
inline bool RequestRemoveSongs::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestRemoveSongs::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestRemoveSongs::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestRemoveSongs::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestRemoveSongs::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestRemoveSongs.playlist_id)
  return _internal_playlist_id();
}
inline void RequestRemoveSongs::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playlist_id_ = value;
}
inline void RequestRemoveSongs::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestRemoveSongs.playlist_id)
}

// repeated int32 songs = 2;
inline int RequestRemoveSongs::_internal_songs_size() const {
  return _impl_.songs_.size();
}
inline int RequestRemoveSongs::songs_size() const {
  return _internal_songs_size();
}
inline void RequestRemoveSongs::clear_songs() {
  _impl_.songs_.Clear();
}
inline int32_t RequestRemoveSongs::_internal_songs(int index) const {
  return _impl_.songs_.Get(index);
}
inline int32_t RequestRemoveSongs::songs(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestRemoveSongs.songs)
  return _internal_songs(index);
}
inline void RequestRemoveSongs::set_songs(int index, int32_t value) {
  _impl_.songs_.Set(index, value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestRemoveSongs.songs)
}
inline void RequestRemoveSongs::_internal_add_songs(int32_t value) {
  _impl_.songs_.Add(value);
}
inline void RequestRemoveSongs::add_songs(int32_t value) {
  _internal_add_songs(value);
  // @@protoc_insertion_point(field_add:cpb.remote.RequestRemoveSongs.songs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RequestRemoveSongs::_internal_songs() const {
  return _impl_.songs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RequestRemoveSongs::songs() const {
  // @@protoc_insertion_point(field_list:cpb.remote.RequestRemoveSongs.songs)
  return _internal_songs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RequestRemoveSongs::_internal_mutable_songs() {
  return &_impl_.songs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RequestRemoveSongs::mutable_songs() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.RequestRemoveSongs.songs)
  return _internal_mutable_songs();
}

// -------------------------------------------------------------------

// RequestOpenPlaylist

// optional int32 playlist_id = 1;
inline bool RequestOpenPlaylist::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestOpenPlaylist::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestOpenPlaylist::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestOpenPlaylist::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestOpenPlaylist::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestOpenPlaylist.playlist_id)
  return _internal_playlist_id();
}
inline void RequestOpenPlaylist::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playlist_id_ = value;
}
inline void RequestOpenPlaylist::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestOpenPlaylist.playlist_id)
}

// -------------------------------------------------------------------

// RequestClosePlaylist

// optional int32 playlist_id = 1;
inline bool RequestClosePlaylist::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestClosePlaylist::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestClosePlaylist::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestClosePlaylist::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestClosePlaylist::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestClosePlaylist.playlist_id)
  return _internal_playlist_id();
}
inline void RequestClosePlaylist::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.playlist_id_ = value;
}
inline void RequestClosePlaylist::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestClosePlaylist.playlist_id)
}

// -------------------------------------------------------------------

// RequestUpdatePlaylist

// optional int32 playlist_id = 1;
inline bool RequestUpdatePlaylist::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestUpdatePlaylist::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestUpdatePlaylist::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RequestUpdatePlaylist::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestUpdatePlaylist::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestUpdatePlaylist.playlist_id)
  return _internal_playlist_id();
}
inline void RequestUpdatePlaylist::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_id_ = value;
}
inline void RequestUpdatePlaylist::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestUpdatePlaylist.playlist_id)
}

// optional string new_playlist_name = 2;
inline bool RequestUpdatePlaylist::_internal_has_new_playlist_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestUpdatePlaylist::has_new_playlist_name() const {
  return _internal_has_new_playlist_name();
}
inline void RequestUpdatePlaylist::clear_new_playlist_name() {
  _impl_.new_playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestUpdatePlaylist::new_playlist_name() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestUpdatePlaylist.new_playlist_name)
  return _internal_new_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestUpdatePlaylist::set_new_playlist_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestUpdatePlaylist.new_playlist_name)
}
inline std::string* RequestUpdatePlaylist::mutable_new_playlist_name() {
  std::string* _s = _internal_mutable_new_playlist_name();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestUpdatePlaylist.new_playlist_name)
  return _s;
}
inline const std::string& RequestUpdatePlaylist::_internal_new_playlist_name() const {
  return _impl_.new_playlist_name_.Get();
}
inline void RequestUpdatePlaylist::_internal_set_new_playlist_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestUpdatePlaylist::_internal_mutable_new_playlist_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestUpdatePlaylist::release_new_playlist_name() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestUpdatePlaylist.new_playlist_name)
  if (!_internal_has_new_playlist_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_playlist_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_playlist_name_.IsDefault()) {
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestUpdatePlaylist::set_allocated_new_playlist_name(std::string* new_playlist_name) {
  if (new_playlist_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_playlist_name_.SetAllocated(new_playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_playlist_name_.IsDefault()) {
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestUpdatePlaylist.new_playlist_name)
}

// optional bool favorite = 3;
inline bool RequestUpdatePlaylist::_internal_has_favorite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestUpdatePlaylist::has_favorite() const {
  return _internal_has_favorite();
}
inline void RequestUpdatePlaylist::clear_favorite() {
  _impl_.favorite_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RequestUpdatePlaylist::_internal_favorite() const {
  return _impl_.favorite_;
}
inline bool RequestUpdatePlaylist::favorite() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestUpdatePlaylist.favorite)
  return _internal_favorite();
}
inline void RequestUpdatePlaylist::_internal_set_favorite(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.favorite_ = value;
}
inline void RequestUpdatePlaylist::set_favorite(bool value) {
  _internal_set_favorite(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestUpdatePlaylist.favorite)
}

// optional bool create_new_playlist = 4;
inline bool RequestUpdatePlaylist::_internal_has_create_new_playlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RequestUpdatePlaylist::has_create_new_playlist() const {
  return _internal_has_create_new_playlist();
}
inline void RequestUpdatePlaylist::clear_create_new_playlist() {
  _impl_.create_new_playlist_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RequestUpdatePlaylist::_internal_create_new_playlist() const {
  return _impl_.create_new_playlist_;
}
inline bool RequestUpdatePlaylist::create_new_playlist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestUpdatePlaylist.create_new_playlist)
  return _internal_create_new_playlist();
}
inline void RequestUpdatePlaylist::_internal_set_create_new_playlist(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.create_new_playlist_ = value;
}
inline void RequestUpdatePlaylist::set_create_new_playlist(bool value) {
  _internal_set_create_new_playlist(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestUpdatePlaylist.create_new_playlist)
}

// optional bool clear_playlist = 5;
inline bool RequestUpdatePlaylist::_internal_has_clear_playlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestUpdatePlaylist::has_clear_playlist() const {
  return _internal_has_clear_playlist();
}
inline void RequestUpdatePlaylist::clear_clear_playlist() {
  _impl_.clear_playlist_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RequestUpdatePlaylist::_internal_clear_playlist() const {
  return _impl_.clear_playlist_;
}
inline bool RequestUpdatePlaylist::clear_playlist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestUpdatePlaylist.clear_playlist)
  return _internal_clear_playlist();
}
inline void RequestUpdatePlaylist::_internal_set_clear_playlist(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clear_playlist_ = value;
}
inline void RequestUpdatePlaylist::set_clear_playlist(bool value) {
  _internal_set_clear_playlist(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestUpdatePlaylist.clear_playlist)
}

// -------------------------------------------------------------------

// ResponseLyrics

// repeated .cpb.remote.Lyric lyrics = 1;
inline int ResponseLyrics::_internal_lyrics_size() const {
  return _impl_.lyrics_.size();
}
inline int ResponseLyrics::lyrics_size() const {
  return _internal_lyrics_size();
}
inline void ResponseLyrics::clear_lyrics() {
  _impl_.lyrics_.Clear();
}
inline ::cpb::remote::Lyric* ResponseLyrics::mutable_lyrics(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseLyrics.lyrics)
  return _impl_.lyrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Lyric >*
ResponseLyrics::mutable_lyrics() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponseLyrics.lyrics)
  return &_impl_.lyrics_;
}
inline const ::cpb::remote::Lyric& ResponseLyrics::_internal_lyrics(int index) const {
  return _impl_.lyrics_.Get(index);
}
inline const ::cpb::remote::Lyric& ResponseLyrics::lyrics(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseLyrics.lyrics)
  return _internal_lyrics(index);
}
inline ::cpb::remote::Lyric* ResponseLyrics::_internal_add_lyrics() {
  return _impl_.lyrics_.Add();
}
inline ::cpb::remote::Lyric* ResponseLyrics::add_lyrics() {
  ::cpb::remote::Lyric* _add = _internal_add_lyrics();
  // @@protoc_insertion_point(field_add:cpb.remote.ResponseLyrics.lyrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Lyric >&
ResponseLyrics::lyrics() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponseLyrics.lyrics)
  return _impl_.lyrics_;
}

// -------------------------------------------------------------------

// Lyric

// optional string id = 1;
inline bool Lyric::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Lyric::has_id() const {
  return _internal_has_id();
}
inline void Lyric::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Lyric::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Lyric.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lyric::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Lyric.id)
}
inline std::string* Lyric::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Lyric.id)
  return _s;
}
inline const std::string& Lyric::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Lyric::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Lyric::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Lyric::release_id() {
  // @@protoc_insertion_point(field_release:cpb.remote.Lyric.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Lyric::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Lyric.id)
}

// optional string title = 2;
inline bool Lyric::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Lyric::has_title() const {
  return _internal_has_title();
}
inline void Lyric::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Lyric::title() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Lyric.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lyric::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Lyric.title)
}
inline std::string* Lyric::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Lyric.title)
  return _s;
}
inline const std::string& Lyric::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Lyric::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Lyric::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Lyric::release_title() {
  // @@protoc_insertion_point(field_release:cpb.remote.Lyric.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Lyric::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Lyric.title)
}

// optional string content = 3;
inline bool Lyric::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Lyric::has_content() const {
  return _internal_has_content();
}
inline void Lyric::clear_content() {
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Lyric::content() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Lyric.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Lyric::set_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Lyric.content)
}
inline std::string* Lyric::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Lyric.content)
  return _s;
}
inline const std::string& Lyric::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Lyric::_internal_set_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Lyric::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Lyric::release_content() {
  // @@protoc_insertion_point(field_release:cpb.remote.Lyric.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Lyric::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Lyric.content)
}

// -------------------------------------------------------------------

// RequestDownloadSongs

// optional .cpb.remote.DownloadItem download_item = 1;
inline bool RequestDownloadSongs::_internal_has_download_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestDownloadSongs::has_download_item() const {
  return _internal_has_download_item();
}
inline void RequestDownloadSongs::clear_download_item() {
  _impl_.download_item_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::cpb::remote::DownloadItem RequestDownloadSongs::_internal_download_item() const {
  return static_cast< ::cpb::remote::DownloadItem >(_impl_.download_item_);
}
inline ::cpb::remote::DownloadItem RequestDownloadSongs::download_item() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestDownloadSongs.download_item)
  return _internal_download_item();
}
inline void RequestDownloadSongs::_internal_set_download_item(::cpb::remote::DownloadItem value) {
  assert(::cpb::remote::DownloadItem_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.download_item_ = value;
}
inline void RequestDownloadSongs::set_download_item(::cpb::remote::DownloadItem value) {
  _internal_set_download_item(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestDownloadSongs.download_item)
}

// optional int32 playlist_id = 2;
inline bool RequestDownloadSongs::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestDownloadSongs::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestDownloadSongs::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RequestDownloadSongs::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestDownloadSongs::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestDownloadSongs.playlist_id)
  return _internal_playlist_id();
}
inline void RequestDownloadSongs::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.playlist_id_ = value;
}
inline void RequestDownloadSongs::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestDownloadSongs.playlist_id)
}

// repeated string urls = 3;
inline int RequestDownloadSongs::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int RequestDownloadSongs::urls_size() const {
  return _internal_urls_size();
}
inline void RequestDownloadSongs::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* RequestDownloadSongs::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:cpb.remote.RequestDownloadSongs.urls)
  return _s;
}
inline const std::string& RequestDownloadSongs::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& RequestDownloadSongs::urls(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestDownloadSongs.urls)
  return _internal_urls(index);
}
inline std::string* RequestDownloadSongs::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestDownloadSongs.urls)
  return _impl_.urls_.Mutable(index);
}
inline void RequestDownloadSongs::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestDownloadSongs.urls)
}
inline void RequestDownloadSongs::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cpb.remote.RequestDownloadSongs.urls)
}
inline void RequestDownloadSongs::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cpb.remote.RequestDownloadSongs.urls)
}
inline void RequestDownloadSongs::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cpb.remote.RequestDownloadSongs.urls)
}
inline std::string* RequestDownloadSongs::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void RequestDownloadSongs::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cpb.remote.RequestDownloadSongs.urls)
}
inline void RequestDownloadSongs::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cpb.remote.RequestDownloadSongs.urls)
}
inline void RequestDownloadSongs::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cpb.remote.RequestDownloadSongs.urls)
}
inline void RequestDownloadSongs::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cpb.remote.RequestDownloadSongs.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestDownloadSongs::urls() const {
  // @@protoc_insertion_point(field_list:cpb.remote.RequestDownloadSongs.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestDownloadSongs::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.RequestDownloadSongs.urls)
  return &_impl_.urls_;
}

// repeated int32 songs_ids = 4;
inline int RequestDownloadSongs::_internal_songs_ids_size() const {
  return _impl_.songs_ids_.size();
}
inline int RequestDownloadSongs::songs_ids_size() const {
  return _internal_songs_ids_size();
}
inline void RequestDownloadSongs::clear_songs_ids() {
  _impl_.songs_ids_.Clear();
}
inline int32_t RequestDownloadSongs::_internal_songs_ids(int index) const {
  return _impl_.songs_ids_.Get(index);
}
inline int32_t RequestDownloadSongs::songs_ids(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestDownloadSongs.songs_ids)
  return _internal_songs_ids(index);
}
inline void RequestDownloadSongs::set_songs_ids(int index, int32_t value) {
  _impl_.songs_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestDownloadSongs.songs_ids)
}
inline void RequestDownloadSongs::_internal_add_songs_ids(int32_t value) {
  _impl_.songs_ids_.Add(value);
}
inline void RequestDownloadSongs::add_songs_ids(int32_t value) {
  _internal_add_songs_ids(value);
  // @@protoc_insertion_point(field_add:cpb.remote.RequestDownloadSongs.songs_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RequestDownloadSongs::_internal_songs_ids() const {
  return _impl_.songs_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RequestDownloadSongs::songs_ids() const {
  // @@protoc_insertion_point(field_list:cpb.remote.RequestDownloadSongs.songs_ids)
  return _internal_songs_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RequestDownloadSongs::_internal_mutable_songs_ids() {
  return &_impl_.songs_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RequestDownloadSongs::mutable_songs_ids() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.RequestDownloadSongs.songs_ids)
  return _internal_mutable_songs_ids();
}

// optional string relative_path = 5;
inline bool RequestDownloadSongs::_internal_has_relative_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestDownloadSongs::has_relative_path() const {
  return _internal_has_relative_path();
}
inline void RequestDownloadSongs::clear_relative_path() {
  _impl_.relative_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestDownloadSongs::relative_path() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestDownloadSongs.relative_path)
  return _internal_relative_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestDownloadSongs::set_relative_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.relative_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestDownloadSongs.relative_path)
}
inline std::string* RequestDownloadSongs::mutable_relative_path() {
  std::string* _s = _internal_mutable_relative_path();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestDownloadSongs.relative_path)
  return _s;
}
inline const std::string& RequestDownloadSongs::_internal_relative_path() const {
  return _impl_.relative_path_.Get();
}
inline void RequestDownloadSongs::_internal_set_relative_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.relative_path_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestDownloadSongs::_internal_mutable_relative_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.relative_path_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestDownloadSongs::release_relative_path() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestDownloadSongs.relative_path)
  if (!_internal_has_relative_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.relative_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestDownloadSongs::set_allocated_relative_path(std::string* relative_path) {
  if (relative_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.relative_path_.SetAllocated(relative_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestDownloadSongs.relative_path)
}

// -------------------------------------------------------------------

// ResponseSongFileChunk

// optional int32 chunk_number = 1;
inline bool ResponseSongFileChunk::_internal_has_chunk_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_chunk_number() const {
  return _internal_has_chunk_number();
}
inline void ResponseSongFileChunk::clear_chunk_number() {
  _impl_.chunk_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ResponseSongFileChunk::_internal_chunk_number() const {
  return _impl_.chunk_number_;
}
inline int32_t ResponseSongFileChunk::chunk_number() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.chunk_number)
  return _internal_chunk_number();
}
inline void ResponseSongFileChunk::_internal_set_chunk_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.chunk_number_ = value;
}
inline void ResponseSongFileChunk::set_chunk_number(int32_t value) {
  _internal_set_chunk_number(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.chunk_number)
}

// optional int32 chunk_count = 2;
inline bool ResponseSongFileChunk::_internal_has_chunk_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_chunk_count() const {
  return _internal_has_chunk_count();
}
inline void ResponseSongFileChunk::clear_chunk_count() {
  _impl_.chunk_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ResponseSongFileChunk::_internal_chunk_count() const {
  return _impl_.chunk_count_;
}
inline int32_t ResponseSongFileChunk::chunk_count() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.chunk_count)
  return _internal_chunk_count();
}
inline void ResponseSongFileChunk::_internal_set_chunk_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.chunk_count_ = value;
}
inline void ResponseSongFileChunk::set_chunk_count(int32_t value) {
  _internal_set_chunk_count(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.chunk_count)
}

// optional int32 file_number = 3;
inline bool ResponseSongFileChunk::_internal_has_file_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_file_number() const {
  return _internal_has_file_number();
}
inline void ResponseSongFileChunk::clear_file_number() {
  _impl_.file_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t ResponseSongFileChunk::_internal_file_number() const {
  return _impl_.file_number_;
}
inline int32_t ResponseSongFileChunk::file_number() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.file_number)
  return _internal_file_number();
}
inline void ResponseSongFileChunk::_internal_set_file_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.file_number_ = value;
}
inline void ResponseSongFileChunk::set_file_number(int32_t value) {
  _internal_set_file_number(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.file_number)
}

// optional int32 file_count = 4;
inline bool ResponseSongFileChunk::_internal_has_file_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_file_count() const {
  return _internal_has_file_count();
}
inline void ResponseSongFileChunk::clear_file_count() {
  _impl_.file_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t ResponseSongFileChunk::_internal_file_count() const {
  return _impl_.file_count_;
}
inline int32_t ResponseSongFileChunk::file_count() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.file_count)
  return _internal_file_count();
}
inline void ResponseSongFileChunk::_internal_set_file_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.file_count_ = value;
}
inline void ResponseSongFileChunk::set_file_count(int32_t value) {
  _internal_set_file_count(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.file_count)
}

// optional .cpb.remote.SongMetadata song_metadata = 6;
inline bool ResponseSongFileChunk::_internal_has_song_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.song_metadata_ != nullptr);
  return value;
}
inline bool ResponseSongFileChunk::has_song_metadata() const {
  return _internal_has_song_metadata();
}
inline void ResponseSongFileChunk::clear_song_metadata() {
  if (_impl_.song_metadata_ != nullptr) _impl_.song_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cpb::remote::SongMetadata& ResponseSongFileChunk::_internal_song_metadata() const {
  const ::cpb::remote::SongMetadata* p = _impl_.song_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::SongMetadata&>(
      ::cpb::remote::_SongMetadata_default_instance_);
}
inline const ::cpb::remote::SongMetadata& ResponseSongFileChunk::song_metadata() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.song_metadata)
  return _internal_song_metadata();
}
inline void ResponseSongFileChunk::unsafe_arena_set_allocated_song_metadata(
    ::cpb::remote::SongMetadata* song_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.song_metadata_);
  }
  _impl_.song_metadata_ = song_metadata;
  if (song_metadata) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.ResponseSongFileChunk.song_metadata)
}
inline ::cpb::remote::SongMetadata* ResponseSongFileChunk::release_song_metadata() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cpb::remote::SongMetadata* temp = _impl_.song_metadata_;
  _impl_.song_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::SongMetadata* ResponseSongFileChunk::unsafe_arena_release_song_metadata() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseSongFileChunk.song_metadata)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cpb::remote::SongMetadata* temp = _impl_.song_metadata_;
  _impl_.song_metadata_ = nullptr;
  return temp;
}
inline ::cpb::remote::SongMetadata* ResponseSongFileChunk::_internal_mutable_song_metadata() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.song_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::SongMetadata>(GetArenaForAllocation());
    _impl_.song_metadata_ = p;
  }
  return _impl_.song_metadata_;
}
inline ::cpb::remote::SongMetadata* ResponseSongFileChunk::mutable_song_metadata() {
  ::cpb::remote::SongMetadata* _msg = _internal_mutable_song_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseSongFileChunk.song_metadata)
  return _msg;
}
inline void ResponseSongFileChunk::set_allocated_song_metadata(::cpb::remote::SongMetadata* song_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.song_metadata_;
  }
  if (song_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(song_metadata);
    if (message_arena != submessage_arena) {
      song_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, song_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.song_metadata_ = song_metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseSongFileChunk.song_metadata)
}

// optional bytes data = 7;
inline bool ResponseSongFileChunk::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_data() const {
  return _internal_has_data();
}
inline void ResponseSongFileChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseSongFileChunk::data() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseSongFileChunk::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.data)
}
inline std::string* ResponseSongFileChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseSongFileChunk.data)
  return _s;
}
inline const std::string& ResponseSongFileChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseSongFileChunk::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseSongFileChunk::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseSongFileChunk::release_data() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseSongFileChunk.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseSongFileChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseSongFileChunk.data)
}

// optional int32 size = 8;
inline bool ResponseSongFileChunk::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_size() const {
  return _internal_has_size();
}
inline void ResponseSongFileChunk::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t ResponseSongFileChunk::_internal_size() const {
  return _impl_.size_;
}
inline int32_t ResponseSongFileChunk::size() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.size)
  return _internal_size();
}
inline void ResponseSongFileChunk::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.size_ = value;
}
inline void ResponseSongFileChunk::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.size)
}

// optional bytes file_hash = 9;
inline bool ResponseSongFileChunk::_internal_has_file_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseSongFileChunk::has_file_hash() const {
  return _internal_has_file_hash();
}
inline void ResponseSongFileChunk::clear_file_hash() {
  _impl_.file_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseSongFileChunk::file_hash() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongFileChunk.file_hash)
  return _internal_file_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseSongFileChunk::set_file_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.file_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongFileChunk.file_hash)
}
inline std::string* ResponseSongFileChunk::mutable_file_hash() {
  std::string* _s = _internal_mutable_file_hash();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseSongFileChunk.file_hash)
  return _s;
}
inline const std::string& ResponseSongFileChunk::_internal_file_hash() const {
  return _impl_.file_hash_.Get();
}
inline void ResponseSongFileChunk::_internal_set_file_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.file_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseSongFileChunk::_internal_mutable_file_hash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.file_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseSongFileChunk::release_file_hash() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseSongFileChunk.file_hash)
  if (!_internal_has_file_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.file_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_hash_.IsDefault()) {
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseSongFileChunk::set_allocated_file_hash(std::string* file_hash) {
  if (file_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.file_hash_.SetAllocated(file_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_hash_.IsDefault()) {
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseSongFileChunk.file_hash)
}

// -------------------------------------------------------------------

// ResponseLibraryChunk

// optional int32 chunk_number = 1;
inline bool ResponseLibraryChunk::_internal_has_chunk_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseLibraryChunk::has_chunk_number() const {
  return _internal_has_chunk_number();
}
inline void ResponseLibraryChunk::clear_chunk_number() {
  _impl_.chunk_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t ResponseLibraryChunk::_internal_chunk_number() const {
  return _impl_.chunk_number_;
}
inline int32_t ResponseLibraryChunk::chunk_number() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseLibraryChunk.chunk_number)
  return _internal_chunk_number();
}
inline void ResponseLibraryChunk::_internal_set_chunk_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.chunk_number_ = value;
}
inline void ResponseLibraryChunk::set_chunk_number(int32_t value) {
  _internal_set_chunk_number(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseLibraryChunk.chunk_number)
}

// optional int32 chunk_count = 2;
inline bool ResponseLibraryChunk::_internal_has_chunk_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResponseLibraryChunk::has_chunk_count() const {
  return _internal_has_chunk_count();
}
inline void ResponseLibraryChunk::clear_chunk_count() {
  _impl_.chunk_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ResponseLibraryChunk::_internal_chunk_count() const {
  return _impl_.chunk_count_;
}
inline int32_t ResponseLibraryChunk::chunk_count() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseLibraryChunk.chunk_count)
  return _internal_chunk_count();
}
inline void ResponseLibraryChunk::_internal_set_chunk_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.chunk_count_ = value;
}
inline void ResponseLibraryChunk::set_chunk_count(int32_t value) {
  _internal_set_chunk_count(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseLibraryChunk.chunk_count)
}

// optional bytes data = 3;
inline bool ResponseLibraryChunk::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseLibraryChunk::has_data() const {
  return _internal_has_data();
}
inline void ResponseLibraryChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseLibraryChunk::data() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseLibraryChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseLibraryChunk::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseLibraryChunk.data)
}
inline std::string* ResponseLibraryChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseLibraryChunk.data)
  return _s;
}
inline const std::string& ResponseLibraryChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ResponseLibraryChunk::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseLibraryChunk::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseLibraryChunk::release_data() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseLibraryChunk.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseLibraryChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseLibraryChunk.data)
}

// optional int32 size = 4;
inline bool ResponseLibraryChunk::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResponseLibraryChunk::has_size() const {
  return _internal_has_size();
}
inline void ResponseLibraryChunk::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ResponseLibraryChunk::_internal_size() const {
  return _impl_.size_;
}
inline int32_t ResponseLibraryChunk::size() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseLibraryChunk.size)
  return _internal_size();
}
inline void ResponseLibraryChunk::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_ = value;
}
inline void ResponseLibraryChunk::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseLibraryChunk.size)
}

// optional bytes file_hash = 5;
inline bool ResponseLibraryChunk::_internal_has_file_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseLibraryChunk::has_file_hash() const {
  return _internal_has_file_hash();
}
inline void ResponseLibraryChunk::clear_file_hash() {
  _impl_.file_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseLibraryChunk::file_hash() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseLibraryChunk.file_hash)
  return _internal_file_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseLibraryChunk::set_file_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.file_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseLibraryChunk.file_hash)
}
inline std::string* ResponseLibraryChunk::mutable_file_hash() {
  std::string* _s = _internal_mutable_file_hash();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseLibraryChunk.file_hash)
  return _s;
}
inline const std::string& ResponseLibraryChunk::_internal_file_hash() const {
  return _impl_.file_hash_.Get();
}
inline void ResponseLibraryChunk::_internal_set_file_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.file_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseLibraryChunk::_internal_mutable_file_hash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.file_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseLibraryChunk::release_file_hash() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseLibraryChunk.file_hash)
  if (!_internal_has_file_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.file_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_hash_.IsDefault()) {
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseLibraryChunk::set_allocated_file_hash(std::string* file_hash) {
  if (file_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.file_hash_.SetAllocated(file_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_hash_.IsDefault()) {
    _impl_.file_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseLibraryChunk.file_hash)
}

// -------------------------------------------------------------------

// ResponseSongOffer

// optional bool accepted = 1;
inline bool ResponseSongOffer::_internal_has_accepted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseSongOffer::has_accepted() const {
  return _internal_has_accepted();
}
inline void ResponseSongOffer::clear_accepted() {
  _impl_.accepted_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ResponseSongOffer::_internal_accepted() const {
  return _impl_.accepted_;
}
inline bool ResponseSongOffer::accepted() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSongOffer.accepted)
  return _internal_accepted();
}
inline void ResponseSongOffer::_internal_set_accepted(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.accepted_ = value;
}
inline void ResponseSongOffer::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseSongOffer.accepted)
}

// -------------------------------------------------------------------

// RequestRateSong

// optional float rating = 1;
inline bool RequestRateSong::_internal_has_rating() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestRateSong::has_rating() const {
  return _internal_has_rating();
}
inline void RequestRateSong::clear_rating() {
  _impl_.rating_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float RequestRateSong::_internal_rating() const {
  return _impl_.rating_;
}
inline float RequestRateSong::rating() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestRateSong.rating)
  return _internal_rating();
}
inline void RequestRateSong::_internal_set_rating(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rating_ = value;
}
inline void RequestRateSong::set_rating(float value) {
  _internal_set_rating(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestRateSong.rating)
}

// -------------------------------------------------------------------

// ResponseDownloadTotalSize

// optional int32 total_size = 1;
inline bool ResponseDownloadTotalSize::_internal_has_total_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseDownloadTotalSize::has_total_size() const {
  return _internal_has_total_size();
}
inline void ResponseDownloadTotalSize::clear_total_size() {
  _impl_.total_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResponseDownloadTotalSize::_internal_total_size() const {
  return _impl_.total_size_;
}
inline int32_t ResponseDownloadTotalSize::total_size() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseDownloadTotalSize.total_size)
  return _internal_total_size();
}
inline void ResponseDownloadTotalSize::_internal_set_total_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.total_size_ = value;
}
inline void ResponseDownloadTotalSize::set_total_size(int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseDownloadTotalSize.total_size)
}

// optional int32 file_count = 2;
inline bool ResponseDownloadTotalSize::_internal_has_file_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseDownloadTotalSize::has_file_count() const {
  return _internal_has_file_count();
}
inline void ResponseDownloadTotalSize::clear_file_count() {
  _impl_.file_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ResponseDownloadTotalSize::_internal_file_count() const {
  return _impl_.file_count_;
}
inline int32_t ResponseDownloadTotalSize::file_count() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseDownloadTotalSize.file_count)
  return _internal_file_count();
}
inline void ResponseDownloadTotalSize::_internal_set_file_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.file_count_ = value;
}
inline void ResponseDownloadTotalSize::set_file_count(int32_t value) {
  _internal_set_file_count(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseDownloadTotalSize.file_count)
}

// -------------------------------------------------------------------

// RequestGlobalSearch

// optional string query = 1;
inline bool RequestGlobalSearch::_internal_has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestGlobalSearch::has_query() const {
  return _internal_has_query();
}
inline void RequestGlobalSearch::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestGlobalSearch::query() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestGlobalSearch.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestGlobalSearch::set_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestGlobalSearch.query)
}
inline std::string* RequestGlobalSearch::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestGlobalSearch.query)
  return _s;
}
inline const std::string& RequestGlobalSearch::_internal_query() const {
  return _impl_.query_.Get();
}
inline void RequestGlobalSearch::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestGlobalSearch::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestGlobalSearch::release_query() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestGlobalSearch.query)
  if (!_internal_has_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestGlobalSearch::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestGlobalSearch.query)
}

// -------------------------------------------------------------------

// ResponseGlobalSearch

// optional int32 id = 1;
inline bool ResponseGlobalSearch::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResponseGlobalSearch::has_id() const {
  return _internal_has_id();
}
inline void ResponseGlobalSearch::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ResponseGlobalSearch::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ResponseGlobalSearch::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearch.id)
  return _internal_id();
}
inline void ResponseGlobalSearch::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}
inline void ResponseGlobalSearch::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearch.id)
}

// optional string query = 2;
inline bool ResponseGlobalSearch::_internal_has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseGlobalSearch::has_query() const {
  return _internal_has_query();
}
inline void ResponseGlobalSearch::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseGlobalSearch::query() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearch.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseGlobalSearch::set_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearch.query)
}
inline std::string* ResponseGlobalSearch::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseGlobalSearch.query)
  return _s;
}
inline const std::string& ResponseGlobalSearch::_internal_query() const {
  return _impl_.query_.Get();
}
inline void ResponseGlobalSearch::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearch::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearch::release_query() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseGlobalSearch.query)
  if (!_internal_has_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseGlobalSearch::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseGlobalSearch.query)
}

// optional string search_provider = 3;
inline bool ResponseGlobalSearch::_internal_has_search_provider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseGlobalSearch::has_search_provider() const {
  return _internal_has_search_provider();
}
inline void ResponseGlobalSearch::clear_search_provider() {
  _impl_.search_provider_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseGlobalSearch::search_provider() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearch.search_provider)
  return _internal_search_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseGlobalSearch::set_search_provider(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.search_provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearch.search_provider)
}
inline std::string* ResponseGlobalSearch::mutable_search_provider() {
  std::string* _s = _internal_mutable_search_provider();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseGlobalSearch.search_provider)
  return _s;
}
inline const std::string& ResponseGlobalSearch::_internal_search_provider() const {
  return _impl_.search_provider_.Get();
}
inline void ResponseGlobalSearch::_internal_set_search_provider(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.search_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearch::_internal_mutable_search_provider() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.search_provider_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearch::release_search_provider() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseGlobalSearch.search_provider)
  if (!_internal_has_search_provider()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.search_provider_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.search_provider_.IsDefault()) {
    _impl_.search_provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseGlobalSearch::set_allocated_search_provider(std::string* search_provider) {
  if (search_provider != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.search_provider_.SetAllocated(search_provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.search_provider_.IsDefault()) {
    _impl_.search_provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseGlobalSearch.search_provider)
}

// repeated .cpb.remote.SongMetadata song_metadata = 4;
inline int ResponseGlobalSearch::_internal_song_metadata_size() const {
  return _impl_.song_metadata_.size();
}
inline int ResponseGlobalSearch::song_metadata_size() const {
  return _internal_song_metadata_size();
}
inline void ResponseGlobalSearch::clear_song_metadata() {
  _impl_.song_metadata_.Clear();
}
inline ::cpb::remote::SongMetadata* ResponseGlobalSearch::mutable_song_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseGlobalSearch.song_metadata)
  return _impl_.song_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >*
ResponseGlobalSearch::mutable_song_metadata() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponseGlobalSearch.song_metadata)
  return &_impl_.song_metadata_;
}
inline const ::cpb::remote::SongMetadata& ResponseGlobalSearch::_internal_song_metadata(int index) const {
  return _impl_.song_metadata_.Get(index);
}
inline const ::cpb::remote::SongMetadata& ResponseGlobalSearch::song_metadata(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearch.song_metadata)
  return _internal_song_metadata(index);
}
inline ::cpb::remote::SongMetadata* ResponseGlobalSearch::_internal_add_song_metadata() {
  return _impl_.song_metadata_.Add();
}
inline ::cpb::remote::SongMetadata* ResponseGlobalSearch::add_song_metadata() {
  ::cpb::remote::SongMetadata* _add = _internal_add_song_metadata();
  // @@protoc_insertion_point(field_add:cpb.remote.ResponseGlobalSearch.song_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::SongMetadata >&
ResponseGlobalSearch::song_metadata() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponseGlobalSearch.song_metadata)
  return _impl_.song_metadata_;
}

// optional bytes search_provider_icon = 5;
inline bool ResponseGlobalSearch::_internal_has_search_provider_icon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseGlobalSearch::has_search_provider_icon() const {
  return _internal_has_search_provider_icon();
}
inline void ResponseGlobalSearch::clear_search_provider_icon() {
  _impl_.search_provider_icon_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ResponseGlobalSearch::search_provider_icon() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearch.search_provider_icon)
  return _internal_search_provider_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseGlobalSearch::set_search_provider_icon(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.search_provider_icon_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearch.search_provider_icon)
}
inline std::string* ResponseGlobalSearch::mutable_search_provider_icon() {
  std::string* _s = _internal_mutable_search_provider_icon();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseGlobalSearch.search_provider_icon)
  return _s;
}
inline const std::string& ResponseGlobalSearch::_internal_search_provider_icon() const {
  return _impl_.search_provider_icon_.Get();
}
inline void ResponseGlobalSearch::_internal_set_search_provider_icon(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.search_provider_icon_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearch::_internal_mutable_search_provider_icon() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.search_provider_icon_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearch::release_search_provider_icon() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseGlobalSearch.search_provider_icon)
  if (!_internal_has_search_provider_icon()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.search_provider_icon_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.search_provider_icon_.IsDefault()) {
    _impl_.search_provider_icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseGlobalSearch::set_allocated_search_provider_icon(std::string* search_provider_icon) {
  if (search_provider_icon != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.search_provider_icon_.SetAllocated(search_provider_icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.search_provider_icon_.IsDefault()) {
    _impl_.search_provider_icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseGlobalSearch.search_provider_icon)
}

// -------------------------------------------------------------------

// ResponseTranscoderStatus

// optional int32 processed = 1;
inline bool ResponseTranscoderStatus::_internal_has_processed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseTranscoderStatus::has_processed() const {
  return _internal_has_processed();
}
inline void ResponseTranscoderStatus::clear_processed() {
  _impl_.processed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ResponseTranscoderStatus::_internal_processed() const {
  return _impl_.processed_;
}
inline int32_t ResponseTranscoderStatus::processed() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseTranscoderStatus.processed)
  return _internal_processed();
}
inline void ResponseTranscoderStatus::_internal_set_processed(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.processed_ = value;
}
inline void ResponseTranscoderStatus::set_processed(int32_t value) {
  _internal_set_processed(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseTranscoderStatus.processed)
}

// optional int32 total = 2;
inline bool ResponseTranscoderStatus::_internal_has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseTranscoderStatus::has_total() const {
  return _internal_has_total();
}
inline void ResponseTranscoderStatus::clear_total() {
  _impl_.total_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ResponseTranscoderStatus::_internal_total() const {
  return _impl_.total_;
}
inline int32_t ResponseTranscoderStatus::total() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseTranscoderStatus.total)
  return _internal_total();
}
inline void ResponseTranscoderStatus::_internal_set_total(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.total_ = value;
}
inline void ResponseTranscoderStatus::set_total(int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseTranscoderStatus.total)
}

// -------------------------------------------------------------------

// ResponseGlobalSearchStatus

// optional int32 id = 1;
inline bool ResponseGlobalSearchStatus::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseGlobalSearchStatus::has_id() const {
  return _internal_has_id();
}
inline void ResponseGlobalSearchStatus::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ResponseGlobalSearchStatus::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ResponseGlobalSearchStatus::id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearchStatus.id)
  return _internal_id();
}
inline void ResponseGlobalSearchStatus::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void ResponseGlobalSearchStatus::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearchStatus.id)
}

// optional string query = 2;
inline bool ResponseGlobalSearchStatus::_internal_has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseGlobalSearchStatus::has_query() const {
  return _internal_has_query();
}
inline void ResponseGlobalSearchStatus::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseGlobalSearchStatus::query() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearchStatus.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseGlobalSearchStatus::set_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearchStatus.query)
}
inline std::string* ResponseGlobalSearchStatus::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseGlobalSearchStatus.query)
  return _s;
}
inline const std::string& ResponseGlobalSearchStatus::_internal_query() const {
  return _impl_.query_.Get();
}
inline void ResponseGlobalSearchStatus::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearchStatus::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseGlobalSearchStatus::release_query() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseGlobalSearchStatus.query)
  if (!_internal_has_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseGlobalSearchStatus::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseGlobalSearchStatus.query)
}

// optional .cpb.remote.GlobalSearchStatus status = 3;
inline bool ResponseGlobalSearchStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseGlobalSearchStatus::has_status() const {
  return _internal_has_status();
}
inline void ResponseGlobalSearchStatus::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::cpb::remote::GlobalSearchStatus ResponseGlobalSearchStatus::_internal_status() const {
  return static_cast< ::cpb::remote::GlobalSearchStatus >(_impl_.status_);
}
inline ::cpb::remote::GlobalSearchStatus ResponseGlobalSearchStatus::status() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseGlobalSearchStatus.status)
  return _internal_status();
}
inline void ResponseGlobalSearchStatus::_internal_set_status(::cpb::remote::GlobalSearchStatus value) {
  assert(::cpb::remote::GlobalSearchStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void ResponseGlobalSearchStatus::set_status(::cpb::remote::GlobalSearchStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseGlobalSearchStatus.status)
}

// -------------------------------------------------------------------

// RequestListFiles

// optional string relative_path = 1;
inline bool RequestListFiles::_internal_has_relative_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestListFiles::has_relative_path() const {
  return _internal_has_relative_path();
}
inline void RequestListFiles::clear_relative_path() {
  _impl_.relative_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestListFiles::relative_path() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestListFiles.relative_path)
  return _internal_relative_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestListFiles::set_relative_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.relative_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestListFiles.relative_path)
}
inline std::string* RequestListFiles::mutable_relative_path() {
  std::string* _s = _internal_mutable_relative_path();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestListFiles.relative_path)
  return _s;
}
inline const std::string& RequestListFiles::_internal_relative_path() const {
  return _impl_.relative_path_.Get();
}
inline void RequestListFiles::_internal_set_relative_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.relative_path_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestListFiles::_internal_mutable_relative_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.relative_path_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestListFiles::release_relative_path() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestListFiles.relative_path)
  if (!_internal_has_relative_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.relative_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestListFiles::set_allocated_relative_path(std::string* relative_path) {
  if (relative_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.relative_path_.SetAllocated(relative_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestListFiles.relative_path)
}

// -------------------------------------------------------------------

// FileMetadata

// optional string filename = 1;
inline bool FileMetadata::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileMetadata::has_filename() const {
  return _internal_has_filename();
}
inline void FileMetadata::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileMetadata::filename() const {
  // @@protoc_insertion_point(field_get:cpb.remote.FileMetadata.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileMetadata::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.FileMetadata.filename)
}
inline std::string* FileMetadata::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:cpb.remote.FileMetadata.filename)
  return _s;
}
inline const std::string& FileMetadata::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void FileMetadata::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMetadata::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* FileMetadata::release_filename() {
  // @@protoc_insertion_point(field_release:cpb.remote.FileMetadata.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FileMetadata::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.FileMetadata.filename)
}

// optional bool is_dir = 2;
inline bool FileMetadata::_internal_has_is_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileMetadata::has_is_dir() const {
  return _internal_has_is_dir();
}
inline void FileMetadata::clear_is_dir() {
  _impl_.is_dir_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FileMetadata::_internal_is_dir() const {
  return _impl_.is_dir_;
}
inline bool FileMetadata::is_dir() const {
  // @@protoc_insertion_point(field_get:cpb.remote.FileMetadata.is_dir)
  return _internal_is_dir();
}
inline void FileMetadata::_internal_set_is_dir(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_dir_ = value;
}
inline void FileMetadata::set_is_dir(bool value) {
  _internal_set_is_dir(value);
  // @@protoc_insertion_point(field_set:cpb.remote.FileMetadata.is_dir)
}

// -------------------------------------------------------------------

// ResponseListFiles

// optional string relative_path = 1;
inline bool ResponseListFiles::_internal_has_relative_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseListFiles::has_relative_path() const {
  return _internal_has_relative_path();
}
inline void ResponseListFiles::clear_relative_path() {
  _impl_.relative_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseListFiles::relative_path() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseListFiles.relative_path)
  return _internal_relative_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseListFiles::set_relative_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.relative_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseListFiles.relative_path)
}
inline std::string* ResponseListFiles::mutable_relative_path() {
  std::string* _s = _internal_mutable_relative_path();
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseListFiles.relative_path)
  return _s;
}
inline const std::string& ResponseListFiles::_internal_relative_path() const {
  return _impl_.relative_path_.Get();
}
inline void ResponseListFiles::_internal_set_relative_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.relative_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseListFiles::_internal_mutable_relative_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.relative_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseListFiles::release_relative_path() {
  // @@protoc_insertion_point(field_release:cpb.remote.ResponseListFiles.relative_path)
  if (!_internal_has_relative_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.relative_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseListFiles::set_allocated_relative_path(std::string* relative_path) {
  if (relative_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.relative_path_.SetAllocated(relative_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.ResponseListFiles.relative_path)
}

// repeated .cpb.remote.FileMetadata files = 2;
inline int ResponseListFiles::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int ResponseListFiles::files_size() const {
  return _internal_files_size();
}
inline void ResponseListFiles::clear_files() {
  _impl_.files_.Clear();
}
inline ::cpb::remote::FileMetadata* ResponseListFiles::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseListFiles.files)
  return _impl_.files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::FileMetadata >*
ResponseListFiles::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponseListFiles.files)
  return &_impl_.files_;
}
inline const ::cpb::remote::FileMetadata& ResponseListFiles::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const ::cpb::remote::FileMetadata& ResponseListFiles::files(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseListFiles.files)
  return _internal_files(index);
}
inline ::cpb::remote::FileMetadata* ResponseListFiles::_internal_add_files() {
  return _impl_.files_.Add();
}
inline ::cpb::remote::FileMetadata* ResponseListFiles::add_files() {
  ::cpb::remote::FileMetadata* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:cpb.remote.ResponseListFiles.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::FileMetadata >&
ResponseListFiles::files() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponseListFiles.files)
  return _impl_.files_;
}

// optional .cpb.remote.ResponseListFiles.Error error = 3;
inline bool ResponseListFiles::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseListFiles::has_error() const {
  return _internal_has_error();
}
inline void ResponseListFiles::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::cpb::remote::ResponseListFiles_Error ResponseListFiles::_internal_error() const {
  return static_cast< ::cpb::remote::ResponseListFiles_Error >(_impl_.error_);
}
inline ::cpb::remote::ResponseListFiles_Error ResponseListFiles::error() const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseListFiles.error)
  return _internal_error();
}
inline void ResponseListFiles::_internal_set_error(::cpb::remote::ResponseListFiles_Error value) {
  assert(::cpb::remote::ResponseListFiles_Error_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_ = value;
}
inline void ResponseListFiles::set_error(::cpb::remote::ResponseListFiles_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:cpb.remote.ResponseListFiles.error)
}

// -------------------------------------------------------------------

// RequestAppendFiles

// optional int32 playlist_id = 1;
inline bool RequestAppendFiles::_internal_has_playlist_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestAppendFiles::has_playlist_id() const {
  return _internal_has_playlist_id();
}
inline void RequestAppendFiles::clear_playlist_id() {
  _impl_.playlist_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RequestAppendFiles::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline int32_t RequestAppendFiles::playlist_id() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestAppendFiles.playlist_id)
  return _internal_playlist_id();
}
inline void RequestAppendFiles::_internal_set_playlist_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.playlist_id_ = value;
}
inline void RequestAppendFiles::set_playlist_id(int32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.playlist_id)
}

// optional string new_playlist_name = 2;
inline bool RequestAppendFiles::_internal_has_new_playlist_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestAppendFiles::has_new_playlist_name() const {
  return _internal_has_new_playlist_name();
}
inline void RequestAppendFiles::clear_new_playlist_name() {
  _impl_.new_playlist_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestAppendFiles::new_playlist_name() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestAppendFiles.new_playlist_name)
  return _internal_new_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestAppendFiles::set_new_playlist_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.new_playlist_name)
}
inline std::string* RequestAppendFiles::mutable_new_playlist_name() {
  std::string* _s = _internal_mutable_new_playlist_name();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestAppendFiles.new_playlist_name)
  return _s;
}
inline const std::string& RequestAppendFiles::_internal_new_playlist_name() const {
  return _impl_.new_playlist_name_.Get();
}
inline void RequestAppendFiles::_internal_set_new_playlist_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestAppendFiles::_internal_mutable_new_playlist_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestAppendFiles::release_new_playlist_name() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestAppendFiles.new_playlist_name)
  if (!_internal_has_new_playlist_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_playlist_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_playlist_name_.IsDefault()) {
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestAppendFiles::set_allocated_new_playlist_name(std::string* new_playlist_name) {
  if (new_playlist_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_playlist_name_.SetAllocated(new_playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_playlist_name_.IsDefault()) {
    _impl_.new_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestAppendFiles.new_playlist_name)
}

// optional string relative_path = 3;
inline bool RequestAppendFiles::_internal_has_relative_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestAppendFiles::has_relative_path() const {
  return _internal_has_relative_path();
}
inline void RequestAppendFiles::clear_relative_path() {
  _impl_.relative_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestAppendFiles::relative_path() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestAppendFiles.relative_path)
  return _internal_relative_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestAppendFiles::set_relative_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.relative_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.relative_path)
}
inline std::string* RequestAppendFiles::mutable_relative_path() {
  std::string* _s = _internal_mutable_relative_path();
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestAppendFiles.relative_path)
  return _s;
}
inline const std::string& RequestAppendFiles::_internal_relative_path() const {
  return _impl_.relative_path_.Get();
}
inline void RequestAppendFiles::_internal_set_relative_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.relative_path_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestAppendFiles::_internal_mutable_relative_path() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.relative_path_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestAppendFiles::release_relative_path() {
  // @@protoc_insertion_point(field_release:cpb.remote.RequestAppendFiles.relative_path)
  if (!_internal_has_relative_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.relative_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RequestAppendFiles::set_allocated_relative_path(std::string* relative_path) {
  if (relative_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.relative_path_.SetAllocated(relative_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relative_path_.IsDefault()) {
    _impl_.relative_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.RequestAppendFiles.relative_path)
}

// repeated string files = 4;
inline int RequestAppendFiles::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int RequestAppendFiles::files_size() const {
  return _internal_files_size();
}
inline void RequestAppendFiles::clear_files() {
  _impl_.files_.Clear();
}
inline std::string* RequestAppendFiles::add_files() {
  std::string* _s = _internal_add_files();
  // @@protoc_insertion_point(field_add_mutable:cpb.remote.RequestAppendFiles.files)
  return _s;
}
inline const std::string& RequestAppendFiles::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const std::string& RequestAppendFiles::files(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestAppendFiles.files)
  return _internal_files(index);
}
inline std::string* RequestAppendFiles::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.RequestAppendFiles.files)
  return _impl_.files_.Mutable(index);
}
inline void RequestAppendFiles::set_files(int index, const std::string& value) {
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.files)
}
inline void RequestAppendFiles::set_files(int index, std::string&& value) {
  _impl_.files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.files)
}
inline void RequestAppendFiles::set_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cpb.remote.RequestAppendFiles.files)
}
inline void RequestAppendFiles::set_files(int index, const char* value, size_t size) {
  _impl_.files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cpb.remote.RequestAppendFiles.files)
}
inline std::string* RequestAppendFiles::_internal_add_files() {
  return _impl_.files_.Add();
}
inline void RequestAppendFiles::add_files(const std::string& value) {
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cpb.remote.RequestAppendFiles.files)
}
inline void RequestAppendFiles::add_files(std::string&& value) {
  _impl_.files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cpb.remote.RequestAppendFiles.files)
}
inline void RequestAppendFiles::add_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cpb.remote.RequestAppendFiles.files)
}
inline void RequestAppendFiles::add_files(const char* value, size_t size) {
  _impl_.files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cpb.remote.RequestAppendFiles.files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestAppendFiles::files() const {
  // @@protoc_insertion_point(field_list:cpb.remote.RequestAppendFiles.files)
  return _impl_.files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestAppendFiles::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.RequestAppendFiles.files)
  return &_impl_.files_;
}

// optional bool play_now = 5;
inline bool RequestAppendFiles::_internal_has_play_now() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RequestAppendFiles::has_play_now() const {
  return _internal_has_play_now();
}
inline void RequestAppendFiles::clear_play_now() {
  _impl_.play_now_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RequestAppendFiles::_internal_play_now() const {
  return _impl_.play_now_;
}
inline bool RequestAppendFiles::play_now() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestAppendFiles.play_now)
  return _internal_play_now();
}
inline void RequestAppendFiles::_internal_set_play_now(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.play_now_ = value;
}
inline void RequestAppendFiles::set_play_now(bool value) {
  _internal_set_play_now(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.play_now)
}

// optional bool clear_first = 6;
inline bool RequestAppendFiles::_internal_has_clear_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestAppendFiles::has_clear_first() const {
  return _internal_has_clear_first();
}
inline void RequestAppendFiles::clear_clear_first() {
  _impl_.clear_first_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RequestAppendFiles::_internal_clear_first() const {
  return _impl_.clear_first_;
}
inline bool RequestAppendFiles::clear_first() const {
  // @@protoc_insertion_point(field_get:cpb.remote.RequestAppendFiles.clear_first)
  return _internal_clear_first();
}
inline void RequestAppendFiles::_internal_set_clear_first(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clear_first_ = value;
}
inline void RequestAppendFiles::set_clear_first(bool value) {
  _internal_set_clear_first(value);
  // @@protoc_insertion_point(field_set:cpb.remote.RequestAppendFiles.clear_first)
}

// -------------------------------------------------------------------

// Stream

// optional string name = 1;
inline bool Stream::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Stream::has_name() const {
  return _internal_has_name();
}
inline void Stream::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stream::name() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Stream.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Stream.name)
}
inline std::string* Stream::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Stream.name)
  return _s;
}
inline const std::string& Stream::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Stream::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_name() {
  // @@protoc_insertion_point(field_release:cpb.remote.Stream.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Stream.name)
}

// optional string url = 2;
inline bool Stream::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Stream::has_url() const {
  return _internal_has_url();
}
inline void Stream::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Stream::url() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Stream.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Stream.url)
}
inline std::string* Stream::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Stream.url)
  return _s;
}
inline const std::string& Stream::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Stream::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_url() {
  // @@protoc_insertion_point(field_release:cpb.remote.Stream.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Stream.url)
}

// optional string url_logo = 3;
inline bool Stream::_internal_has_url_logo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Stream::has_url_logo() const {
  return _internal_has_url_logo();
}
inline void Stream::clear_url_logo() {
  _impl_.url_logo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Stream::url_logo() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Stream.url_logo)
  return _internal_url_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Stream::set_url_logo(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.url_logo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cpb.remote.Stream.url_logo)
}
inline std::string* Stream::mutable_url_logo() {
  std::string* _s = _internal_mutable_url_logo();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Stream.url_logo)
  return _s;
}
inline const std::string& Stream::_internal_url_logo() const {
  return _impl_.url_logo_.Get();
}
inline void Stream::_internal_set_url_logo(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.url_logo_.Set(value, GetArenaForAllocation());
}
inline std::string* Stream::_internal_mutable_url_logo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.url_logo_.Mutable(GetArenaForAllocation());
}
inline std::string* Stream::release_url_logo() {
  // @@protoc_insertion_point(field_release:cpb.remote.Stream.url_logo)
  if (!_internal_has_url_logo()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.url_logo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_logo_.IsDefault()) {
    _impl_.url_logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Stream::set_allocated_url_logo(std::string* url_logo) {
  if (url_logo != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.url_logo_.SetAllocated(url_logo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_logo_.IsDefault()) {
    _impl_.url_logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Stream.url_logo)
}

// -------------------------------------------------------------------

// ResponseSavedRadios

// repeated .cpb.remote.Stream streams = 1;
inline int ResponseSavedRadios::_internal_streams_size() const {
  return _impl_.streams_.size();
}
inline int ResponseSavedRadios::streams_size() const {
  return _internal_streams_size();
}
inline void ResponseSavedRadios::clear_streams() {
  _impl_.streams_.Clear();
}
inline ::cpb::remote::Stream* ResponseSavedRadios::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:cpb.remote.ResponseSavedRadios.streams)
  return _impl_.streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Stream >*
ResponseSavedRadios::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:cpb.remote.ResponseSavedRadios.streams)
  return &_impl_.streams_;
}
inline const ::cpb::remote::Stream& ResponseSavedRadios::_internal_streams(int index) const {
  return _impl_.streams_.Get(index);
}
inline const ::cpb::remote::Stream& ResponseSavedRadios::streams(int index) const {
  // @@protoc_insertion_point(field_get:cpb.remote.ResponseSavedRadios.streams)
  return _internal_streams(index);
}
inline ::cpb::remote::Stream* ResponseSavedRadios::_internal_add_streams() {
  return _impl_.streams_.Add();
}
inline ::cpb::remote::Stream* ResponseSavedRadios::add_streams() {
  ::cpb::remote::Stream* _add = _internal_add_streams();
  // @@protoc_insertion_point(field_add:cpb.remote.ResponseSavedRadios.streams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cpb::remote::Stream >&
ResponseSavedRadios::streams() const {
  // @@protoc_insertion_point(field_list:cpb.remote.ResponseSavedRadios.streams)
  return _impl_.streams_;
}

// -------------------------------------------------------------------

// Message

// optional int32 version = 1 [default = 21];
inline bool Message::_internal_has_version() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool Message::has_version() const {
  return _internal_has_version();
}
inline void Message::clear_version() {
  _impl_.version_ = 21;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline int32_t Message::_internal_version() const {
  return _impl_.version_;
}
inline int32_t Message::version() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.version)
  return _internal_version();
}
inline void Message::_internal_set_version(int32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.version_ = value;
}
inline void Message::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Message.version)
}

// optional .cpb.remote.MsgType type = 2 [default = UNKNOWN];
inline bool Message::_internal_has_type() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool Message::has_type() const {
  return _internal_has_type();
}
inline void Message::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline ::cpb::remote::MsgType Message::_internal_type() const {
  return static_cast< ::cpb::remote::MsgType >(_impl_.type_);
}
inline ::cpb::remote::MsgType Message::type() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.type)
  return _internal_type();
}
inline void Message::_internal_set_type(::cpb::remote::MsgType value) {
  assert(::cpb::remote::MsgType_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void Message::set_type(::cpb::remote::MsgType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cpb.remote.Message.type)
}

// optional .cpb.remote.RequestConnect request_connect = 21;
inline bool Message::_internal_has_request_connect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_connect_ != nullptr);
  return value;
}
inline bool Message::has_request_connect() const {
  return _internal_has_request_connect();
}
inline void Message::clear_request_connect() {
  if (_impl_.request_connect_ != nullptr) _impl_.request_connect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::cpb::remote::RequestConnect& Message::_internal_request_connect() const {
  const ::cpb::remote::RequestConnect* p = _impl_.request_connect_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestConnect&>(
      ::cpb::remote::_RequestConnect_default_instance_);
}
inline const ::cpb::remote::RequestConnect& Message::request_connect() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_connect)
  return _internal_request_connect();
}
inline void Message::unsafe_arena_set_allocated_request_connect(
    ::cpb::remote::RequestConnect* request_connect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_connect_);
  }
  _impl_.request_connect_ = request_connect;
  if (request_connect) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_connect)
}
inline ::cpb::remote::RequestConnect* Message::release_request_connect() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::cpb::remote::RequestConnect* temp = _impl_.request_connect_;
  _impl_.request_connect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestConnect* Message::unsafe_arena_release_request_connect() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_connect)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::cpb::remote::RequestConnect* temp = _impl_.request_connect_;
  _impl_.request_connect_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestConnect* Message::_internal_mutable_request_connect() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.request_connect_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestConnect>(GetArenaForAllocation());
    _impl_.request_connect_ = p;
  }
  return _impl_.request_connect_;
}
inline ::cpb::remote::RequestConnect* Message::mutable_request_connect() {
  ::cpb::remote::RequestConnect* _msg = _internal_mutable_request_connect();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_connect)
  return _msg;
}
inline void Message::set_allocated_request_connect(::cpb::remote::RequestConnect* request_connect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_connect_;
  }
  if (request_connect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_connect);
    if (message_arena != submessage_arena) {
      request_connect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_connect, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.request_connect_ = request_connect;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_connect)
}

// optional .cpb.remote.RequestPlaylists request_playlists = 27;
inline bool Message::_internal_has_request_playlists() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_playlists_ != nullptr);
  return value;
}
inline bool Message::has_request_playlists() const {
  return _internal_has_request_playlists();
}
inline void Message::clear_request_playlists() {
  if (_impl_.request_playlists_ != nullptr) _impl_.request_playlists_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::cpb::remote::RequestPlaylists& Message::_internal_request_playlists() const {
  const ::cpb::remote::RequestPlaylists* p = _impl_.request_playlists_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestPlaylists&>(
      ::cpb::remote::_RequestPlaylists_default_instance_);
}
inline const ::cpb::remote::RequestPlaylists& Message::request_playlists() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_playlists)
  return _internal_request_playlists();
}
inline void Message::unsafe_arena_set_allocated_request_playlists(
    ::cpb::remote::RequestPlaylists* request_playlists) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_playlists_);
  }
  _impl_.request_playlists_ = request_playlists;
  if (request_playlists) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_playlists)
}
inline ::cpb::remote::RequestPlaylists* Message::release_request_playlists() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::cpb::remote::RequestPlaylists* temp = _impl_.request_playlists_;
  _impl_.request_playlists_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestPlaylists* Message::unsafe_arena_release_request_playlists() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_playlists)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::cpb::remote::RequestPlaylists* temp = _impl_.request_playlists_;
  _impl_.request_playlists_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestPlaylists* Message::_internal_mutable_request_playlists() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.request_playlists_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestPlaylists>(GetArenaForAllocation());
    _impl_.request_playlists_ = p;
  }
  return _impl_.request_playlists_;
}
inline ::cpb::remote::RequestPlaylists* Message::mutable_request_playlists() {
  ::cpb::remote::RequestPlaylists* _msg = _internal_mutable_request_playlists();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_playlists)
  return _msg;
}
inline void Message::set_allocated_request_playlists(::cpb::remote::RequestPlaylists* request_playlists) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_playlists_;
  }
  if (request_playlists) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_playlists);
    if (message_arena != submessage_arena) {
      request_playlists = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_playlists, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.request_playlists_ = request_playlists;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_playlists)
}

// optional .cpb.remote.RequestPlaylistSongs request_playlist_songs = 10;
inline bool Message::_internal_has_request_playlist_songs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_playlist_songs_ != nullptr);
  return value;
}
inline bool Message::has_request_playlist_songs() const {
  return _internal_has_request_playlist_songs();
}
inline void Message::clear_request_playlist_songs() {
  if (_impl_.request_playlist_songs_ != nullptr) _impl_.request_playlist_songs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cpb::remote::RequestPlaylistSongs& Message::_internal_request_playlist_songs() const {
  const ::cpb::remote::RequestPlaylistSongs* p = _impl_.request_playlist_songs_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestPlaylistSongs&>(
      ::cpb::remote::_RequestPlaylistSongs_default_instance_);
}
inline const ::cpb::remote::RequestPlaylistSongs& Message::request_playlist_songs() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_playlist_songs)
  return _internal_request_playlist_songs();
}
inline void Message::unsafe_arena_set_allocated_request_playlist_songs(
    ::cpb::remote::RequestPlaylistSongs* request_playlist_songs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_playlist_songs_);
  }
  _impl_.request_playlist_songs_ = request_playlist_songs;
  if (request_playlist_songs) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_playlist_songs)
}
inline ::cpb::remote::RequestPlaylistSongs* Message::release_request_playlist_songs() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::remote::RequestPlaylistSongs* temp = _impl_.request_playlist_songs_;
  _impl_.request_playlist_songs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestPlaylistSongs* Message::unsafe_arena_release_request_playlist_songs() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_playlist_songs)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cpb::remote::RequestPlaylistSongs* temp = _impl_.request_playlist_songs_;
  _impl_.request_playlist_songs_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestPlaylistSongs* Message::_internal_mutable_request_playlist_songs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.request_playlist_songs_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestPlaylistSongs>(GetArenaForAllocation());
    _impl_.request_playlist_songs_ = p;
  }
  return _impl_.request_playlist_songs_;
}
inline ::cpb::remote::RequestPlaylistSongs* Message::mutable_request_playlist_songs() {
  ::cpb::remote::RequestPlaylistSongs* _msg = _internal_mutable_request_playlist_songs();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_playlist_songs)
  return _msg;
}
inline void Message::set_allocated_request_playlist_songs(::cpb::remote::RequestPlaylistSongs* request_playlist_songs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_playlist_songs_;
  }
  if (request_playlist_songs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_playlist_songs);
    if (message_arena != submessage_arena) {
      request_playlist_songs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_playlist_songs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_playlist_songs_ = request_playlist_songs;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_playlist_songs)
}

// optional .cpb.remote.RequestChangeSong request_change_song = 11;
inline bool Message::_internal_has_request_change_song() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_change_song_ != nullptr);
  return value;
}
inline bool Message::has_request_change_song() const {
  return _internal_has_request_change_song();
}
inline void Message::clear_request_change_song() {
  if (_impl_.request_change_song_ != nullptr) _impl_.request_change_song_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cpb::remote::RequestChangeSong& Message::_internal_request_change_song() const {
  const ::cpb::remote::RequestChangeSong* p = _impl_.request_change_song_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestChangeSong&>(
      ::cpb::remote::_RequestChangeSong_default_instance_);
}
inline const ::cpb::remote::RequestChangeSong& Message::request_change_song() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_change_song)
  return _internal_request_change_song();
}
inline void Message::unsafe_arena_set_allocated_request_change_song(
    ::cpb::remote::RequestChangeSong* request_change_song) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_change_song_);
  }
  _impl_.request_change_song_ = request_change_song;
  if (request_change_song) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_change_song)
}
inline ::cpb::remote::RequestChangeSong* Message::release_request_change_song() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::remote::RequestChangeSong* temp = _impl_.request_change_song_;
  _impl_.request_change_song_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestChangeSong* Message::unsafe_arena_release_request_change_song() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_change_song)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cpb::remote::RequestChangeSong* temp = _impl_.request_change_song_;
  _impl_.request_change_song_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestChangeSong* Message::_internal_mutable_request_change_song() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.request_change_song_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestChangeSong>(GetArenaForAllocation());
    _impl_.request_change_song_ = p;
  }
  return _impl_.request_change_song_;
}
inline ::cpb::remote::RequestChangeSong* Message::mutable_request_change_song() {
  ::cpb::remote::RequestChangeSong* _msg = _internal_mutable_request_change_song();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_change_song)
  return _msg;
}
inline void Message::set_allocated_request_change_song(::cpb::remote::RequestChangeSong* request_change_song) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_change_song_;
  }
  if (request_change_song) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_change_song);
    if (message_arena != submessage_arena) {
      request_change_song = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_change_song, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.request_change_song_ = request_change_song;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_change_song)
}

// optional .cpb.remote.RequestSetVolume request_set_volume = 12;
inline bool Message::_internal_has_request_set_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_set_volume_ != nullptr);
  return value;
}
inline bool Message::has_request_set_volume() const {
  return _internal_has_request_set_volume();
}
inline void Message::clear_request_set_volume() {
  if (_impl_.request_set_volume_ != nullptr) _impl_.request_set_volume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cpb::remote::RequestSetVolume& Message::_internal_request_set_volume() const {
  const ::cpb::remote::RequestSetVolume* p = _impl_.request_set_volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestSetVolume&>(
      ::cpb::remote::_RequestSetVolume_default_instance_);
}
inline const ::cpb::remote::RequestSetVolume& Message::request_set_volume() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_set_volume)
  return _internal_request_set_volume();
}
inline void Message::unsafe_arena_set_allocated_request_set_volume(
    ::cpb::remote::RequestSetVolume* request_set_volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_set_volume_);
  }
  _impl_.request_set_volume_ = request_set_volume;
  if (request_set_volume) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_set_volume)
}
inline ::cpb::remote::RequestSetVolume* Message::release_request_set_volume() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cpb::remote::RequestSetVolume* temp = _impl_.request_set_volume_;
  _impl_.request_set_volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestSetVolume* Message::unsafe_arena_release_request_set_volume() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_set_volume)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cpb::remote::RequestSetVolume* temp = _impl_.request_set_volume_;
  _impl_.request_set_volume_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestSetVolume* Message::_internal_mutable_request_set_volume() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.request_set_volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestSetVolume>(GetArenaForAllocation());
    _impl_.request_set_volume_ = p;
  }
  return _impl_.request_set_volume_;
}
inline ::cpb::remote::RequestSetVolume* Message::mutable_request_set_volume() {
  ::cpb::remote::RequestSetVolume* _msg = _internal_mutable_request_set_volume();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_set_volume)
  return _msg;
}
inline void Message::set_allocated_request_set_volume(::cpb::remote::RequestSetVolume* request_set_volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_set_volume_;
  }
  if (request_set_volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_set_volume);
    if (message_arena != submessage_arena) {
      request_set_volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_set_volume, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.request_set_volume_ = request_set_volume;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_set_volume)
}

// optional .cpb.remote.RequestSetTrackPosition request_set_track_position = 23;
inline bool Message::_internal_has_request_set_track_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_set_track_position_ != nullptr);
  return value;
}
inline bool Message::has_request_set_track_position() const {
  return _internal_has_request_set_track_position();
}
inline void Message::clear_request_set_track_position() {
  if (_impl_.request_set_track_position_ != nullptr) _impl_.request_set_track_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::cpb::remote::RequestSetTrackPosition& Message::_internal_request_set_track_position() const {
  const ::cpb::remote::RequestSetTrackPosition* p = _impl_.request_set_track_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestSetTrackPosition&>(
      ::cpb::remote::_RequestSetTrackPosition_default_instance_);
}
inline const ::cpb::remote::RequestSetTrackPosition& Message::request_set_track_position() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_set_track_position)
  return _internal_request_set_track_position();
}
inline void Message::unsafe_arena_set_allocated_request_set_track_position(
    ::cpb::remote::RequestSetTrackPosition* request_set_track_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_set_track_position_);
  }
  _impl_.request_set_track_position_ = request_set_track_position;
  if (request_set_track_position) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_set_track_position)
}
inline ::cpb::remote::RequestSetTrackPosition* Message::release_request_set_track_position() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::cpb::remote::RequestSetTrackPosition* temp = _impl_.request_set_track_position_;
  _impl_.request_set_track_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestSetTrackPosition* Message::unsafe_arena_release_request_set_track_position() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_set_track_position)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::cpb::remote::RequestSetTrackPosition* temp = _impl_.request_set_track_position_;
  _impl_.request_set_track_position_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestSetTrackPosition* Message::_internal_mutable_request_set_track_position() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.request_set_track_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestSetTrackPosition>(GetArenaForAllocation());
    _impl_.request_set_track_position_ = p;
  }
  return _impl_.request_set_track_position_;
}
inline ::cpb::remote::RequestSetTrackPosition* Message::mutable_request_set_track_position() {
  ::cpb::remote::RequestSetTrackPosition* _msg = _internal_mutable_request_set_track_position();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_set_track_position)
  return _msg;
}
inline void Message::set_allocated_request_set_track_position(::cpb::remote::RequestSetTrackPosition* request_set_track_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_set_track_position_;
  }
  if (request_set_track_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_set_track_position);
    if (message_arena != submessage_arena) {
      request_set_track_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_set_track_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.request_set_track_position_ = request_set_track_position;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_set_track_position)
}

// optional .cpb.remote.RequestInsertUrls request_insert_urls = 25;
inline bool Message::_internal_has_request_insert_urls() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_insert_urls_ != nullptr);
  return value;
}
inline bool Message::has_request_insert_urls() const {
  return _internal_has_request_insert_urls();
}
inline void Message::clear_request_insert_urls() {
  if (_impl_.request_insert_urls_ != nullptr) _impl_.request_insert_urls_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::cpb::remote::RequestInsertUrls& Message::_internal_request_insert_urls() const {
  const ::cpb::remote::RequestInsertUrls* p = _impl_.request_insert_urls_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestInsertUrls&>(
      ::cpb::remote::_RequestInsertUrls_default_instance_);
}
inline const ::cpb::remote::RequestInsertUrls& Message::request_insert_urls() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_insert_urls)
  return _internal_request_insert_urls();
}
inline void Message::unsafe_arena_set_allocated_request_insert_urls(
    ::cpb::remote::RequestInsertUrls* request_insert_urls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_insert_urls_);
  }
  _impl_.request_insert_urls_ = request_insert_urls;
  if (request_insert_urls) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_insert_urls)
}
inline ::cpb::remote::RequestInsertUrls* Message::release_request_insert_urls() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::cpb::remote::RequestInsertUrls* temp = _impl_.request_insert_urls_;
  _impl_.request_insert_urls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestInsertUrls* Message::unsafe_arena_release_request_insert_urls() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_insert_urls)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::cpb::remote::RequestInsertUrls* temp = _impl_.request_insert_urls_;
  _impl_.request_insert_urls_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestInsertUrls* Message::_internal_mutable_request_insert_urls() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.request_insert_urls_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestInsertUrls>(GetArenaForAllocation());
    _impl_.request_insert_urls_ = p;
  }
  return _impl_.request_insert_urls_;
}
inline ::cpb::remote::RequestInsertUrls* Message::mutable_request_insert_urls() {
  ::cpb::remote::RequestInsertUrls* _msg = _internal_mutable_request_insert_urls();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_insert_urls)
  return _msg;
}
inline void Message::set_allocated_request_insert_urls(::cpb::remote::RequestInsertUrls* request_insert_urls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_insert_urls_;
  }
  if (request_insert_urls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_insert_urls);
    if (message_arena != submessage_arena) {
      request_insert_urls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_insert_urls, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.request_insert_urls_ = request_insert_urls;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_insert_urls)
}

// optional .cpb.remote.RequestRemoveSongs request_remove_songs = 26;
inline bool Message::_internal_has_request_remove_songs() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_remove_songs_ != nullptr);
  return value;
}
inline bool Message::has_request_remove_songs() const {
  return _internal_has_request_remove_songs();
}
inline void Message::clear_request_remove_songs() {
  if (_impl_.request_remove_songs_ != nullptr) _impl_.request_remove_songs_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::cpb::remote::RequestRemoveSongs& Message::_internal_request_remove_songs() const {
  const ::cpb::remote::RequestRemoveSongs* p = _impl_.request_remove_songs_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestRemoveSongs&>(
      ::cpb::remote::_RequestRemoveSongs_default_instance_);
}
inline const ::cpb::remote::RequestRemoveSongs& Message::request_remove_songs() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_remove_songs)
  return _internal_request_remove_songs();
}
inline void Message::unsafe_arena_set_allocated_request_remove_songs(
    ::cpb::remote::RequestRemoveSongs* request_remove_songs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_remove_songs_);
  }
  _impl_.request_remove_songs_ = request_remove_songs;
  if (request_remove_songs) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_remove_songs)
}
inline ::cpb::remote::RequestRemoveSongs* Message::release_request_remove_songs() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::cpb::remote::RequestRemoveSongs* temp = _impl_.request_remove_songs_;
  _impl_.request_remove_songs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestRemoveSongs* Message::unsafe_arena_release_request_remove_songs() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_remove_songs)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::cpb::remote::RequestRemoveSongs* temp = _impl_.request_remove_songs_;
  _impl_.request_remove_songs_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestRemoveSongs* Message::_internal_mutable_request_remove_songs() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.request_remove_songs_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestRemoveSongs>(GetArenaForAllocation());
    _impl_.request_remove_songs_ = p;
  }
  return _impl_.request_remove_songs_;
}
inline ::cpb::remote::RequestRemoveSongs* Message::mutable_request_remove_songs() {
  ::cpb::remote::RequestRemoveSongs* _msg = _internal_mutable_request_remove_songs();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_remove_songs)
  return _msg;
}
inline void Message::set_allocated_request_remove_songs(::cpb::remote::RequestRemoveSongs* request_remove_songs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_remove_songs_;
  }
  if (request_remove_songs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_remove_songs);
    if (message_arena != submessage_arena) {
      request_remove_songs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_remove_songs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.request_remove_songs_ = request_remove_songs;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_remove_songs)
}

// optional .cpb.remote.RequestOpenPlaylist request_open_playlist = 28;
inline bool Message::_internal_has_request_open_playlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_open_playlist_ != nullptr);
  return value;
}
inline bool Message::has_request_open_playlist() const {
  return _internal_has_request_open_playlist();
}
inline void Message::clear_request_open_playlist() {
  if (_impl_.request_open_playlist_ != nullptr) _impl_.request_open_playlist_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::cpb::remote::RequestOpenPlaylist& Message::_internal_request_open_playlist() const {
  const ::cpb::remote::RequestOpenPlaylist* p = _impl_.request_open_playlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestOpenPlaylist&>(
      ::cpb::remote::_RequestOpenPlaylist_default_instance_);
}
inline const ::cpb::remote::RequestOpenPlaylist& Message::request_open_playlist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_open_playlist)
  return _internal_request_open_playlist();
}
inline void Message::unsafe_arena_set_allocated_request_open_playlist(
    ::cpb::remote::RequestOpenPlaylist* request_open_playlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_open_playlist_);
  }
  _impl_.request_open_playlist_ = request_open_playlist;
  if (request_open_playlist) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_open_playlist)
}
inline ::cpb::remote::RequestOpenPlaylist* Message::release_request_open_playlist() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::cpb::remote::RequestOpenPlaylist* temp = _impl_.request_open_playlist_;
  _impl_.request_open_playlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestOpenPlaylist* Message::unsafe_arena_release_request_open_playlist() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_open_playlist)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::cpb::remote::RequestOpenPlaylist* temp = _impl_.request_open_playlist_;
  _impl_.request_open_playlist_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestOpenPlaylist* Message::_internal_mutable_request_open_playlist() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.request_open_playlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestOpenPlaylist>(GetArenaForAllocation());
    _impl_.request_open_playlist_ = p;
  }
  return _impl_.request_open_playlist_;
}
inline ::cpb::remote::RequestOpenPlaylist* Message::mutable_request_open_playlist() {
  ::cpb::remote::RequestOpenPlaylist* _msg = _internal_mutable_request_open_playlist();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_open_playlist)
  return _msg;
}
inline void Message::set_allocated_request_open_playlist(::cpb::remote::RequestOpenPlaylist* request_open_playlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_open_playlist_;
  }
  if (request_open_playlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_open_playlist);
    if (message_arena != submessage_arena) {
      request_open_playlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_open_playlist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.request_open_playlist_ = request_open_playlist;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_open_playlist)
}

// optional .cpb.remote.RequestClosePlaylist request_close_playlist = 29;
inline bool Message::_internal_has_request_close_playlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_close_playlist_ != nullptr);
  return value;
}
inline bool Message::has_request_close_playlist() const {
  return _internal_has_request_close_playlist();
}
inline void Message::clear_request_close_playlist() {
  if (_impl_.request_close_playlist_ != nullptr) _impl_.request_close_playlist_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::cpb::remote::RequestClosePlaylist& Message::_internal_request_close_playlist() const {
  const ::cpb::remote::RequestClosePlaylist* p = _impl_.request_close_playlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestClosePlaylist&>(
      ::cpb::remote::_RequestClosePlaylist_default_instance_);
}
inline const ::cpb::remote::RequestClosePlaylist& Message::request_close_playlist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_close_playlist)
  return _internal_request_close_playlist();
}
inline void Message::unsafe_arena_set_allocated_request_close_playlist(
    ::cpb::remote::RequestClosePlaylist* request_close_playlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_close_playlist_);
  }
  _impl_.request_close_playlist_ = request_close_playlist;
  if (request_close_playlist) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_close_playlist)
}
inline ::cpb::remote::RequestClosePlaylist* Message::release_request_close_playlist() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::cpb::remote::RequestClosePlaylist* temp = _impl_.request_close_playlist_;
  _impl_.request_close_playlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestClosePlaylist* Message::unsafe_arena_release_request_close_playlist() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_close_playlist)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::cpb::remote::RequestClosePlaylist* temp = _impl_.request_close_playlist_;
  _impl_.request_close_playlist_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestClosePlaylist* Message::_internal_mutable_request_close_playlist() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.request_close_playlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestClosePlaylist>(GetArenaForAllocation());
    _impl_.request_close_playlist_ = p;
  }
  return _impl_.request_close_playlist_;
}
inline ::cpb::remote::RequestClosePlaylist* Message::mutable_request_close_playlist() {
  ::cpb::remote::RequestClosePlaylist* _msg = _internal_mutable_request_close_playlist();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_close_playlist)
  return _msg;
}
inline void Message::set_allocated_request_close_playlist(::cpb::remote::RequestClosePlaylist* request_close_playlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_close_playlist_;
  }
  if (request_close_playlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_close_playlist);
    if (message_arena != submessage_arena) {
      request_close_playlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_close_playlist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.request_close_playlist_ = request_close_playlist;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_close_playlist)
}

// optional .cpb.remote.RequestUpdatePlaylist request_update_playlist = 53;
inline bool Message::_internal_has_request_update_playlist() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_update_playlist_ != nullptr);
  return value;
}
inline bool Message::has_request_update_playlist() const {
  return _internal_has_request_update_playlist();
}
inline void Message::clear_request_update_playlist() {
  if (_impl_.request_update_playlist_ != nullptr) _impl_.request_update_playlist_->Clear();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const ::cpb::remote::RequestUpdatePlaylist& Message::_internal_request_update_playlist() const {
  const ::cpb::remote::RequestUpdatePlaylist* p = _impl_.request_update_playlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestUpdatePlaylist&>(
      ::cpb::remote::_RequestUpdatePlaylist_default_instance_);
}
inline const ::cpb::remote::RequestUpdatePlaylist& Message::request_update_playlist() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_update_playlist)
  return _internal_request_update_playlist();
}
inline void Message::unsafe_arena_set_allocated_request_update_playlist(
    ::cpb::remote::RequestUpdatePlaylist* request_update_playlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_update_playlist_);
  }
  _impl_.request_update_playlist_ = request_update_playlist;
  if (request_update_playlist) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_update_playlist)
}
inline ::cpb::remote::RequestUpdatePlaylist* Message::release_request_update_playlist() {
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::cpb::remote::RequestUpdatePlaylist* temp = _impl_.request_update_playlist_;
  _impl_.request_update_playlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestUpdatePlaylist* Message::unsafe_arena_release_request_update_playlist() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_update_playlist)
  _impl_._has_bits_[1] &= ~0x00000004u;
  ::cpb::remote::RequestUpdatePlaylist* temp = _impl_.request_update_playlist_;
  _impl_.request_update_playlist_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestUpdatePlaylist* Message::_internal_mutable_request_update_playlist() {
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.request_update_playlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestUpdatePlaylist>(GetArenaForAllocation());
    _impl_.request_update_playlist_ = p;
  }
  return _impl_.request_update_playlist_;
}
inline ::cpb::remote::RequestUpdatePlaylist* Message::mutable_request_update_playlist() {
  ::cpb::remote::RequestUpdatePlaylist* _msg = _internal_mutable_request_update_playlist();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_update_playlist)
  return _msg;
}
inline void Message::set_allocated_request_update_playlist(::cpb::remote::RequestUpdatePlaylist* request_update_playlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_update_playlist_;
  }
  if (request_update_playlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_update_playlist);
    if (message_arena != submessage_arena) {
      request_update_playlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_update_playlist, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.request_update_playlist_ = request_update_playlist;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_update_playlist)
}

// optional .cpb.remote.RequestDownloadSongs request_download_songs = 31;
inline bool Message::_internal_has_request_download_songs() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_download_songs_ != nullptr);
  return value;
}
inline bool Message::has_request_download_songs() const {
  return _internal_has_request_download_songs();
}
inline void Message::clear_request_download_songs() {
  if (_impl_.request_download_songs_ != nullptr) _impl_.request_download_songs_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::cpb::remote::RequestDownloadSongs& Message::_internal_request_download_songs() const {
  const ::cpb::remote::RequestDownloadSongs* p = _impl_.request_download_songs_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestDownloadSongs&>(
      ::cpb::remote::_RequestDownloadSongs_default_instance_);
}
inline const ::cpb::remote::RequestDownloadSongs& Message::request_download_songs() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_download_songs)
  return _internal_request_download_songs();
}
inline void Message::unsafe_arena_set_allocated_request_download_songs(
    ::cpb::remote::RequestDownloadSongs* request_download_songs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_download_songs_);
  }
  _impl_.request_download_songs_ = request_download_songs;
  if (request_download_songs) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_download_songs)
}
inline ::cpb::remote::RequestDownloadSongs* Message::release_request_download_songs() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::cpb::remote::RequestDownloadSongs* temp = _impl_.request_download_songs_;
  _impl_.request_download_songs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestDownloadSongs* Message::unsafe_arena_release_request_download_songs() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_download_songs)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::cpb::remote::RequestDownloadSongs* temp = _impl_.request_download_songs_;
  _impl_.request_download_songs_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestDownloadSongs* Message::_internal_mutable_request_download_songs() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.request_download_songs_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestDownloadSongs>(GetArenaForAllocation());
    _impl_.request_download_songs_ = p;
  }
  return _impl_.request_download_songs_;
}
inline ::cpb::remote::RequestDownloadSongs* Message::mutable_request_download_songs() {
  ::cpb::remote::RequestDownloadSongs* _msg = _internal_mutable_request_download_songs();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_download_songs)
  return _msg;
}
inline void Message::set_allocated_request_download_songs(::cpb::remote::RequestDownloadSongs* request_download_songs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_download_songs_;
  }
  if (request_download_songs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_download_songs);
    if (message_arena != submessage_arena) {
      request_download_songs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_download_songs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.request_download_songs_ = request_download_songs;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_download_songs)
}

// optional .cpb.remote.RequestRateSong request_rate_song = 35;
inline bool Message::_internal_has_request_rate_song() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_rate_song_ != nullptr);
  return value;
}
inline bool Message::has_request_rate_song() const {
  return _internal_has_request_rate_song();
}
inline void Message::clear_request_rate_song() {
  if (_impl_.request_rate_song_ != nullptr) _impl_.request_rate_song_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::cpb::remote::RequestRateSong& Message::_internal_request_rate_song() const {
  const ::cpb::remote::RequestRateSong* p = _impl_.request_rate_song_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestRateSong&>(
      ::cpb::remote::_RequestRateSong_default_instance_);
}
inline const ::cpb::remote::RequestRateSong& Message::request_rate_song() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_rate_song)
  return _internal_request_rate_song();
}
inline void Message::unsafe_arena_set_allocated_request_rate_song(
    ::cpb::remote::RequestRateSong* request_rate_song) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_rate_song_);
  }
  _impl_.request_rate_song_ = request_rate_song;
  if (request_rate_song) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_rate_song)
}
inline ::cpb::remote::RequestRateSong* Message::release_request_rate_song() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::cpb::remote::RequestRateSong* temp = _impl_.request_rate_song_;
  _impl_.request_rate_song_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestRateSong* Message::unsafe_arena_release_request_rate_song() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_rate_song)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::cpb::remote::RequestRateSong* temp = _impl_.request_rate_song_;
  _impl_.request_rate_song_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestRateSong* Message::_internal_mutable_request_rate_song() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.request_rate_song_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestRateSong>(GetArenaForAllocation());
    _impl_.request_rate_song_ = p;
  }
  return _impl_.request_rate_song_;
}
inline ::cpb::remote::RequestRateSong* Message::mutable_request_rate_song() {
  ::cpb::remote::RequestRateSong* _msg = _internal_mutable_request_rate_song();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_rate_song)
  return _msg;
}
inline void Message::set_allocated_request_rate_song(::cpb::remote::RequestRateSong* request_rate_song) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_rate_song_;
  }
  if (request_rate_song) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_rate_song);
    if (message_arena != submessage_arena) {
      request_rate_song = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_rate_song, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.request_rate_song_ = request_rate_song;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_rate_song)
}

// optional .cpb.remote.RequestGlobalSearch request_global_search = 37;
inline bool Message::_internal_has_request_global_search() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_global_search_ != nullptr);
  return value;
}
inline bool Message::has_request_global_search() const {
  return _internal_has_request_global_search();
}
inline void Message::clear_request_global_search() {
  if (_impl_.request_global_search_ != nullptr) _impl_.request_global_search_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::cpb::remote::RequestGlobalSearch& Message::_internal_request_global_search() const {
  const ::cpb::remote::RequestGlobalSearch* p = _impl_.request_global_search_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestGlobalSearch&>(
      ::cpb::remote::_RequestGlobalSearch_default_instance_);
}
inline const ::cpb::remote::RequestGlobalSearch& Message::request_global_search() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_global_search)
  return _internal_request_global_search();
}
inline void Message::unsafe_arena_set_allocated_request_global_search(
    ::cpb::remote::RequestGlobalSearch* request_global_search) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_global_search_);
  }
  _impl_.request_global_search_ = request_global_search;
  if (request_global_search) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_global_search)
}
inline ::cpb::remote::RequestGlobalSearch* Message::release_request_global_search() {
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::cpb::remote::RequestGlobalSearch* temp = _impl_.request_global_search_;
  _impl_.request_global_search_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestGlobalSearch* Message::unsafe_arena_release_request_global_search() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_global_search)
  _impl_._has_bits_[0] &= ~0x08000000u;
  ::cpb::remote::RequestGlobalSearch* temp = _impl_.request_global_search_;
  _impl_.request_global_search_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestGlobalSearch* Message::_internal_mutable_request_global_search() {
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.request_global_search_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestGlobalSearch>(GetArenaForAllocation());
    _impl_.request_global_search_ = p;
  }
  return _impl_.request_global_search_;
}
inline ::cpb::remote::RequestGlobalSearch* Message::mutable_request_global_search() {
  ::cpb::remote::RequestGlobalSearch* _msg = _internal_mutable_request_global_search();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_global_search)
  return _msg;
}
inline void Message::set_allocated_request_global_search(::cpb::remote::RequestGlobalSearch* request_global_search) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_global_search_;
  }
  if (request_global_search) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_global_search);
    if (message_arena != submessage_arena) {
      request_global_search = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_global_search, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.request_global_search_ = request_global_search;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_global_search)
}

// optional .cpb.remote.RequestListFiles request_list_files = 50;
inline bool Message::_internal_has_request_list_files() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_list_files_ != nullptr);
  return value;
}
inline bool Message::has_request_list_files() const {
  return _internal_has_request_list_files();
}
inline void Message::clear_request_list_files() {
  if (_impl_.request_list_files_ != nullptr) _impl_.request_list_files_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::cpb::remote::RequestListFiles& Message::_internal_request_list_files() const {
  const ::cpb::remote::RequestListFiles* p = _impl_.request_list_files_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestListFiles&>(
      ::cpb::remote::_RequestListFiles_default_instance_);
}
inline const ::cpb::remote::RequestListFiles& Message::request_list_files() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_list_files)
  return _internal_request_list_files();
}
inline void Message::unsafe_arena_set_allocated_request_list_files(
    ::cpb::remote::RequestListFiles* request_list_files) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_list_files_);
  }
  _impl_.request_list_files_ = request_list_files;
  if (request_list_files) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_list_files)
}
inline ::cpb::remote::RequestListFiles* Message::release_request_list_files() {
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::cpb::remote::RequestListFiles* temp = _impl_.request_list_files_;
  _impl_.request_list_files_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestListFiles* Message::unsafe_arena_release_request_list_files() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_list_files)
  _impl_._has_bits_[0] &= ~0x80000000u;
  ::cpb::remote::RequestListFiles* temp = _impl_.request_list_files_;
  _impl_.request_list_files_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestListFiles* Message::_internal_mutable_request_list_files() {
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.request_list_files_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestListFiles>(GetArenaForAllocation());
    _impl_.request_list_files_ = p;
  }
  return _impl_.request_list_files_;
}
inline ::cpb::remote::RequestListFiles* Message::mutable_request_list_files() {
  ::cpb::remote::RequestListFiles* _msg = _internal_mutable_request_list_files();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_list_files)
  return _msg;
}
inline void Message::set_allocated_request_list_files(::cpb::remote::RequestListFiles* request_list_files) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_list_files_;
  }
  if (request_list_files) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_list_files);
    if (message_arena != submessage_arena) {
      request_list_files = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_list_files, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.request_list_files_ = request_list_files;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_list_files)
}

// optional .cpb.remote.RequestAppendFiles request_append_files = 51;
inline bool Message::_internal_has_request_append_files() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_append_files_ != nullptr);
  return value;
}
inline bool Message::has_request_append_files() const {
  return _internal_has_request_append_files();
}
inline void Message::clear_request_append_files() {
  if (_impl_.request_append_files_ != nullptr) _impl_.request_append_files_->Clear();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const ::cpb::remote::RequestAppendFiles& Message::_internal_request_append_files() const {
  const ::cpb::remote::RequestAppendFiles* p = _impl_.request_append_files_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::RequestAppendFiles&>(
      ::cpb::remote::_RequestAppendFiles_default_instance_);
}
inline const ::cpb::remote::RequestAppendFiles& Message::request_append_files() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.request_append_files)
  return _internal_request_append_files();
}
inline void Message::unsafe_arena_set_allocated_request_append_files(
    ::cpb::remote::RequestAppendFiles* request_append_files) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_append_files_);
  }
  _impl_.request_append_files_ = request_append_files;
  if (request_append_files) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.request_append_files)
}
inline ::cpb::remote::RequestAppendFiles* Message::release_request_append_files() {
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::cpb::remote::RequestAppendFiles* temp = _impl_.request_append_files_;
  _impl_.request_append_files_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::RequestAppendFiles* Message::unsafe_arena_release_request_append_files() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.request_append_files)
  _impl_._has_bits_[1] &= ~0x00000001u;
  ::cpb::remote::RequestAppendFiles* temp = _impl_.request_append_files_;
  _impl_.request_append_files_ = nullptr;
  return temp;
}
inline ::cpb::remote::RequestAppendFiles* Message::_internal_mutable_request_append_files() {
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.request_append_files_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::RequestAppendFiles>(GetArenaForAllocation());
    _impl_.request_append_files_ = p;
  }
  return _impl_.request_append_files_;
}
inline ::cpb::remote::RequestAppendFiles* Message::mutable_request_append_files() {
  ::cpb::remote::RequestAppendFiles* _msg = _internal_mutable_request_append_files();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.request_append_files)
  return _msg;
}
inline void Message::set_allocated_request_append_files(::cpb::remote::RequestAppendFiles* request_append_files) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_append_files_;
  }
  if (request_append_files) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_append_files);
    if (message_arena != submessage_arena) {
      request_append_files = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_append_files, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.request_append_files_ = request_append_files;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.request_append_files)
}

// optional .cpb.remote.Repeat repeat = 13;
inline bool Message::_internal_has_repeat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.repeat_ != nullptr);
  return value;
}
inline bool Message::has_repeat() const {
  return _internal_has_repeat();
}
inline void Message::clear_repeat() {
  if (_impl_.repeat_ != nullptr) _impl_.repeat_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::cpb::remote::Repeat& Message::_internal_repeat() const {
  const ::cpb::remote::Repeat* p = _impl_.repeat_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::Repeat&>(
      ::cpb::remote::_Repeat_default_instance_);
}
inline const ::cpb::remote::Repeat& Message::repeat() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.repeat)
  return _internal_repeat();
}
inline void Message::unsafe_arena_set_allocated_repeat(
    ::cpb::remote::Repeat* repeat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.repeat_);
  }
  _impl_.repeat_ = repeat;
  if (repeat) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.repeat)
}
inline ::cpb::remote::Repeat* Message::release_repeat() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cpb::remote::Repeat* temp = _impl_.repeat_;
  _impl_.repeat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::Repeat* Message::unsafe_arena_release_repeat() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.repeat)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cpb::remote::Repeat* temp = _impl_.repeat_;
  _impl_.repeat_ = nullptr;
  return temp;
}
inline ::cpb::remote::Repeat* Message::_internal_mutable_repeat() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.repeat_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::Repeat>(GetArenaForAllocation());
    _impl_.repeat_ = p;
  }
  return _impl_.repeat_;
}
inline ::cpb::remote::Repeat* Message::mutable_repeat() {
  ::cpb::remote::Repeat* _msg = _internal_mutable_repeat();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.repeat)
  return _msg;
}
inline void Message::set_allocated_repeat(::cpb::remote::Repeat* repeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.repeat_;
  }
  if (repeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(repeat);
    if (message_arena != submessage_arena) {
      repeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeat, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.repeat_ = repeat;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.repeat)
}

// optional .cpb.remote.Shuffle shuffle = 14;
inline bool Message::_internal_has_shuffle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shuffle_ != nullptr);
  return value;
}
inline bool Message::has_shuffle() const {
  return _internal_has_shuffle();
}
inline void Message::clear_shuffle() {
  if (_impl_.shuffle_ != nullptr) _impl_.shuffle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::cpb::remote::Shuffle& Message::_internal_shuffle() const {
  const ::cpb::remote::Shuffle* p = _impl_.shuffle_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::Shuffle&>(
      ::cpb::remote::_Shuffle_default_instance_);
}
inline const ::cpb::remote::Shuffle& Message::shuffle() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.shuffle)
  return _internal_shuffle();
}
inline void Message::unsafe_arena_set_allocated_shuffle(
    ::cpb::remote::Shuffle* shuffle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shuffle_);
  }
  _impl_.shuffle_ = shuffle;
  if (shuffle) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.shuffle)
}
inline ::cpb::remote::Shuffle* Message::release_shuffle() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::cpb::remote::Shuffle* temp = _impl_.shuffle_;
  _impl_.shuffle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::Shuffle* Message::unsafe_arena_release_shuffle() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.shuffle)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::cpb::remote::Shuffle* temp = _impl_.shuffle_;
  _impl_.shuffle_ = nullptr;
  return temp;
}
inline ::cpb::remote::Shuffle* Message::_internal_mutable_shuffle() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.shuffle_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::Shuffle>(GetArenaForAllocation());
    _impl_.shuffle_ = p;
  }
  return _impl_.shuffle_;
}
inline ::cpb::remote::Shuffle* Message::mutable_shuffle() {
  ::cpb::remote::Shuffle* _msg = _internal_mutable_shuffle();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.shuffle)
  return _msg;
}
inline void Message::set_allocated_shuffle(::cpb::remote::Shuffle* shuffle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shuffle_;
  }
  if (shuffle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shuffle);
    if (message_arena != submessage_arena) {
      shuffle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shuffle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.shuffle_ = shuffle;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.shuffle)
}

// optional .cpb.remote.ResponseClementineInfo response_clementine_info = 15;
inline bool Message::_internal_has_response_clementine_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_clementine_info_ != nullptr);
  return value;
}
inline bool Message::has_response_clementine_info() const {
  return _internal_has_response_clementine_info();
}
inline void Message::clear_response_clementine_info() {
  if (_impl_.response_clementine_info_ != nullptr) _impl_.response_clementine_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::cpb::remote::ResponseClementineInfo& Message::_internal_response_clementine_info() const {
  const ::cpb::remote::ResponseClementineInfo* p = _impl_.response_clementine_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseClementineInfo&>(
      ::cpb::remote::_ResponseClementineInfo_default_instance_);
}
inline const ::cpb::remote::ResponseClementineInfo& Message::response_clementine_info() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_clementine_info)
  return _internal_response_clementine_info();
}
inline void Message::unsafe_arena_set_allocated_response_clementine_info(
    ::cpb::remote::ResponseClementineInfo* response_clementine_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_clementine_info_);
  }
  _impl_.response_clementine_info_ = response_clementine_info;
  if (response_clementine_info) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_clementine_info)
}
inline ::cpb::remote::ResponseClementineInfo* Message::release_response_clementine_info() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::cpb::remote::ResponseClementineInfo* temp = _impl_.response_clementine_info_;
  _impl_.response_clementine_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseClementineInfo* Message::unsafe_arena_release_response_clementine_info() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_clementine_info)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::cpb::remote::ResponseClementineInfo* temp = _impl_.response_clementine_info_;
  _impl_.response_clementine_info_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseClementineInfo* Message::_internal_mutable_response_clementine_info() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.response_clementine_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseClementineInfo>(GetArenaForAllocation());
    _impl_.response_clementine_info_ = p;
  }
  return _impl_.response_clementine_info_;
}
inline ::cpb::remote::ResponseClementineInfo* Message::mutable_response_clementine_info() {
  ::cpb::remote::ResponseClementineInfo* _msg = _internal_mutable_response_clementine_info();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_clementine_info)
  return _msg;
}
inline void Message::set_allocated_response_clementine_info(::cpb::remote::ResponseClementineInfo* response_clementine_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_clementine_info_;
  }
  if (response_clementine_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_clementine_info);
    if (message_arena != submessage_arena) {
      response_clementine_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_clementine_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.response_clementine_info_ = response_clementine_info;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_clementine_info)
}

// optional .cpb.remote.ResponseCurrentMetadata response_current_metadata = 16;
inline bool Message::_internal_has_response_current_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_current_metadata_ != nullptr);
  return value;
}
inline bool Message::has_response_current_metadata() const {
  return _internal_has_response_current_metadata();
}
inline void Message::clear_response_current_metadata() {
  if (_impl_.response_current_metadata_ != nullptr) _impl_.response_current_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::cpb::remote::ResponseCurrentMetadata& Message::_internal_response_current_metadata() const {
  const ::cpb::remote::ResponseCurrentMetadata* p = _impl_.response_current_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseCurrentMetadata&>(
      ::cpb::remote::_ResponseCurrentMetadata_default_instance_);
}
inline const ::cpb::remote::ResponseCurrentMetadata& Message::response_current_metadata() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_current_metadata)
  return _internal_response_current_metadata();
}
inline void Message::unsafe_arena_set_allocated_response_current_metadata(
    ::cpb::remote::ResponseCurrentMetadata* response_current_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_current_metadata_);
  }
  _impl_.response_current_metadata_ = response_current_metadata;
  if (response_current_metadata) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_current_metadata)
}
inline ::cpb::remote::ResponseCurrentMetadata* Message::release_response_current_metadata() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::cpb::remote::ResponseCurrentMetadata* temp = _impl_.response_current_metadata_;
  _impl_.response_current_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseCurrentMetadata* Message::unsafe_arena_release_response_current_metadata() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_current_metadata)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::cpb::remote::ResponseCurrentMetadata* temp = _impl_.response_current_metadata_;
  _impl_.response_current_metadata_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseCurrentMetadata* Message::_internal_mutable_response_current_metadata() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.response_current_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseCurrentMetadata>(GetArenaForAllocation());
    _impl_.response_current_metadata_ = p;
  }
  return _impl_.response_current_metadata_;
}
inline ::cpb::remote::ResponseCurrentMetadata* Message::mutable_response_current_metadata() {
  ::cpb::remote::ResponseCurrentMetadata* _msg = _internal_mutable_response_current_metadata();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_current_metadata)
  return _msg;
}
inline void Message::set_allocated_response_current_metadata(::cpb::remote::ResponseCurrentMetadata* response_current_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_current_metadata_;
  }
  if (response_current_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_current_metadata);
    if (message_arena != submessage_arena) {
      response_current_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_current_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.response_current_metadata_ = response_current_metadata;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_current_metadata)
}

// optional .cpb.remote.ResponsePlaylists response_playlists = 17;
inline bool Message::_internal_has_response_playlists() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_playlists_ != nullptr);
  return value;
}
inline bool Message::has_response_playlists() const {
  return _internal_has_response_playlists();
}
inline void Message::clear_response_playlists() {
  if (_impl_.response_playlists_ != nullptr) _impl_.response_playlists_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::cpb::remote::ResponsePlaylists& Message::_internal_response_playlists() const {
  const ::cpb::remote::ResponsePlaylists* p = _impl_.response_playlists_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponsePlaylists&>(
      ::cpb::remote::_ResponsePlaylists_default_instance_);
}
inline const ::cpb::remote::ResponsePlaylists& Message::response_playlists() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_playlists)
  return _internal_response_playlists();
}
inline void Message::unsafe_arena_set_allocated_response_playlists(
    ::cpb::remote::ResponsePlaylists* response_playlists) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_playlists_);
  }
  _impl_.response_playlists_ = response_playlists;
  if (response_playlists) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_playlists)
}
inline ::cpb::remote::ResponsePlaylists* Message::release_response_playlists() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::cpb::remote::ResponsePlaylists* temp = _impl_.response_playlists_;
  _impl_.response_playlists_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponsePlaylists* Message::unsafe_arena_release_response_playlists() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_playlists)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::cpb::remote::ResponsePlaylists* temp = _impl_.response_playlists_;
  _impl_.response_playlists_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponsePlaylists* Message::_internal_mutable_response_playlists() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.response_playlists_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponsePlaylists>(GetArenaForAllocation());
    _impl_.response_playlists_ = p;
  }
  return _impl_.response_playlists_;
}
inline ::cpb::remote::ResponsePlaylists* Message::mutable_response_playlists() {
  ::cpb::remote::ResponsePlaylists* _msg = _internal_mutable_response_playlists();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_playlists)
  return _msg;
}
inline void Message::set_allocated_response_playlists(::cpb::remote::ResponsePlaylists* response_playlists) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_playlists_;
  }
  if (response_playlists) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_playlists);
    if (message_arena != submessage_arena) {
      response_playlists = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_playlists, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.response_playlists_ = response_playlists;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_playlists)
}

// optional .cpb.remote.ResponsePlaylistSongs response_playlist_songs = 18;
inline bool Message::_internal_has_response_playlist_songs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_playlist_songs_ != nullptr);
  return value;
}
inline bool Message::has_response_playlist_songs() const {
  return _internal_has_response_playlist_songs();
}
inline void Message::clear_response_playlist_songs() {
  if (_impl_.response_playlist_songs_ != nullptr) _impl_.response_playlist_songs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::cpb::remote::ResponsePlaylistSongs& Message::_internal_response_playlist_songs() const {
  const ::cpb::remote::ResponsePlaylistSongs* p = _impl_.response_playlist_songs_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponsePlaylistSongs&>(
      ::cpb::remote::_ResponsePlaylistSongs_default_instance_);
}
inline const ::cpb::remote::ResponsePlaylistSongs& Message::response_playlist_songs() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_playlist_songs)
  return _internal_response_playlist_songs();
}
inline void Message::unsafe_arena_set_allocated_response_playlist_songs(
    ::cpb::remote::ResponsePlaylistSongs* response_playlist_songs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_playlist_songs_);
  }
  _impl_.response_playlist_songs_ = response_playlist_songs;
  if (response_playlist_songs) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_playlist_songs)
}
inline ::cpb::remote::ResponsePlaylistSongs* Message::release_response_playlist_songs() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::cpb::remote::ResponsePlaylistSongs* temp = _impl_.response_playlist_songs_;
  _impl_.response_playlist_songs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponsePlaylistSongs* Message::unsafe_arena_release_response_playlist_songs() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_playlist_songs)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::cpb::remote::ResponsePlaylistSongs* temp = _impl_.response_playlist_songs_;
  _impl_.response_playlist_songs_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponsePlaylistSongs* Message::_internal_mutable_response_playlist_songs() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.response_playlist_songs_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponsePlaylistSongs>(GetArenaForAllocation());
    _impl_.response_playlist_songs_ = p;
  }
  return _impl_.response_playlist_songs_;
}
inline ::cpb::remote::ResponsePlaylistSongs* Message::mutable_response_playlist_songs() {
  ::cpb::remote::ResponsePlaylistSongs* _msg = _internal_mutable_response_playlist_songs();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_playlist_songs)
  return _msg;
}
inline void Message::set_allocated_response_playlist_songs(::cpb::remote::ResponsePlaylistSongs* response_playlist_songs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_playlist_songs_;
  }
  if (response_playlist_songs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_playlist_songs);
    if (message_arena != submessage_arena) {
      response_playlist_songs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_playlist_songs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.response_playlist_songs_ = response_playlist_songs;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_playlist_songs)
}

// optional .cpb.remote.ResponseEngineStateChanged response_engine_state_changed = 19;
inline bool Message::_internal_has_response_engine_state_changed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_engine_state_changed_ != nullptr);
  return value;
}
inline bool Message::has_response_engine_state_changed() const {
  return _internal_has_response_engine_state_changed();
}
inline void Message::clear_response_engine_state_changed() {
  if (_impl_.response_engine_state_changed_ != nullptr) _impl_.response_engine_state_changed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::cpb::remote::ResponseEngineStateChanged& Message::_internal_response_engine_state_changed() const {
  const ::cpb::remote::ResponseEngineStateChanged* p = _impl_.response_engine_state_changed_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseEngineStateChanged&>(
      ::cpb::remote::_ResponseEngineStateChanged_default_instance_);
}
inline const ::cpb::remote::ResponseEngineStateChanged& Message::response_engine_state_changed() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_engine_state_changed)
  return _internal_response_engine_state_changed();
}
inline void Message::unsafe_arena_set_allocated_response_engine_state_changed(
    ::cpb::remote::ResponseEngineStateChanged* response_engine_state_changed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_engine_state_changed_);
  }
  _impl_.response_engine_state_changed_ = response_engine_state_changed;
  if (response_engine_state_changed) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_engine_state_changed)
}
inline ::cpb::remote::ResponseEngineStateChanged* Message::release_response_engine_state_changed() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::cpb::remote::ResponseEngineStateChanged* temp = _impl_.response_engine_state_changed_;
  _impl_.response_engine_state_changed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseEngineStateChanged* Message::unsafe_arena_release_response_engine_state_changed() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_engine_state_changed)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::cpb::remote::ResponseEngineStateChanged* temp = _impl_.response_engine_state_changed_;
  _impl_.response_engine_state_changed_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseEngineStateChanged* Message::_internal_mutable_response_engine_state_changed() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.response_engine_state_changed_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseEngineStateChanged>(GetArenaForAllocation());
    _impl_.response_engine_state_changed_ = p;
  }
  return _impl_.response_engine_state_changed_;
}
inline ::cpb::remote::ResponseEngineStateChanged* Message::mutable_response_engine_state_changed() {
  ::cpb::remote::ResponseEngineStateChanged* _msg = _internal_mutable_response_engine_state_changed();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_engine_state_changed)
  return _msg;
}
inline void Message::set_allocated_response_engine_state_changed(::cpb::remote::ResponseEngineStateChanged* response_engine_state_changed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_engine_state_changed_;
  }
  if (response_engine_state_changed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_engine_state_changed);
    if (message_arena != submessage_arena) {
      response_engine_state_changed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_engine_state_changed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.response_engine_state_changed_ = response_engine_state_changed;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_engine_state_changed)
}

// optional .cpb.remote.ResponseUpdateTrackPosition response_update_track_position = 20;
inline bool Message::_internal_has_response_update_track_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_update_track_position_ != nullptr);
  return value;
}
inline bool Message::has_response_update_track_position() const {
  return _internal_has_response_update_track_position();
}
inline void Message::clear_response_update_track_position() {
  if (_impl_.response_update_track_position_ != nullptr) _impl_.response_update_track_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::cpb::remote::ResponseUpdateTrackPosition& Message::_internal_response_update_track_position() const {
  const ::cpb::remote::ResponseUpdateTrackPosition* p = _impl_.response_update_track_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseUpdateTrackPosition&>(
      ::cpb::remote::_ResponseUpdateTrackPosition_default_instance_);
}
inline const ::cpb::remote::ResponseUpdateTrackPosition& Message::response_update_track_position() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_update_track_position)
  return _internal_response_update_track_position();
}
inline void Message::unsafe_arena_set_allocated_response_update_track_position(
    ::cpb::remote::ResponseUpdateTrackPosition* response_update_track_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_update_track_position_);
  }
  _impl_.response_update_track_position_ = response_update_track_position;
  if (response_update_track_position) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_update_track_position)
}
inline ::cpb::remote::ResponseUpdateTrackPosition* Message::release_response_update_track_position() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::cpb::remote::ResponseUpdateTrackPosition* temp = _impl_.response_update_track_position_;
  _impl_.response_update_track_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseUpdateTrackPosition* Message::unsafe_arena_release_response_update_track_position() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_update_track_position)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::cpb::remote::ResponseUpdateTrackPosition* temp = _impl_.response_update_track_position_;
  _impl_.response_update_track_position_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseUpdateTrackPosition* Message::_internal_mutable_response_update_track_position() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.response_update_track_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseUpdateTrackPosition>(GetArenaForAllocation());
    _impl_.response_update_track_position_ = p;
  }
  return _impl_.response_update_track_position_;
}
inline ::cpb::remote::ResponseUpdateTrackPosition* Message::mutable_response_update_track_position() {
  ::cpb::remote::ResponseUpdateTrackPosition* _msg = _internal_mutable_response_update_track_position();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_update_track_position)
  return _msg;
}
inline void Message::set_allocated_response_update_track_position(::cpb::remote::ResponseUpdateTrackPosition* response_update_track_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_update_track_position_;
  }
  if (response_update_track_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_update_track_position);
    if (message_arena != submessage_arena) {
      response_update_track_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_update_track_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.response_update_track_position_ = response_update_track_position;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_update_track_position)
}

// optional .cpb.remote.ResponseDisconnect response_disconnect = 22;
inline bool Message::_internal_has_response_disconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_disconnect_ != nullptr);
  return value;
}
inline bool Message::has_response_disconnect() const {
  return _internal_has_response_disconnect();
}
inline void Message::clear_response_disconnect() {
  if (_impl_.response_disconnect_ != nullptr) _impl_.response_disconnect_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::cpb::remote::ResponseDisconnect& Message::_internal_response_disconnect() const {
  const ::cpb::remote::ResponseDisconnect* p = _impl_.response_disconnect_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseDisconnect&>(
      ::cpb::remote::_ResponseDisconnect_default_instance_);
}
inline const ::cpb::remote::ResponseDisconnect& Message::response_disconnect() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_disconnect)
  return _internal_response_disconnect();
}
inline void Message::unsafe_arena_set_allocated_response_disconnect(
    ::cpb::remote::ResponseDisconnect* response_disconnect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_disconnect_);
  }
  _impl_.response_disconnect_ = response_disconnect;
  if (response_disconnect) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_disconnect)
}
inline ::cpb::remote::ResponseDisconnect* Message::release_response_disconnect() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::cpb::remote::ResponseDisconnect* temp = _impl_.response_disconnect_;
  _impl_.response_disconnect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseDisconnect* Message::unsafe_arena_release_response_disconnect() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_disconnect)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::cpb::remote::ResponseDisconnect* temp = _impl_.response_disconnect_;
  _impl_.response_disconnect_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseDisconnect* Message::_internal_mutable_response_disconnect() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.response_disconnect_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseDisconnect>(GetArenaForAllocation());
    _impl_.response_disconnect_ = p;
  }
  return _impl_.response_disconnect_;
}
inline ::cpb::remote::ResponseDisconnect* Message::mutable_response_disconnect() {
  ::cpb::remote::ResponseDisconnect* _msg = _internal_mutable_response_disconnect();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_disconnect)
  return _msg;
}
inline void Message::set_allocated_response_disconnect(::cpb::remote::ResponseDisconnect* response_disconnect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_disconnect_;
  }
  if (response_disconnect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_disconnect);
    if (message_arena != submessage_arena) {
      response_disconnect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_disconnect, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.response_disconnect_ = response_disconnect;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_disconnect)
}

// optional .cpb.remote.ResponseActiveChanged response_active_changed = 24;
inline bool Message::_internal_has_response_active_changed() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_active_changed_ != nullptr);
  return value;
}
inline bool Message::has_response_active_changed() const {
  return _internal_has_response_active_changed();
}
inline void Message::clear_response_active_changed() {
  if (_impl_.response_active_changed_ != nullptr) _impl_.response_active_changed_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::cpb::remote::ResponseActiveChanged& Message::_internal_response_active_changed() const {
  const ::cpb::remote::ResponseActiveChanged* p = _impl_.response_active_changed_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseActiveChanged&>(
      ::cpb::remote::_ResponseActiveChanged_default_instance_);
}
inline const ::cpb::remote::ResponseActiveChanged& Message::response_active_changed() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_active_changed)
  return _internal_response_active_changed();
}
inline void Message::unsafe_arena_set_allocated_response_active_changed(
    ::cpb::remote::ResponseActiveChanged* response_active_changed) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_active_changed_);
  }
  _impl_.response_active_changed_ = response_active_changed;
  if (response_active_changed) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_active_changed)
}
inline ::cpb::remote::ResponseActiveChanged* Message::release_response_active_changed() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::cpb::remote::ResponseActiveChanged* temp = _impl_.response_active_changed_;
  _impl_.response_active_changed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseActiveChanged* Message::unsafe_arena_release_response_active_changed() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_active_changed)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::cpb::remote::ResponseActiveChanged* temp = _impl_.response_active_changed_;
  _impl_.response_active_changed_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseActiveChanged* Message::_internal_mutable_response_active_changed() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.response_active_changed_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseActiveChanged>(GetArenaForAllocation());
    _impl_.response_active_changed_ = p;
  }
  return _impl_.response_active_changed_;
}
inline ::cpb::remote::ResponseActiveChanged* Message::mutable_response_active_changed() {
  ::cpb::remote::ResponseActiveChanged* _msg = _internal_mutable_response_active_changed();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_active_changed)
  return _msg;
}
inline void Message::set_allocated_response_active_changed(::cpb::remote::ResponseActiveChanged* response_active_changed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_active_changed_;
  }
  if (response_active_changed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_active_changed);
    if (message_arena != submessage_arena) {
      response_active_changed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_active_changed, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.response_active_changed_ = response_active_changed;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_active_changed)
}

// optional .cpb.remote.ResponseLyrics response_lyrics = 30;
inline bool Message::_internal_has_response_lyrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_lyrics_ != nullptr);
  return value;
}
inline bool Message::has_response_lyrics() const {
  return _internal_has_response_lyrics();
}
inline void Message::clear_response_lyrics() {
  if (_impl_.response_lyrics_ != nullptr) _impl_.response_lyrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::cpb::remote::ResponseLyrics& Message::_internal_response_lyrics() const {
  const ::cpb::remote::ResponseLyrics* p = _impl_.response_lyrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseLyrics&>(
      ::cpb::remote::_ResponseLyrics_default_instance_);
}
inline const ::cpb::remote::ResponseLyrics& Message::response_lyrics() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_lyrics)
  return _internal_response_lyrics();
}
inline void Message::unsafe_arena_set_allocated_response_lyrics(
    ::cpb::remote::ResponseLyrics* response_lyrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_lyrics_);
  }
  _impl_.response_lyrics_ = response_lyrics;
  if (response_lyrics) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_lyrics)
}
inline ::cpb::remote::ResponseLyrics* Message::release_response_lyrics() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::cpb::remote::ResponseLyrics* temp = _impl_.response_lyrics_;
  _impl_.response_lyrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseLyrics* Message::unsafe_arena_release_response_lyrics() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_lyrics)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::cpb::remote::ResponseLyrics* temp = _impl_.response_lyrics_;
  _impl_.response_lyrics_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseLyrics* Message::_internal_mutable_response_lyrics() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.response_lyrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseLyrics>(GetArenaForAllocation());
    _impl_.response_lyrics_ = p;
  }
  return _impl_.response_lyrics_;
}
inline ::cpb::remote::ResponseLyrics* Message::mutable_response_lyrics() {
  ::cpb::remote::ResponseLyrics* _msg = _internal_mutable_response_lyrics();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_lyrics)
  return _msg;
}
inline void Message::set_allocated_response_lyrics(::cpb::remote::ResponseLyrics* response_lyrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_lyrics_;
  }
  if (response_lyrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_lyrics);
    if (message_arena != submessage_arena) {
      response_lyrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_lyrics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.response_lyrics_ = response_lyrics;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_lyrics)
}

// optional .cpb.remote.ResponseSongFileChunk response_song_file_chunk = 32;
inline bool Message::_internal_has_response_song_file_chunk() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_song_file_chunk_ != nullptr);
  return value;
}
inline bool Message::has_response_song_file_chunk() const {
  return _internal_has_response_song_file_chunk();
}
inline void Message::clear_response_song_file_chunk() {
  if (_impl_.response_song_file_chunk_ != nullptr) _impl_.response_song_file_chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::cpb::remote::ResponseSongFileChunk& Message::_internal_response_song_file_chunk() const {
  const ::cpb::remote::ResponseSongFileChunk* p = _impl_.response_song_file_chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseSongFileChunk&>(
      ::cpb::remote::_ResponseSongFileChunk_default_instance_);
}
inline const ::cpb::remote::ResponseSongFileChunk& Message::response_song_file_chunk() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_song_file_chunk)
  return _internal_response_song_file_chunk();
}
inline void Message::unsafe_arena_set_allocated_response_song_file_chunk(
    ::cpb::remote::ResponseSongFileChunk* response_song_file_chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_song_file_chunk_);
  }
  _impl_.response_song_file_chunk_ = response_song_file_chunk;
  if (response_song_file_chunk) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_song_file_chunk)
}
inline ::cpb::remote::ResponseSongFileChunk* Message::release_response_song_file_chunk() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::cpb::remote::ResponseSongFileChunk* temp = _impl_.response_song_file_chunk_;
  _impl_.response_song_file_chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseSongFileChunk* Message::unsafe_arena_release_response_song_file_chunk() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_song_file_chunk)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::cpb::remote::ResponseSongFileChunk* temp = _impl_.response_song_file_chunk_;
  _impl_.response_song_file_chunk_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseSongFileChunk* Message::_internal_mutable_response_song_file_chunk() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.response_song_file_chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseSongFileChunk>(GetArenaForAllocation());
    _impl_.response_song_file_chunk_ = p;
  }
  return _impl_.response_song_file_chunk_;
}
inline ::cpb::remote::ResponseSongFileChunk* Message::mutable_response_song_file_chunk() {
  ::cpb::remote::ResponseSongFileChunk* _msg = _internal_mutable_response_song_file_chunk();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_song_file_chunk)
  return _msg;
}
inline void Message::set_allocated_response_song_file_chunk(::cpb::remote::ResponseSongFileChunk* response_song_file_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_song_file_chunk_;
  }
  if (response_song_file_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_song_file_chunk);
    if (message_arena != submessage_arena) {
      response_song_file_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_song_file_chunk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.response_song_file_chunk_ = response_song_file_chunk;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_song_file_chunk)
}

// optional .cpb.remote.ResponseSongOffer response_song_offer = 33;
inline bool Message::_internal_has_response_song_offer() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_song_offer_ != nullptr);
  return value;
}
inline bool Message::has_response_song_offer() const {
  return _internal_has_response_song_offer();
}
inline void Message::clear_response_song_offer() {
  if (_impl_.response_song_offer_ != nullptr) _impl_.response_song_offer_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::cpb::remote::ResponseSongOffer& Message::_internal_response_song_offer() const {
  const ::cpb::remote::ResponseSongOffer* p = _impl_.response_song_offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseSongOffer&>(
      ::cpb::remote::_ResponseSongOffer_default_instance_);
}
inline const ::cpb::remote::ResponseSongOffer& Message::response_song_offer() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_song_offer)
  return _internal_response_song_offer();
}
inline void Message::unsafe_arena_set_allocated_response_song_offer(
    ::cpb::remote::ResponseSongOffer* response_song_offer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_song_offer_);
  }
  _impl_.response_song_offer_ = response_song_offer;
  if (response_song_offer) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_song_offer)
}
inline ::cpb::remote::ResponseSongOffer* Message::release_response_song_offer() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::cpb::remote::ResponseSongOffer* temp = _impl_.response_song_offer_;
  _impl_.response_song_offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseSongOffer* Message::unsafe_arena_release_response_song_offer() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_song_offer)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::cpb::remote::ResponseSongOffer* temp = _impl_.response_song_offer_;
  _impl_.response_song_offer_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseSongOffer* Message::_internal_mutable_response_song_offer() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.response_song_offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseSongOffer>(GetArenaForAllocation());
    _impl_.response_song_offer_ = p;
  }
  return _impl_.response_song_offer_;
}
inline ::cpb::remote::ResponseSongOffer* Message::mutable_response_song_offer() {
  ::cpb::remote::ResponseSongOffer* _msg = _internal_mutable_response_song_offer();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_song_offer)
  return _msg;
}
inline void Message::set_allocated_response_song_offer(::cpb::remote::ResponseSongOffer* response_song_offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_song_offer_;
  }
  if (response_song_offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_song_offer);
    if (message_arena != submessage_arena) {
      response_song_offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_song_offer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.response_song_offer_ = response_song_offer;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_song_offer)
}

// optional .cpb.remote.ResponseLibraryChunk response_library_chunk = 34;
inline bool Message::_internal_has_response_library_chunk() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_library_chunk_ != nullptr);
  return value;
}
inline bool Message::has_response_library_chunk() const {
  return _internal_has_response_library_chunk();
}
inline void Message::clear_response_library_chunk() {
  if (_impl_.response_library_chunk_ != nullptr) _impl_.response_library_chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::cpb::remote::ResponseLibraryChunk& Message::_internal_response_library_chunk() const {
  const ::cpb::remote::ResponseLibraryChunk* p = _impl_.response_library_chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseLibraryChunk&>(
      ::cpb::remote::_ResponseLibraryChunk_default_instance_);
}
inline const ::cpb::remote::ResponseLibraryChunk& Message::response_library_chunk() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_library_chunk)
  return _internal_response_library_chunk();
}
inline void Message::unsafe_arena_set_allocated_response_library_chunk(
    ::cpb::remote::ResponseLibraryChunk* response_library_chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_library_chunk_);
  }
  _impl_.response_library_chunk_ = response_library_chunk;
  if (response_library_chunk) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_library_chunk)
}
inline ::cpb::remote::ResponseLibraryChunk* Message::release_response_library_chunk() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::cpb::remote::ResponseLibraryChunk* temp = _impl_.response_library_chunk_;
  _impl_.response_library_chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseLibraryChunk* Message::unsafe_arena_release_response_library_chunk() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_library_chunk)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::cpb::remote::ResponseLibraryChunk* temp = _impl_.response_library_chunk_;
  _impl_.response_library_chunk_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseLibraryChunk* Message::_internal_mutable_response_library_chunk() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.response_library_chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseLibraryChunk>(GetArenaForAllocation());
    _impl_.response_library_chunk_ = p;
  }
  return _impl_.response_library_chunk_;
}
inline ::cpb::remote::ResponseLibraryChunk* Message::mutable_response_library_chunk() {
  ::cpb::remote::ResponseLibraryChunk* _msg = _internal_mutable_response_library_chunk();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_library_chunk)
  return _msg;
}
inline void Message::set_allocated_response_library_chunk(::cpb::remote::ResponseLibraryChunk* response_library_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_library_chunk_;
  }
  if (response_library_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_library_chunk);
    if (message_arena != submessage_arena) {
      response_library_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_library_chunk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.response_library_chunk_ = response_library_chunk;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_library_chunk)
}

// optional .cpb.remote.ResponseDownloadTotalSize response_download_total_size = 36;
inline bool Message::_internal_has_response_download_total_size() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_download_total_size_ != nullptr);
  return value;
}
inline bool Message::has_response_download_total_size() const {
  return _internal_has_response_download_total_size();
}
inline void Message::clear_response_download_total_size() {
  if (_impl_.response_download_total_size_ != nullptr) _impl_.response_download_total_size_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::cpb::remote::ResponseDownloadTotalSize& Message::_internal_response_download_total_size() const {
  const ::cpb::remote::ResponseDownloadTotalSize* p = _impl_.response_download_total_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseDownloadTotalSize&>(
      ::cpb::remote::_ResponseDownloadTotalSize_default_instance_);
}
inline const ::cpb::remote::ResponseDownloadTotalSize& Message::response_download_total_size() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_download_total_size)
  return _internal_response_download_total_size();
}
inline void Message::unsafe_arena_set_allocated_response_download_total_size(
    ::cpb::remote::ResponseDownloadTotalSize* response_download_total_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_download_total_size_);
  }
  _impl_.response_download_total_size_ = response_download_total_size;
  if (response_download_total_size) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_download_total_size)
}
inline ::cpb::remote::ResponseDownloadTotalSize* Message::release_response_download_total_size() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::cpb::remote::ResponseDownloadTotalSize* temp = _impl_.response_download_total_size_;
  _impl_.response_download_total_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseDownloadTotalSize* Message::unsafe_arena_release_response_download_total_size() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_download_total_size)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::cpb::remote::ResponseDownloadTotalSize* temp = _impl_.response_download_total_size_;
  _impl_.response_download_total_size_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseDownloadTotalSize* Message::_internal_mutable_response_download_total_size() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.response_download_total_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseDownloadTotalSize>(GetArenaForAllocation());
    _impl_.response_download_total_size_ = p;
  }
  return _impl_.response_download_total_size_;
}
inline ::cpb::remote::ResponseDownloadTotalSize* Message::mutable_response_download_total_size() {
  ::cpb::remote::ResponseDownloadTotalSize* _msg = _internal_mutable_response_download_total_size();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_download_total_size)
  return _msg;
}
inline void Message::set_allocated_response_download_total_size(::cpb::remote::ResponseDownloadTotalSize* response_download_total_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_download_total_size_;
  }
  if (response_download_total_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_download_total_size);
    if (message_arena != submessage_arena) {
      response_download_total_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_download_total_size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.response_download_total_size_ = response_download_total_size;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_download_total_size)
}

// optional .cpb.remote.ResponseGlobalSearch response_global_search = 38;
inline bool Message::_internal_has_response_global_search() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_global_search_ != nullptr);
  return value;
}
inline bool Message::has_response_global_search() const {
  return _internal_has_response_global_search();
}
inline void Message::clear_response_global_search() {
  if (_impl_.response_global_search_ != nullptr) _impl_.response_global_search_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::cpb::remote::ResponseGlobalSearch& Message::_internal_response_global_search() const {
  const ::cpb::remote::ResponseGlobalSearch* p = _impl_.response_global_search_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseGlobalSearch&>(
      ::cpb::remote::_ResponseGlobalSearch_default_instance_);
}
inline const ::cpb::remote::ResponseGlobalSearch& Message::response_global_search() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_global_search)
  return _internal_response_global_search();
}
inline void Message::unsafe_arena_set_allocated_response_global_search(
    ::cpb::remote::ResponseGlobalSearch* response_global_search) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_global_search_);
  }
  _impl_.response_global_search_ = response_global_search;
  if (response_global_search) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_global_search)
}
inline ::cpb::remote::ResponseGlobalSearch* Message::release_response_global_search() {
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::cpb::remote::ResponseGlobalSearch* temp = _impl_.response_global_search_;
  _impl_.response_global_search_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseGlobalSearch* Message::unsafe_arena_release_response_global_search() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_global_search)
  _impl_._has_bits_[0] &= ~0x10000000u;
  ::cpb::remote::ResponseGlobalSearch* temp = _impl_.response_global_search_;
  _impl_.response_global_search_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseGlobalSearch* Message::_internal_mutable_response_global_search() {
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.response_global_search_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseGlobalSearch>(GetArenaForAllocation());
    _impl_.response_global_search_ = p;
  }
  return _impl_.response_global_search_;
}
inline ::cpb::remote::ResponseGlobalSearch* Message::mutable_response_global_search() {
  ::cpb::remote::ResponseGlobalSearch* _msg = _internal_mutable_response_global_search();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_global_search)
  return _msg;
}
inline void Message::set_allocated_response_global_search(::cpb::remote::ResponseGlobalSearch* response_global_search) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_global_search_;
  }
  if (response_global_search) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_global_search);
    if (message_arena != submessage_arena) {
      response_global_search = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_global_search, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.response_global_search_ = response_global_search;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_global_search)
}

// optional .cpb.remote.ResponseTranscoderStatus response_transcoder_status = 39;
inline bool Message::_internal_has_response_transcoder_status() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_transcoder_status_ != nullptr);
  return value;
}
inline bool Message::has_response_transcoder_status() const {
  return _internal_has_response_transcoder_status();
}
inline void Message::clear_response_transcoder_status() {
  if (_impl_.response_transcoder_status_ != nullptr) _impl_.response_transcoder_status_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::cpb::remote::ResponseTranscoderStatus& Message::_internal_response_transcoder_status() const {
  const ::cpb::remote::ResponseTranscoderStatus* p = _impl_.response_transcoder_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseTranscoderStatus&>(
      ::cpb::remote::_ResponseTranscoderStatus_default_instance_);
}
inline const ::cpb::remote::ResponseTranscoderStatus& Message::response_transcoder_status() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_transcoder_status)
  return _internal_response_transcoder_status();
}
inline void Message::unsafe_arena_set_allocated_response_transcoder_status(
    ::cpb::remote::ResponseTranscoderStatus* response_transcoder_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_transcoder_status_);
  }
  _impl_.response_transcoder_status_ = response_transcoder_status;
  if (response_transcoder_status) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_transcoder_status)
}
inline ::cpb::remote::ResponseTranscoderStatus* Message::release_response_transcoder_status() {
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::cpb::remote::ResponseTranscoderStatus* temp = _impl_.response_transcoder_status_;
  _impl_.response_transcoder_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseTranscoderStatus* Message::unsafe_arena_release_response_transcoder_status() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_transcoder_status)
  _impl_._has_bits_[0] &= ~0x20000000u;
  ::cpb::remote::ResponseTranscoderStatus* temp = _impl_.response_transcoder_status_;
  _impl_.response_transcoder_status_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseTranscoderStatus* Message::_internal_mutable_response_transcoder_status() {
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.response_transcoder_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseTranscoderStatus>(GetArenaForAllocation());
    _impl_.response_transcoder_status_ = p;
  }
  return _impl_.response_transcoder_status_;
}
inline ::cpb::remote::ResponseTranscoderStatus* Message::mutable_response_transcoder_status() {
  ::cpb::remote::ResponseTranscoderStatus* _msg = _internal_mutable_response_transcoder_status();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_transcoder_status)
  return _msg;
}
inline void Message::set_allocated_response_transcoder_status(::cpb::remote::ResponseTranscoderStatus* response_transcoder_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_transcoder_status_;
  }
  if (response_transcoder_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_transcoder_status);
    if (message_arena != submessage_arena) {
      response_transcoder_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_transcoder_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.response_transcoder_status_ = response_transcoder_status;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_transcoder_status)
}

// optional .cpb.remote.ResponseGlobalSearchStatus response_global_search_status = 40;
inline bool Message::_internal_has_response_global_search_status() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_global_search_status_ != nullptr);
  return value;
}
inline bool Message::has_response_global_search_status() const {
  return _internal_has_response_global_search_status();
}
inline void Message::clear_response_global_search_status() {
  if (_impl_.response_global_search_status_ != nullptr) _impl_.response_global_search_status_->Clear();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const ::cpb::remote::ResponseGlobalSearchStatus& Message::_internal_response_global_search_status() const {
  const ::cpb::remote::ResponseGlobalSearchStatus* p = _impl_.response_global_search_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseGlobalSearchStatus&>(
      ::cpb::remote::_ResponseGlobalSearchStatus_default_instance_);
}
inline const ::cpb::remote::ResponseGlobalSearchStatus& Message::response_global_search_status() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_global_search_status)
  return _internal_response_global_search_status();
}
inline void Message::unsafe_arena_set_allocated_response_global_search_status(
    ::cpb::remote::ResponseGlobalSearchStatus* response_global_search_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_global_search_status_);
  }
  _impl_.response_global_search_status_ = response_global_search_status;
  if (response_global_search_status) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_global_search_status)
}
inline ::cpb::remote::ResponseGlobalSearchStatus* Message::release_response_global_search_status() {
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::cpb::remote::ResponseGlobalSearchStatus* temp = _impl_.response_global_search_status_;
  _impl_.response_global_search_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseGlobalSearchStatus* Message::unsafe_arena_release_response_global_search_status() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_global_search_status)
  _impl_._has_bits_[0] &= ~0x40000000u;
  ::cpb::remote::ResponseGlobalSearchStatus* temp = _impl_.response_global_search_status_;
  _impl_.response_global_search_status_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseGlobalSearchStatus* Message::_internal_mutable_response_global_search_status() {
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.response_global_search_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseGlobalSearchStatus>(GetArenaForAllocation());
    _impl_.response_global_search_status_ = p;
  }
  return _impl_.response_global_search_status_;
}
inline ::cpb::remote::ResponseGlobalSearchStatus* Message::mutable_response_global_search_status() {
  ::cpb::remote::ResponseGlobalSearchStatus* _msg = _internal_mutable_response_global_search_status();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_global_search_status)
  return _msg;
}
inline void Message::set_allocated_response_global_search_status(::cpb::remote::ResponseGlobalSearchStatus* response_global_search_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_global_search_status_;
  }
  if (response_global_search_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_global_search_status);
    if (message_arena != submessage_arena) {
      response_global_search_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_global_search_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.response_global_search_status_ = response_global_search_status;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_global_search_status)
}

// optional .cpb.remote.ResponseListFiles response_list_files = 52;
inline bool Message::_internal_has_response_list_files() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_list_files_ != nullptr);
  return value;
}
inline bool Message::has_response_list_files() const {
  return _internal_has_response_list_files();
}
inline void Message::clear_response_list_files() {
  if (_impl_.response_list_files_ != nullptr) _impl_.response_list_files_->Clear();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const ::cpb::remote::ResponseListFiles& Message::_internal_response_list_files() const {
  const ::cpb::remote::ResponseListFiles* p = _impl_.response_list_files_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseListFiles&>(
      ::cpb::remote::_ResponseListFiles_default_instance_);
}
inline const ::cpb::remote::ResponseListFiles& Message::response_list_files() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_list_files)
  return _internal_response_list_files();
}
inline void Message::unsafe_arena_set_allocated_response_list_files(
    ::cpb::remote::ResponseListFiles* response_list_files) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_list_files_);
  }
  _impl_.response_list_files_ = response_list_files;
  if (response_list_files) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_list_files)
}
inline ::cpb::remote::ResponseListFiles* Message::release_response_list_files() {
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::cpb::remote::ResponseListFiles* temp = _impl_.response_list_files_;
  _impl_.response_list_files_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseListFiles* Message::unsafe_arena_release_response_list_files() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_list_files)
  _impl_._has_bits_[1] &= ~0x00000002u;
  ::cpb::remote::ResponseListFiles* temp = _impl_.response_list_files_;
  _impl_.response_list_files_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseListFiles* Message::_internal_mutable_response_list_files() {
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.response_list_files_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseListFiles>(GetArenaForAllocation());
    _impl_.response_list_files_ = p;
  }
  return _impl_.response_list_files_;
}
inline ::cpb::remote::ResponseListFiles* Message::mutable_response_list_files() {
  ::cpb::remote::ResponseListFiles* _msg = _internal_mutable_response_list_files();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_list_files)
  return _msg;
}
inline void Message::set_allocated_response_list_files(::cpb::remote::ResponseListFiles* response_list_files) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_list_files_;
  }
  if (response_list_files) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_list_files);
    if (message_arena != submessage_arena) {
      response_list_files = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_list_files, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.response_list_files_ = response_list_files;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_list_files)
}

// optional .cpb.remote.ResponseSavedRadios response_saved_radios = 54;
inline bool Message::_internal_has_response_saved_radios() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_saved_radios_ != nullptr);
  return value;
}
inline bool Message::has_response_saved_radios() const {
  return _internal_has_response_saved_radios();
}
inline void Message::clear_response_saved_radios() {
  if (_impl_.response_saved_radios_ != nullptr) _impl_.response_saved_radios_->Clear();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const ::cpb::remote::ResponseSavedRadios& Message::_internal_response_saved_radios() const {
  const ::cpb::remote::ResponseSavedRadios* p = _impl_.response_saved_radios_;
  return p != nullptr ? *p : reinterpret_cast<const ::cpb::remote::ResponseSavedRadios&>(
      ::cpb::remote::_ResponseSavedRadios_default_instance_);
}
inline const ::cpb::remote::ResponseSavedRadios& Message::response_saved_radios() const {
  // @@protoc_insertion_point(field_get:cpb.remote.Message.response_saved_radios)
  return _internal_response_saved_radios();
}
inline void Message::unsafe_arena_set_allocated_response_saved_radios(
    ::cpb::remote::ResponseSavedRadios* response_saved_radios) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_saved_radios_);
  }
  _impl_.response_saved_radios_ = response_saved_radios;
  if (response_saved_radios) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cpb.remote.Message.response_saved_radios)
}
inline ::cpb::remote::ResponseSavedRadios* Message::release_response_saved_radios() {
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::cpb::remote::ResponseSavedRadios* temp = _impl_.response_saved_radios_;
  _impl_.response_saved_radios_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cpb::remote::ResponseSavedRadios* Message::unsafe_arena_release_response_saved_radios() {
  // @@protoc_insertion_point(field_release:cpb.remote.Message.response_saved_radios)
  _impl_._has_bits_[1] &= ~0x00000008u;
  ::cpb::remote::ResponseSavedRadios* temp = _impl_.response_saved_radios_;
  _impl_.response_saved_radios_ = nullptr;
  return temp;
}
inline ::cpb::remote::ResponseSavedRadios* Message::_internal_mutable_response_saved_radios() {
  _impl_._has_bits_[1] |= 0x00000008u;
  if (_impl_.response_saved_radios_ == nullptr) {
    auto* p = CreateMaybeMessage<::cpb::remote::ResponseSavedRadios>(GetArenaForAllocation());
    _impl_.response_saved_radios_ = p;
  }
  return _impl_.response_saved_radios_;
}
inline ::cpb::remote::ResponseSavedRadios* Message::mutable_response_saved_radios() {
  ::cpb::remote::ResponseSavedRadios* _msg = _internal_mutable_response_saved_radios();
  // @@protoc_insertion_point(field_mutable:cpb.remote.Message.response_saved_radios)
  return _msg;
}
inline void Message::set_allocated_response_saved_radios(::cpb::remote::ResponseSavedRadios* response_saved_radios) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_saved_radios_;
  }
  if (response_saved_radios) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_saved_radios);
    if (message_arena != submessage_arena) {
      response_saved_radios = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_saved_radios, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.response_saved_radios_ = response_saved_radios;
  // @@protoc_insertion_point(field_set_allocated:cpb.remote.Message.response_saved_radios)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace remote
}  // namespace cpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cpb::remote::SongMetadata_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::SongMetadata_Type>() {
  return ::cpb::remote::SongMetadata_Type_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::ResponseListFiles_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::ResponseListFiles_Error>() {
  return ::cpb::remote::ResponseListFiles_Error_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::MsgType>() {
  return ::cpb::remote::MsgType_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::EngineState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::EngineState>() {
  return ::cpb::remote::EngineState_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::RepeatMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::RepeatMode>() {
  return ::cpb::remote::RepeatMode_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::ShuffleMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::ShuffleMode>() {
  return ::cpb::remote::ShuffleMode_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::ReasonDisconnect> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::ReasonDisconnect>() {
  return ::cpb::remote::ReasonDisconnect_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::DownloadItem> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::DownloadItem>() {
  return ::cpb::remote::DownloadItem_descriptor();
}
template <> struct is_proto_enum< ::cpb::remote::GlobalSearchStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cpb::remote::GlobalSearchStatus>() {
  return ::cpb::remote::GlobalSearchStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remotecontrolmessages_2eproto
